# Copyright (C) 2008-2016 CS-SI. All Rights Reserved.
# Author: Yoann Vandoorselaere <yoann.v@libiodef-ids.com>
#
# This file is part of the LibIodef library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIODEFTreeWrapHxx;

use Generate;
@ISA = qw/Generate/;

use strict;
use IODEFTree;

sub     header
{
    my  $self = shift;

    $self->output("
/*****
*
* Copyright (C) 2008-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v\@libiodef-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIODEFTreeWrapHxx package */

#ifndef _LIBIODEF_IODEF_TREE_WRAP_HXX
#define _LIBIODEF_IODEF_TREE_WRAP_HXX

#include <list>
#include <string>

#include \"libiodef.h\"
#include \"iodef-time.hxx\"

using namespace std;


class IODEFiodef_data {
};
");
}

sub footer
{
    my  $self = shift;

    $self->output("");
    $self->output("#define $_->[0] $_->[1]\n") foreach ( @{ $self->{type_list} } );
    $self->output("\n");
    $self->output("#endif /* _LIBIODEF_IODEF_TREE_WRAP */\n");
}

sub struct_definition
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $priv = 0;

    $self->output("class IODEF$struct->{short_typename} {\n");
    foreach my $member ( @{ $struct->{field_list} } ) {
        if ( (!($member->{metatype} & &METATYPE_PRIMITIVE)) &&
               ($member->{metatype} & (&METATYPE_STRUCT|&METATYPE_LIST|&METATYPE_UNION)) ) {

            if ( $priv == 0 ) {
                $self->output("\n    private:\n");
                $priv = 1;
            }

            my $type;

            if ( $member->{metatype} & (&METATYPE_LIST) ) {
                $type = "std::list<IODEF$member->{short_typename} *>";
            } elsif ( $member->{metatype} & (&METATYPE_UNION) ) {
                $self->output("        union {\n");

                foreach my $umember ( @{ $member->{member_list} } ) {
                    $type = "IODEF$umember->{short_typename} *";
                    $self->output("                $type $umember->{short_typename};\n");
                }
                $self->output("        } $member->{name};\n");
                $self->output("        $member->{typename} $member->{var};\n");

                next;
            } else {
                $type = "IODEF$member->{short_typename} *";
            }

            $self->output("        $type $member->{short_typename};\n");
        }
    }

    $self->output("\n    protected:\n");
    $self->output("        $struct->{typename} *_priv;\n\n");
    $self->output("    public:\n");
}

sub struct_constructor
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("        IODEF$struct->{short_typename}();\n");
    $self->output("        IODEF$struct->{short_typename}($struct->{typename} *ptr);\n");
    $self->output("        IODEF$struct->{short_typename} *copy(IODEF$struct->{short_typename} *dst);\n");
    $self->output("        IODEF$struct->{short_typename} *clone();\n");
    $self->output("        int compare(IODEF$struct->{short_typename} *obj1);\n");
}


sub struct_ref
{
    my $self = shift;
    my $tree = shift;
    my $struct = shift;

    $struct->{refcount} or return;
    $self->output("        IODEF$struct->{short_typename} *ref();\n");

}

sub struct_destroy
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("        ~IODEF$struct->{short_typename}();\n");
}

sub struct_field_normal
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $name = shift || $field->{name};
    my  $ptr = "";
    my  $refer = "";

    $ptr = "*", $refer = "*" if ( $field->{metatype} & &METATYPE_STRUCT );
    $refer = "*" if ( $field->{metatype} & &METATYPE_OPTIONAL_INT );

    if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
        $self->output("        void unset_${name}();\n");
    }

    my $type = $field->{typename};
    if ( $field->{typename} eq "libiodef_string_t" ) {
        $type = "std::string";
    } elsif ( $field->{typename} eq "iodef_time_t" ) {
        $type = "IODEFTime";
    } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
        $type = "IODEF$field->{short_typename}";
    } else {
        $type = "$field->{typename}";
    }

    $self->output("        $type ${refer}get_${name}();\n");

    my $field_name = ($name eq "class") ? "class_str" : $name;

    $self->output("        void set_${name}($type ${ptr}${field_name});\n");
    $self->output("        $type *new_${name}();\n\n");
}

sub     struct_field_union
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;

    $self->output("        $field->{typename} get_$field->{var}();\n");

    foreach my $member ( @{ $field->{member_list} } ) {
        $self->struct_field_normal($tree, $struct,
                                   { metatype => &METATYPE_STRUCT,
                                     name => "$field->{name}.$member->{name}",
                                     typename => $member->{typename},
                                     short_typename => $member->{short_typename},
                                     ptr => $member->{ptr}
                                   }, $member->{name});
    }
}

sub     struct_field_list
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;

    my $type = $field->{typename};
    if ( $field->{typename} eq "libiodef_string_t" ) {
        $type = "std::string";
    } elsif ( !($field->{metatype} & (&METATYPE_PRIMITIVE)) ) {
        $type = "IODEF$field->{short_typename}";
    } else {
        $type = "$field->{typename}";
    }

    $self->output("
        std::list<$type *> *get_$field->{short_name}_list();
        void set_$field->{short_name}($type *object, int pos);
        $type *new_$field->{short_name}(int pos);

");
}

sub     struct_fields
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    foreach my $field ( @{ $struct->{field_list} } ) {
        $self->struct_field_normal($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_NORMAL );
        $self->struct_field_list($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_LIST );
        $self->struct_field_union($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_UNION );
    }
}

sub     struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->struct_definition($tree, $struct);
    $self->struct_constructor($tree, $struct);
#    $self->struct_ref($tree, $struct);
    $self->struct_destroy($tree, $struct);
    $self->struct_fields($tree, $struct);
    $self->output("};\n\n");
}

sub     enum
{
    my  $self = shift;
    my  $tree = shift;
    my  $enum = shift;
    my  $cnt = 0;

    #FIXME
    return;

    foreach ( @{ $enum->{desc} } ) {
        if ( $cnt == 0 ) {
            $self->output("typedef enum {\n");

        } elsif ( $cnt + 1 == @{ $enum->{desc} } ) {
            $self->output("\} $enum->{typename};\n");

        } else {
            my $val = $_;

            $val =~ s/\(.*\)//;
            $self->output("$val\n");
        }

        $cnt++;
    }

    $self->output("\n\n");
    $self->output("$enum->{typename} iodef_$enum->{short_typename}_to_numeric(const char *name);", "\n");
    $self->output("const char *iodef_$enum->{short_typename}_to_string($enum->{typename} val);", "\n");
    $self->output("\n\n");
}

sub     pre_declared
{
    my  $self = shift;
    my  $tree = shift;
    my  $pre_declared = shift;

    if ( $pre_declared->{metatype} & &METATYPE_STRUCT ) {
    $self->output("
typedef struct iodef_$pre_declared->{short_typename} $pre_declared->{typename};

");
    } else {
    $self->output("
typedef enum iodef_$pre_declared->{short_typename} $pre_declared->{typename};

");
    }
}

1;
