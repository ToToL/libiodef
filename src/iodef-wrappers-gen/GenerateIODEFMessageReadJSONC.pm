# Copyright (C) 2003-2012 CS-SI. All Rights Reserved.
# Author: Nicolas Delon <nicolas.delon@libiodef-ids.com>
#
# This file is part of the LibIodef library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIODEFMessageReadJSONC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IODEFTree;

sub     header
{
     my $self = shift;

     $self->output("
/*****
*
* Copyright (C) 2001-2012 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v\@libiodef-ids.com>
* Author: Nicolas Delon <nicolas.delon\@libiodef-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIODEFMessageReadJSONC package */
#include \"config.h\"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include \"libiodef-error.h\"
#include \"libiodef-inttypes.h\"
#include \"libiodef-list.h\"
#include \"libiodef-extract.h\"
#include \"libiodef-io.h\"
#include \"iodef-document-id.h\"
#include \"iodef.h\"
#include \"iodef-tree-wrap.h\"

#define JSMN_PARENT_LINKS

#include \"iodef-wrappers-gen/jsmn/jsmn.h\"
#include \"iodef-wrappers-gen/jsmn/jsmn.c\"

#ifndef MIN
# define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

typedef struct {
        const char *input;
        jsmntok_t jtok[1024];
        int jtoksize;
        unsigned int idx;
\} json_data_t;





// code from http://stackoverflow.com/a/4609989/697313
static int unicode_to_utf8(unsigned int codepoint, libiodef_string_t *out)
{
          char val;

          if ( codepoint < 0x80 )
                libiodef_string_ncat(out, (char *) &codepoint, 1);

          else if ( codepoint < 0x800 ) {
                val = 192 + codepoint / 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else if ( codepoint - 0xd800u < 0x800 )
                return 0; // surrogate must have been treated earlier

          else if ( codepoint < 0x10000 ) {
                val = 224 + codepoint / 4096;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint /64 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else if ( codepoint < 0x110000 ) {
                val = 240 + codepoint / 262144;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint / 4096 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint / 64 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else
                return -1;

          return 1;
}


static int hexval(char c)
{
        if ( c >= '0' && c <= '9' )
                return c - '0';

        else if ( c >= 'a' && c <= 'f' )
                return c - 'a' + 10;

        else if ( c >= 'A' && c <= 'F' )
                return c - 'A' + 10;

        else return -1;
}


static int unescape_unicode(const char *in, const char *end)
{
        int h1, h2, h3, h4;

        if ( in + 4 > end )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"unicode sequence must be at least 4 characters long\");;

        if ( (h1 = hexval(in[0])) < 0 || (h2 = hexval(in[1])) < 0 || (h3 = hexval(in[2])) < 0 || (h4 = hexval(in[3])) < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"invalid unicode escape: '%.6s'\", in - 2);

        return h1 << 12 | h2 << 8 | h3 << 4 | h4;
}


static int unescape_string(libiodef_string_t *out, const char *in, size_t size)
{
        int ret;
        const char *end = in + size;

        for ( ; in < end; in++ ) {
                if ( *in != '\\\\' ) {
                        ret = libiodef_string_ncat(out, in, 1);
                        continue;
                }

                in++;
                switch(*in) {
                        case '\"':
                        case '/':
                        case '\\\\':
                                ret = libiodef_string_ncat(out, in, 1);
                                break;

                        case 'b':
                                ret = libiodef_string_ncat(out, \"\\b\", 1);
                                break;
                        case 't':
                                ret = libiodef_string_ncat(out, \"\\t\", 1);
                                break;
                        case 'n':
                                ret = libiodef_string_ncat(out, \"\\n\", 1);
                                break;
                        case 'f':
                                ret = libiodef_string_ncat(out, \"\\f\", 1);
                                break;
                        case 'r':
                                ret = libiodef_string_ncat(out, \"\\r\", 1);
                                break;

                        case 'u': {
                                int codepoint;

                                codepoint = unescape_unicode(in + 1, end);
                                if ( codepoint < 0 )
                                        return codepoint;

                                if ( (codepoint & 0xfc00) == 0xd800 ) {
                                        /*
                                         * high surrogate; need one more unicode to succeed
                                         */
                                        in += 7;

                                        ret = unescape_unicode(in, end);
                                        if ( ret < 0 )
                                                return ret;

                                        codepoint = 0x10000 + ((codepoint - 0xd800) << 10) + (ret - 0xdc00);
                                }

                                ret = unicode_to_utf8(codepoint, out);
                                if ( ret < 0 )
                                        return ret;

                                in += 4;
                                break;
                        }

                        default:
                                ret = libiodef_string_ncat(out, in, 1);
                                break;
                }

                if ( ret < 0 )
                        return ret;
        }

        return 0;
}


static int __get_float(json_data_t *ctrl, float *value)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        *value = strtof(ctrl->input + j->start, &end);
        if ( end != (str + len) )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"error decoding to real\");

        return 0;
\}



static int64_t __get_integer(json_data_t *ctrl)
{
        int64_t ret;
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        if ( j->type != JSMN_PRIMITIVE )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"JSON value is not a primitive\");

        ret = strtoll(ctrl->input + j->start, &end, 10);
        if ( end != (str + len) )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"error decoding to integer\");

        return ret;
\}


static int __get_string_copy(json_data_t *ctrl, unsigned int idx, char *out, size_t size)
{
        size_t insize;
        jsmntok_t *j = &ctrl->jtok[idx];
        const char *input = ctrl->input + j->start;

        insize = j->end - j->start;

        if ( insize == 0 ) {
                *out = '\\0';
                return 0;
        }

        else if ( insize >= size )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"buffer is too small\");

        strncpy(out, input, MIN(size, j->end - j->start));
        out[j->end - j->start] = 0;

        return 0;
}

static int __get_string(json_data_t *ctrl, libiodef_string_t *out)
{
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        const char *input = ctrl->input + j->start;

        if ( j->type != JSMN_STRING )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"JSON value is not string\");

        if ( j->end - j->start == 0 )
                return 0;

        return unescape_string(out, input, j->end - j->start);
\}


static int jsoneq(json_data_t *data, jsmntok_t *tok, const char *wanted)
{
    size_t size = tok->end - tok->start;
    const char *start = data->input + tok->start;

    if ( tok->type == JSMN_STRING && strlen(wanted) == size && strncmp(start, wanted, size) == 0)
            return 0;

    return -1;
\}



static int __get_json_key(json_data_t *ctrl, const char *wanted, unsigned int sidx)
{
        unsigned int i;

        for ( i = 0; i < ctrl->jtok[sidx].size * 2; i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[sidx + i], wanted) == 0 )
                        return i;
        }

        return -1;
}
");
}

sub     struct_field_normal
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $type = shift || $field->{value_type};
    my  $var_type = shift || "$field->{typename}";

    if ( $field->{metatype} & &METATYPE_LIST ) {
        if ( $field->{metatype} & &METATYPE_ENUM ){
                $self->output("
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        int ret = iodef_$struct->{short_typename}_$field->{short_name}_to_numeric(buf);
                                        if ( ret != -1 )
                                                iodef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret, IODEF_LIST_APPEND);
");
        } elsif ( $field->{metatype} & &METATYPE_OPTIONAL_INT ){
                $self->output("{
                                        int64_t ret;

                                        ret = __get_integer(ctrl);
                                        if ( ret < 0 )
                                                return ret;

                                        iodef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret, IODEF_LIST_APPEND);
                              \}
");
        } else {
                $self->output("
                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
");
        }

        $self->output("
                                                            ctrl->idx += 1;
                    \}

                                                ctrl->idx -= 1;
                                                ");

    } else {
        if ( $field->{metatype} & &METATYPE_ENUM ){
                $self->output("
                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_$struct->{short_typename}_$field->{short_name}_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret);
");
        } elsif ( $field->{metatype} & &METATYPE_OPTIONAL_INT ){
                $self->output("
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret);
");
        } elsif ( $field->{typename} eq "iodef_time_t" ){
                $self->output("
                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, time);
");

        } elsif ( $field->{typename} eq "iodef_data_t" ){
            if ( not $struct->{short_typename} eq "additional_data" ) {
                $self->output("
                        int ret;
                        iodef_data_t *data;
                        libiodef_string_t *str;

                        ret = iodef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &data);
                        if ( ret < 0 )
                                return ret;

                        ret = libiodef_string_new(&str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 ) {
                                libiodef_string_destroy(str);
                                return ret;
                        }

                        ret = iodef_data_set_byte_string_dup(data, (const unsigned char *) libiodef_string_get_string(str), libiodef_string_get_len(str));
                        libiodef_string_destroy(str);
");
            } else {
                $self->output("
                        int ret;
                        char buf[128];
                        iodef_data_t *data;
                        iodef_additional_data_type_t type;

                        ret = __get_json_key(ctrl, \"type\", obj_idx);
                        if ( ret < 0 )
                                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"type argument required for additional data object\");

                        ret = __get_string_copy(ctrl, obj_idx + ret + 1, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        type = iodef_additional_data_type_to_numeric(buf);
                        if ( type < 0 )
                                return type;

                        ret = iodef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &data);
                        if ( ret < 0 )
                                return ret;

                        switch(type) {
                                case IODEF_ADDITIONAL_DATA_TYPE_REAL: {
                                        float val;

                                        ret = __get_float(ctrl, &val);
                                        if ( ret < 0 )
                                                return ret;

                                        iodef_data_set_float(data, val);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_BYTE:
                                case IODEF_ADDITIONAL_DATA_TYPE_BOOLEAN:
                                case IODEF_ADDITIONAL_DATA_TYPE_INTEGER: {
                                        int64_t val;

                                        val = __get_integer(ctrl);
                                        if ( val < 0 )
                                                return val;

                                        iodef_data_set_int(data, val);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_DATE_TIME: {
                                        iodef_time_t *time;
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        ret = iodef_time_new_from_string(&time, buf);
                                        if ( ret < 0 )
                                                return ret;

                                        iodef_data_set_time(data, time);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_STRING:
                                case IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING:
                                case IODEF_ADDITIONAL_DATA_TYPE_CHARACTER:
                                case IODEF_ADDITIONAL_DATA_TYPE_NTPSTAMP:
                                case IODEF_ADDITIONAL_DATA_TYPE_PORTLIST:
                                case IODEF_ADDITIONAL_DATA_TYPE_XML: {
                                        libiodef_string_t *str;

                                        ret = libiodef_string_new(&str);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 ) {
                                                libiodef_string_destroy(str);
                                                return ret;
                                        }

                                        if ( type == IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING )
                                                ret = iodef_data_set_byte_string_dup(data, (const unsigned char *) libiodef_string_get_string(str), libiodef_string_get_len(str));
                                        else
                                                ret = iodef_data_set_char_string_dup_fast(data, libiodef_string_get_string(str), libiodef_string_get_len(str));

                                        libiodef_string_destroy(str);
                                        break;
                                }

                                default:
                                        return -1;
                        }
");
            }
        } elsif ( $field->{typename} eq "float" ){
                $self->output("
                        int ret;
                        float *value;

                        ret = iodef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &value);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_float(ctrl, value);
                        if ( ret < 0 )
                                return ret;
");
        } else {
                $self->output("
                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
");

        }


    }
}

sub     struct_field_struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $name = shift || $field->{name};

    if ( $field->{metatype} & &METATYPE_LIST ) {
           $self->output("
                                                int ret;
                                                iodef_${name}_t *${name};

                                                ret = iodef_$struct->{short_typename}_new_${name}($struct->{short_typename}, &${name}, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_${name}_read_json(${name}, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;
");
    } else {
           $self->output("
                        int ret;
                        iodef_${name}_t *${name};

                        ret = iodef_$struct->{short_typename}_new_${name}($struct->{short_typename}, &${name});
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_${name}_read_json(${name}, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;
");
    }
}

sub     struct_field_union
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $i = shift || 0;

    foreach my $member ( @{$field->{member_list}} ) {
        $i += 1;
        if ( $i == 1 ) {
            $self->output("
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"$member->{name}\") == 0){
                        ctrl->idx++;
");
        } else {
            $self->output("
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"$member->{name}\") == 0){
                        ctrl->idx++;
");
        }
        $self->struct_field_struct($tree, $struct, $member);
        $self->output("
                }
");
    }
}

sub     struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $i = 0;

    $self->output("
/**
 * iodef_$struct->{short_typename}_read:
 * \@$struct->{short_typename}: Pointer to a #$struct->{typename} object.
 * \@json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_$struct->{short_typename} from the \@json message, and
 * store it into \@$struct->{short_typename}.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_$struct->{short_typename}_read_json($struct->{typename} *$struct->{short_typename}, json_data_t *ctrl)
\{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
");


if ( $struct->{short_typename} eq "additional_data" ) {
        $self->output("
                unsigned int obj_idx = ctrl->idx;
");
}

$self->output("
        //printf(\"READ $struct->{short_typename} idx=%u rsize=%lu type=%d\\n\", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"unexpected JSON object type\");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf(\"MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\\n\", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"_self\") == 0 ) {
                        ctrl->idx++;
                        continue;
                }
");

    foreach my $field ( @{$struct->{field_list}} ) {
        my $name = ($field->{metatype} & (&METATYPE_STRUCT | &METATYPE_LIST)) ? $field->{short_name} : $field->{name};

        unless ( $field->{metatype} & &METATYPE_UNION ) {
            $i += 1;
            if ( $i == 1 ) {
                $self->output("
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"${name}\") == 0 ) {
                        ctrl->idx++;
");
            } else {
                $self->output("
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"${name}\") == 0 ) {
                        ctrl->idx++;
");

            }
        }

        if ( $field->{metatype} & &METATYPE_NORMAL ) {

            if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
                $self->struct_field_normal($tree, $struct, $field);

            } elsif ( $field->{metatype} & &METATYPE_ENUM ) {
                $self->struct_field_normal($tree, $struct, $field, "int32", "int32_t");

            } else {
                $self->struct_field_struct($tree, $struct, $field);
            }
            $self->output("
                }
");

        } elsif ( $field->{metatype} & &METATYPE_LIST ) {
            $self->output("
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {
");

            if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
                $self->struct_field_normal($tree, $struct, $field);

            } else {
                $self->struct_field_struct($tree, $struct, $field, $field->{short_name});
            }
            $self->output("
                        }
                }
");

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->struct_field_union($tree, $struct, $field, $i);
        }

    }

    $self->output("
                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"unexpected field '%.*s' while reading $struct->{short_typename}\", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
\}
");
}

sub        footer
{
    my        $self = shift;
    my        $tree = shift;
    my        $first = 1;

    $self->output("
int iodef_object_new_from_json(iodef_object_t **object, const char *json_message)
{
        int ret, selfkey;
        jsmn_parser parser;
        json_data_t ctrl;

        jsmn_init(&parser);
        ctrl.idx = 0;
        ctrl.input = json_message;

        ret = ctrl.jtoksize = jsmn_parse(&parser, json_message, strlen(json_message), ctrl.jtok, sizeof(ctrl.jtok) / sizeof(*ctrl.jtok));
        if ( ret < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"error parsing json message\");

        selfkey = __get_json_key(&ctrl, \"_self\", 0);
        if ( selfkey < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"json message miss '_self' attribute\");
");


foreach my $obj ( sort { $a->{id} <=> $b->{id} } map { ($_->{obj_type} != &OBJ_PRE_DECLARED ? $_ : () ) } @{ $tree->{obj_list} } ) {

        if ( $obj->{obj_type} == &OBJ_STRUCT ) {
                if ( ! $first ) {
                    $self->output("else ");
                } else {
                    $first = 0;
                }

                $self->output("
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], \"$obj->{typename}\") == 0 ) {
                ret = iodef_$obj->{short_typename}_new((iodef_$obj->{short_typename}_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_$obj->{short_typename}_read_json((iodef_$obj->{short_typename}_t *) *object, &ctrl);
        }
        ");
        }
}

$self->output("
        else {
                ret = libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, \"unknown object type '%s'\", \"\");
        }

        return ret;
}

")
}

1;
