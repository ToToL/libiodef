# Copyright (C) 2003-2016 CS-SI. All Rights Reserved.
# Author: Nicolas Delon <nicolas.delon@libiodef-ids.com>
#
# This file is part of the LibIodef library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIODEFMessageIdH;

use Generate;
@ISA = qw/Generate/;

use strict;
use IODEFTree;

sub max ($$) { $_[$_[0] < $_[1]] }

my %previd_hash;
my %previd_rev_hash;
our $max_id = 0;

open FILE, "../include/iodef-document-id.h";
while (my $line = <FILE>) {
        chomp($line);

        if ( not $line =~ /define\s*[A-Z_]+\s*\d+/ ) {
                next;
        }

        my ($keyword, $key, $value) = split(' ', $line);
        $previd_hash{$key} = $value;
        $previd_rev_hash{$value} = 1;
}
close FILE;


sub getPreviousID {
        my $tag = shift;
        return $previd_hash{$tag};
}


sub genNewID {
        my $i;
        my $idmin = shift;

        for ($i = $idmin; defined $previd_rev_hash{$i}; $i++) {};

        $previd_rev_hash{$i} = 1;
        return $i;
}


sub     header
{
     my $self = shift;
     my $tree = shift;
     my $id = 0;

     $self->output("
/* Auto-generated by the GenerateIODEFMessageIdH package */

#ifndef _LIBIODEF_IODEF_DOCUMENT_ID_H
#define _LIBIODEF_IODEF_DOCUMENT_ID_H

/*
 * Misc value
 */

#define IODEF_MSG_OWN_FORMAT                                 253
#define IODEF_MSG_END_OF_TAG                                 254

/*
 * Tag value
 */

");

     foreach my $struct ( @{ $tree->{struct_list} } ) {
         if ( ! $struct->{toplevel} ) {
             my $id = getPreviousID("IODEF_MSG_" . uc($struct->{short_typename}) . "_TAG");
             if (! defined($id) ) {
                $id = genNewID($max_id);
             }

             $max_id = max($id + 1, $max_id);
             $self->output("#define ", "IODEF_MSG_" . uc($struct->{short_typename}) . "_TAG ", $id, "\n");
         }
     }

     $self->output("\n\n");
}

sub     footer
{
    my  $self = shift;

    $self->output("#endif /* _LIBIODEF_IODEF_DOCUMENT_ID_H */", "\n");
}

sub     struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("/*\n",
                  " * IODEF \u$struct->{short_typename}\n",
                  " */\n");

    foreach my $field ( @{ $struct->{field_list} } ) {

        if ( $field->{metatype} & (&METATYPE_PRIMITIVE | &METATYPE_ENUM) ) {
            my $tag = "IODEF_MSG_" . uc($struct->{short_typename}) . "_" . uc($field->{short_name});

            my $id = getPreviousID($tag);
            if ( ! defined $id ) {
                $id = genNewID($max_id);
            }

            $self->output("#define ", $tag, " ", $id, "\n");
        }
    }

    $self->output("\n\n");
}

1;
