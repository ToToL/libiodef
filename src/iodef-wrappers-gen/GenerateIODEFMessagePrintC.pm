# Copyright (C) 2003-2016 CS-SI. All Rights Reserved.
# Author: Nicolas Delon <nicolas.delon@libiodef-ids.com>
#
# This file is part of the LibIodef library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIODEFMessagePrintC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IODEFTree;

sub        header
{
    my        $self = shift;

    $self->output("
/*****
*
* Copyright (C) 2004-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v\@libiodef-ids.com>
* Author: Nicolas Delon <nicolas.delon\@libiodef-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIODEFMessagePrintC package */

#include \"config.h\"
#include \"libmissing.h\"

#include <stdio.h>

#include \"iodef.h\"
#include \"iodef-tree-wrap.h\"
#include \"iodef-document-print.h\"


static int indent = 0;

static void print_indent(libiodef_io_t *fd)
\{
        int cnt;

        for ( cnt = 0; cnt < indent; cnt++ )
                libiodef_io_write(fd, \" \", 1);
\}



static void print_string(libiodef_string_t *string, libiodef_io_t *fd)
\{
        if ( libiodef_string_is_empty(string) )
                libiodef_io_write(fd, \"<empty>\", 7);
        else
                libiodef_io_write(fd, libiodef_string_get_string(string), libiodef_string_get_len(string));
\}



static void print_uint8(uint8_t i, libiodef_io_t *fd)
\{
        int len;
        char buf[sizeof(\"255\")];

        /*
         * %hh convertion specifier is not portable.
         */
        len = snprintf(buf, sizeof(buf), \"\%u\", (unsigned int) i);
        libiodef_io_write(fd, buf, len);
\}


static void print_uint16(uint16_t i, libiodef_io_t *fd)
\{
        int len;
        char buf[sizeof(\"65535\")];

        len = snprintf(buf, sizeof(buf), \"\%hu\", i);
        libiodef_io_write(fd, buf, len);
\}


static void print_int32(int32_t i, libiodef_io_t *fd)
\{
        int len;
        char buf[sizeof(\"4294967296\")];

        len = snprintf(buf, sizeof(buf), \"\%d\", i);
        libiodef_io_write(fd, buf, len);
\}


static void print_uint32(uint32_t i, libiodef_io_t *fd)
\{
        int len;
        char buf[sizeof(\"4294967296\")];

        len = snprintf(buf, sizeof(buf), \"\%u\", i);
        libiodef_io_write(fd, buf, len);
\}



static void print_uint64(uint64_t i, libiodef_io_t *fd)
\{
        int len;
        char buf[sizeof(\"18446744073709551616\")];

        len = snprintf(buf, sizeof(buf), \"%\" LIBIODEF_PRIu64, i);
        libiodef_io_write(fd, buf, len);
\}



static void print_float(float f, libiodef_io_t *fd)
\{
        int len;
        char buf[32];

        len = snprintf(buf, sizeof(buf), \"\%f\", f);
        libiodef_io_write(fd, buf, len);
\}




static void print_time(iodef_time_t *t, libiodef_io_t *fd)
\{
        int len;
        time_t _time;
        struct tm _tm;
        char tmp[32], buf[128];

        _time = iodef_time_get_sec(t) + iodef_time_get_gmt_offset(t);

        if ( ! gmtime_r(&_time, &_tm) )
                return;

        len = strftime(tmp, sizeof(tmp), \"%d/%m/%Y %H:%M:%S\", &_tm);
        if ( len == 0 )
                return;

        len = snprintf(buf, sizeof(buf), \"%s.%u %+.2d:%.2d\",
                       tmp, iodef_time_get_usec(t), iodef_time_get_gmt_offset(t) / 3600,
                       iodef_time_get_gmt_offset(t) % 3600 / 60);

        libiodef_io_write(fd, buf, len);
\}



/* print data as a string */

static int print_data(iodef_data_t *data, libiodef_io_t *fd)
\{
        int ret;
        libiodef_string_t *out;

        ret = libiodef_string_new(&out);
        if ( ret < 0 )
                return ret;

        ret = iodef_data_to_string(data, out);
        if ( ret < 0 ) {
                libiodef_string_destroy(out);
                return ret;
        }

        libiodef_io_write(fd, libiodef_string_get_string(out), libiodef_string_get_len(out));
        libiodef_string_destroy(out);

        return 0;
\}



static void print_enum(const char *s, int i, libiodef_io_t *fd)
\{
        int len;
        char buf[512];

        if ( ! s )
                s = \"<invalid enum value>\";

        len = snprintf(buf, sizeof(buf), \"\%s (\%d)\", s, i);
        libiodef_io_write(fd, buf, len);
\}

");
}

sub        struct_field_normal
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;
    my        $field = shift;
    my        $refer = "";

    $refer = "*" if ( $field->{metatype} & &METATYPE_OPTIONAL_INT );

    if ( $field->{metatype} & &METATYPE_ENUM ) {
        $self->output("
        \{
                int ${refer}i = iodef_$struct->{short_typename}_get_$field->{name}(ptr);

");

        if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
            $self->output("
                if ( i )
");
        }

        $self->output("

                \{
                        print_indent(fd);
                        libiodef_io_write(fd, \"$field->{name}: \", sizeof(\"$field->{name}: \") - 1);
                        print_enum(iodef_$field->{short_typename}_to_string(${refer}i), ${refer}i, fd);
                        libiodef_io_write(fd, \"\\n\", sizeof(\"\\n\") - 1);
                \}
        \}
");

    } elsif ( $field->{metatype} & &METATYPE_PRIMITIVE ) {

        if ( $field->{metatype} & (&METATYPE_STRUCT|&METATYPE_OPTIONAL_INT) ) {
            $self->output("
        \{
                $field->{typename} *field;
                const char tmp[] = \"$field->{name}: \";

                field = iodef_$struct->{short_typename}_get_$field->{name}(ptr);

                if ( field ) \{
                        print_indent(fd);
                        libiodef_io_write(fd, tmp, sizeof(tmp) - 1);
");

            if ( $struct->{short_typename} eq "additional_data" and $field->{typename} eq "iodef_data_t" ) {
                $self->output("
                        if ( iodef_additional_data_get_type(ptr) != IODEF_ADDITIONAL_DATA_TYPE_NTPSTAMP )
                                print_$field->{value_type}(${refer}field, fd);\n
                        else {
                                int ret;
                                uint64_t i;
                                libiodef_string_t *out;

                                ret = libiodef_string_new(&out);
                                if ( ret < 0 )
                                        return;

                                i = iodef_data_get_int(field);
                                ret = libiodef_string_sprintf(out, \"0x%\" LIBIODEF_PRIx32 \".0x%\" LIBIODEF_PRIx32 \"\", (uint32_t) (i >> 32), (uint32_t) i);
                                if ( ret < 0 ) {
                                        libiodef_string_destroy(out);
                                        return;
                                }

                                libiodef_io_write(fd, libiodef_string_get_string(out), libiodef_string_get_len(out));
                                libiodef_string_destroy(out);
                        }
");
            }
            else {
                $self->output("                        print_$field->{value_type}(${refer}field, fd);\n");
            }

            $self->output("                        libiodef_io_write(fd, \"\\n\", sizeof(\"\\n\") - 1);
                \}
        \}
");

        } else {
            $self->output("
        print_indent(fd);
        libiodef_io_write(fd, \"$field->{name}: \", sizeof(\"$field->{name}: \") - 1);
        print_$field->{value_type}(iodef_$struct->{short_typename}_get_$field->{name}(ptr), fd);
        libiodef_io_write(fd, \"\\n\", sizeof(\"\\n\") - 1);
");
        }

    } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
        $self->output("
        \{
                $field->{typename} *field;

                field = iodef_$struct->{short_typename}_get_$field->{name}(ptr);

                if ( field ) \{
                        print_indent(fd);
                        libiodef_io_write(fd, \"$field->{name}:\\n\", sizeof(\"$field->{name}:\\n\") - 1);
                        iodef_$field->{short_typename}_print(field, fd);
                \}
        \}
");
    }
}

sub        struct_field_union
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;
    my        $field = shift;

    $self->output("
        switch ( iodef_$struct->{short_typename}_get_$field->{var}(ptr) ) \{");

    foreach my $member ( @{ $field->{member_list} } ) {
        $self->output("
        case $member->{value}:
                print_indent(fd);
                libiodef_io_write(fd, \"$member->{name}:\\n\", sizeof(\"$member->{name}:\\n\") - 1);
                iodef_$member->{short_typename}_print(iodef_$struct->{short_typename}_get_$member->{name}(ptr), fd);
                break;
 ");
    }

    $self->output("
        default:
                break;
        \}
");

}

sub        struct_field_list
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;
    my        $field = shift;

    $self->output("
        \{
                char buf[128];
                $field->{typename} *elem = NULL;
                int cnt = 0, len;

                while ( (elem = iodef_$struct->{short_typename}_get_next_$field->{short_name}(ptr, elem)) ) \{
                        print_indent(fd);
");

    if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
        $self->output("
                        len = snprintf(buf, sizeof(buf), \"$field->{short_name}(%d): \", cnt);
                        libiodef_io_write(fd, buf, len);
                        print_$field->{value_type}(elem, fd);
                        libiodef_io_write(fd, \"\\n\", sizeof(\"\\n\") - 1);
");

    } else {
        $self->output("
                        len = snprintf(buf, sizeof(buf), \"$field->{short_name}(%d): \\n\", cnt);
                        libiodef_io_write(fd, buf, len);
                        iodef_$field->{short_typename}_print(elem, fd);
");
    }

    $self->output("
                        cnt++;
                \}
        \}
");
}

sub        struct
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;

    $self->output("
/**
 * iodef_$struct->{short_typename}_print:
 * \@ptr: Pointer to an $struct->{typename} object.
 * \@fd: Pointer to a #libiodef_io_t object where to print \@ptr to.
 *
 * This function will convert \@ptr to a string suitable for writing,
 * and write it to the provided \@fd descriptor.
 */
void iodef_$struct->{short_typename}_print($struct->{typename} *ptr, libiodef_io_t *fd)
\{
        if ( ! ptr )
                return;

");

    if ( $struct->{short_typename} ne "message" ) {
        $self->output("        indent += 8;\n");
    }

    foreach my $field ( @{ $struct->{field_list} } ) {

        if ( $field->{metatype} & &METATYPE_NORMAL ) {
            $self->struct_field_normal($tree, $struct, $field);

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->struct_field_union($tree, $struct, $field);

        } elsif ( $field->{metatype} & &METATYPE_LIST ) {
            $self->struct_field_list($tree, $struct, $field);
        }
    }

    if ( $struct->{short_typename} ne "message" ) {
        $self->output("\n        indent -= 8;\n");
    }

    $self->output("}\n");
}

sub        footer
{
    my        $self = shift;
    my        $tree = shift;
}

1;
