
/*****
*
* Copyright (C) 2001-2012 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@libiodef-ids.com>
* Author: Nicolas Delon <nicolas.delon@libiodef-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIODEFMessageReadJSONC package */
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "libiodef-error.h"
#include "libiodef-inttypes.h"
#include "libiodef-list.h"
#include "libiodef-extract.h"
#include "libiodef-io.h"
#include "iodef-document-id.h"
#include "iodef.h"
#include "iodef-tree-wrap.h"

#define JSMN_PARENT_LINKS

#include "iodef-wrappers-gen/jsmn/jsmn.h"
#include "iodef-wrappers-gen/jsmn/jsmn.c"

#ifndef MIN
# define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

typedef struct {
        const char *input;
        jsmntok_t jtok[1024];
        int jtoksize;
        unsigned int idx;
} json_data_t;





// code from http://stackoverflow.com/a/4609989/697313
static int unicode_to_utf8(unsigned int codepoint, libiodef_string_t *out)
{
          char val;

          if ( codepoint < 0x80 )
                libiodef_string_ncat(out, (char *) &codepoint, 1);

          else if ( codepoint < 0x800 ) {
                val = 192 + codepoint / 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else if ( codepoint - 0xd800u < 0x800 )
                return 0; // surrogate must have been treated earlier

          else if ( codepoint < 0x10000 ) {
                val = 224 + codepoint / 4096;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint /64 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else if ( codepoint < 0x110000 ) {
                val = 240 + codepoint / 262144;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint / 4096 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint / 64 % 64;
                libiodef_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodef_string_ncat(out, &val, 1);
          }

          else
                return -1;

          return 1;
}


static int hexval(char c)
{
        if ( c >= '0' && c <= '9' )
                return c - '0';

        else if ( c >= 'a' && c <= 'f' )
                return c - 'a' + 10;

        else if ( c >= 'A' && c <= 'F' )
                return c - 'A' + 10;

        else return -1;
}


static int unescape_unicode(const char *in, const char *end)
{
        int h1, h2, h3, h4;

        if ( in + 4 > end )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unicode sequence must be at least 4 characters long");;

        if ( (h1 = hexval(in[0])) < 0 || (h2 = hexval(in[1])) < 0 || (h3 = hexval(in[2])) < 0 || (h4 = hexval(in[3])) < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "invalid unicode escape: '%.6s'", in - 2);

        return h1 << 12 | h2 << 8 | h3 << 4 | h4;
}


static int unescape_string(libiodef_string_t *out, const char *in, size_t size)
{
        int ret;
        const char *end = in + size;

        for ( ; in < end; in++ ) {
                if ( *in != '\\' ) {
                        ret = libiodef_string_ncat(out, in, 1);
                        continue;
                }

                in++;
                switch(*in) {
                        case '"':
                        case '/':
                        case '\\':
                                ret = libiodef_string_ncat(out, in, 1);
                                break;

                        case 'b':
                                ret = libiodef_string_ncat(out, "\b", 1);
                                break;
                        case 't':
                                ret = libiodef_string_ncat(out, "\t", 1);
                                break;
                        case 'n':
                                ret = libiodef_string_ncat(out, "\n", 1);
                                break;
                        case 'f':
                                ret = libiodef_string_ncat(out, "\f", 1);
                                break;
                        case 'r':
                                ret = libiodef_string_ncat(out, "\r", 1);
                                break;

                        case 'u': {
                                int codepoint;

                                codepoint = unescape_unicode(in + 1, end);
                                if ( codepoint < 0 )
                                        return codepoint;

                                if ( (codepoint & 0xfc00) == 0xd800 ) {
                                        /*
                                         * high surrogate; need one more unicode to succeed
                                         */
                                        in += 7;

                                        ret = unescape_unicode(in, end);
                                        if ( ret < 0 )
                                                return ret;

                                        codepoint = 0x10000 + ((codepoint - 0xd800) << 10) + (ret - 0xdc00);
                                }

                                ret = unicode_to_utf8(codepoint, out);
                                if ( ret < 0 )
                                        return ret;

                                in += 4;
                                break;
                        }

                        default:
                                ret = libiodef_string_ncat(out, in, 1);
                                break;
                }

                if ( ret < 0 )
                        return ret;
        }

        return 0;
}


static int __get_float(json_data_t *ctrl, float *value)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        *value = strtof(ctrl->input + j->start, &end);
        if ( end != (str + len) )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "error decoding to real");

        return 0;
}



static int64_t __get_integer(json_data_t *ctrl)
{
        int64_t ret;
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        if ( j->type != JSMN_PRIMITIVE )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "JSON value is not a primitive");

        ret = strtoll(ctrl->input + j->start, &end, 10);
        if ( end != (str + len) )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "error decoding to integer");

        return ret;
}


static int __get_string_copy(json_data_t *ctrl, unsigned int idx, char *out, size_t size)
{
        size_t insize;
        jsmntok_t *j = &ctrl->jtok[idx];
        const char *input = ctrl->input + j->start;

        insize = j->end - j->start;

        if ( insize == 0 ) {
                *out = '\0';
                return 0;
        }

        else if ( insize >= size )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "buffer is too small");

        strncpy(out, input, MIN(size, j->end - j->start));
        out[j->end - j->start] = 0;

        return 0;
}

static int __get_string(json_data_t *ctrl, libiodef_string_t *out)
{
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        const char *input = ctrl->input + j->start;

        if ( j->type != JSMN_STRING )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "JSON value is not string");

        if ( j->end - j->start == 0 )
                return 0;

        return unescape_string(out, input, j->end - j->start);
}


static int jsoneq(json_data_t *data, jsmntok_t *tok, const char *wanted)
{
    size_t size = tok->end - tok->start;
    const char *start = data->input + tok->start;

    if ( tok->type == JSMN_STRING && strlen(wanted) == size && strncmp(start, wanted, size) == 0)
            return 0;

    return -1;
}



static int __get_json_key(json_data_t *ctrl, const char *wanted, unsigned int sidx)
{
        unsigned int i;

        for ( i = 0; i < ctrl->jtok[sidx].size * 2; i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[sidx + i], wanted) == 0 )
                        return i;
        }

        return -1;
}

/**
 * iodef_additional_data_read:
 * @additional_data: Pointer to a #iodef_additional_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_additional_data from the @json message, and
 * store it into @additional_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_additional_data_read_json(iodef_additional_data_t *additional_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

                unsigned int obj_idx = ctrl->idx;

        //printf("READ additional_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_additional_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_additional_data_set_restriction(additional_data, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_additional_data_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_additional_data_set_type(additional_data, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "formatid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_additional_data_new_formatid(additional_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_additional_data_new_meaning(additional_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_dtype") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_additional_data_new_ext_dtype(additional_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "data") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_data_t *data;
                        iodef_additional_data_type_t type;

                        ret = __get_json_key(ctrl, "type", obj_idx);
                        if ( ret < 0 )
                                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "type argument required for additional data object");

                        ret = __get_string_copy(ctrl, obj_idx + ret + 1, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        type = iodef_additional_data_type_to_numeric(buf);
                        if ( type < 0 )
                                return type;

                        ret = iodef_additional_data_new_data(additional_data, &data);
                        if ( ret < 0 )
                                return ret;

                        switch(type) {
                                case IODEF_ADDITIONAL_DATA_TYPE_REAL: {
                                        float val;

                                        ret = __get_float(ctrl, &val);
                                        if ( ret < 0 )
                                                return ret;

                                        iodef_data_set_float(data, val);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_BYTE:
                                case IODEF_ADDITIONAL_DATA_TYPE_BOOLEAN:
                                case IODEF_ADDITIONAL_DATA_TYPE_INTEGER: {
                                        int64_t val;

                                        val = __get_integer(ctrl);
                                        if ( val < 0 )
                                                return val;

                                        iodef_data_set_int(data, val);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_DATE_TIME: {
                                        iodef_time_t *time;
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        ret = iodef_time_new_from_string(&time, buf);
                                        if ( ret < 0 )
                                                return ret;

                                        iodef_data_set_time(data, time);
                                        break;
                                }

                                case IODEF_ADDITIONAL_DATA_TYPE_STRING:
                                case IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING:
                                case IODEF_ADDITIONAL_DATA_TYPE_CHARACTER:
                                case IODEF_ADDITIONAL_DATA_TYPE_NTPSTAMP:
                                case IODEF_ADDITIONAL_DATA_TYPE_PORTLIST:
                                case IODEF_ADDITIONAL_DATA_TYPE_XML: {
                                        libiodef_string_t *str;

                                        ret = libiodef_string_new(&str);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 ) {
                                                libiodef_string_destroy(str);
                                                return ret;
                                        }

                                        if ( type == IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING )
                                                ret = iodef_data_set_byte_string_dup(data, (const unsigned char *) libiodef_string_get_string(str), libiodef_string_get_len(str));
                                        else
                                                ret = iodef_data_set_char_string_dup_fast(data, libiodef_string_get_string(str), libiodef_string_get_len(str));

                                        libiodef_string_destroy(str);
                                        break;
                                }

                                default:
                                        return -1;
                        }

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading additional_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_email_read:
 * @email: Pointer to a #iodef_email_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_email from the @json message, and
 * store it into @email.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_email_read_json(iodef_email_t *email, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ email idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_email_meaning_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_email_set_meaning(email, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_email_new_email(email, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading email", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_registry_handle_read:
 * @registry_handle: Pointer to a #iodef_registry_handle_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_registry_handle from the @json message, and
 * store it into @registry_handle.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_registry_handle_read_json(iodef_registry_handle_t *registry_handle, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ registry_handle idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registry") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_registry_handle_registry_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_registry_handle_set_registry(registry_handle, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_registry") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_registry_handle_new_ext_registry(registry_handle, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading registry_handle", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_postal_address_read:
 * @postal_address: Pointer to a #iodef_postal_address_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_postal_address from the @json message, and
 * store it into @postal_address.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_postal_address_read_json(iodef_postal_address_t *postal_address, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ postal_address idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_postal_address_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_postal_address_set_lang(postal_address, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_postal_address_meaning_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_postal_address_set_meaning(postal_address, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading postal_address", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_contact_read:
 * @contact: Pointer to a #iodef_contact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_contact from the @json message, and
 * store it into @contact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_contact_read_json(iodef_contact_t *contact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ contact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_contact_new_additional_data(contact, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "fax") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_contact_new_fax(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_contact_new_description(contact, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "telephone") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_contact_new_telephone(contact, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registry_handle") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_registry_handle_t *registry_handle;

                                                ret = iodef_contact_new_registry_handle(contact, &registry_handle, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_registry_handle_read_json(registry_handle, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_contact_t *contact;

                                                ret = iodef_contact_new_contact(contact, &contact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact_name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_contact_new_contact_name(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "timezone") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_contact_new_timezone(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "postal_address") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_postal_address_t *postal_address;

                        ret = iodef_contact_new_postal_address(contact, &postal_address);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_postal_address_read_json(postal_address, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_email_t *email;

                                                ret = iodef_contact_new_email(contact, &email, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_email_read_json(email, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_contact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_contact_set_type(contact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "role") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_contact_role_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_contact_set_role(contact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_contact_new_ext_type(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_role") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_contact_new_ext_role(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_contact_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_contact_set_restriction(contact, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading contact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_incident_id_read:
 * @incident_id: Pointer to a #iodef_incident_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_incident_id from the @json message, and
 * store it into @incident_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_incident_id_read_json(iodef_incident_id_t *incident_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ incident_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "instance") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_incident_id_new_instance(incident_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_incident_id_new_name(incident_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_id_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_incident_id_set_restriction(incident_id, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading incident_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_alternative_id_read:
 * @alternative_id: Pointer to a #iodef_alternative_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_alternative_id from the @json message, and
 * store it into @alternative_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_alternative_id_read_json(iodef_alternative_id_t *alternative_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ alternative_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_incident_id_t *incident_id;

                                                ret = iodef_alternative_id_new_incident_id(alternative_id, &incident_id, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_incident_id_read_json(incident_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_alternative_id_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_alternative_id_set_restriction(alternative_id, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading alternative_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_related_activity_read:
 * @related_activity: Pointer to a #iodef_related_activity_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_related_activity from the @json message, and
 * store it into @related_activity.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_related_activity_read_json(iodef_related_activity_t *related_activity, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ related_activity idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_related_activity_new_url(related_activity, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_incident_id_t *incident_id;

                                                ret = iodef_related_activity_new_incident_id(related_activity, &incident_id, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_incident_id_read_json(incident_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_related_activity_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_related_activity_set_restriction(related_activity, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading related_activity", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_history_item_read:
 * @history_item: Pointer to a #iodef_history_item_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_history_item from the @json message, and
 * store it into @history_item.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_history_item_read_json(iodef_history_item_t *history_item, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ history_item idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_history_item_new_additional_data(history_item, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_incident_id_t *incident_id;

                        ret = iodef_history_item_new_incident_id(history_item, &incident_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_id_read_json(incident_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_history_item_new_description(history_item, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_contact_t *contact;

                        ret = iodef_history_item_new_contact(history_item, &contact);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_contact_read_json(contact, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_history_item_set_date_time(history_item, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "action") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_history_item_action_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_history_item_set_action(history_item, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_history_item_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_history_item_set_restriction(history_item, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_action") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_history_item_new_ext_action(history_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading history_item", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_history_read:
 * @history: Pointer to a #iodef_history_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_history from the @json message, and
 * store it into @history.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_history_read_json(iodef_history_t *history, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ history idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "history_item") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_history_item_t *history_item;

                                                ret = iodef_history_new_history_item(history, &history_item, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_history_item_read_json(history_item, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_history_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_history_set_restriction(history, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading history", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_expectation_read:
 * @expectation: Pointer to a #iodef_expectation_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_expectation from the @json message, and
 * store it into @expectation.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_expectation_read_json(iodef_expectation_t *expectation, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ expectation idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_expectation_set_end_time(expectation, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_expectation_new_description(expectation, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_expectation_set_start_time(expectation, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_contact_t *contact;

                        ret = iodef_expectation_new_contact(expectation, &contact);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_contact_read_json(contact, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "action") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_expectation_action_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_expectation_set_action(expectation, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_expectation_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_expectation_set_restriction(expectation, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_action") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_expectation_new_ext_action(expectation, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_expectation_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_expectation_set_severity(expectation, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading expectation", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_record_pattern_read:
 * @record_pattern: Pointer to a #iodef_record_pattern_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_record_pattern from the @json message, and
 * store it into @record_pattern.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_record_pattern_read_json(iodef_record_pattern_t *record_pattern, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ record_pattern idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "offsetunit") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_pattern_offsetunit_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_pattern_set_offsetunit(record_pattern, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "instance") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_record_pattern_set_instance(record_pattern, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_record_pattern_new_ext_type(record_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "offset") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_record_pattern_set_offset(record_pattern, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_offsetunit") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_record_pattern_new_ext_offsetunit(record_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_pattern_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_pattern_set_type(record_pattern, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading record_pattern", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_record_item_read:
 * @record_item: Pointer to a #iodef_record_item_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_record_item from the @json message, and
 * store it into @record_item.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_record_item_read_json(iodef_record_item_t *record_item, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ record_item idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_item_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_item_set_restriction(record_item, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "dtype") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_item_dtype_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_item_set_dtype(record_item, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "formatid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_record_item_new_formatid(record_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_record_item_new_meaning(record_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_dtype") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_record_item_new_ext_dtype(record_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "data") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_data_t *data;
                        libiodef_string_t *str;

                        ret = iodef_record_item_new_data(record_item, &data);
                        if ( ret < 0 )
                                return ret;

                        ret = libiodef_string_new(&str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 ) {
                                libiodef_string_destroy(str);
                                return ret;
                        }

                        ret = iodef_data_set_byte_string_dup(data, (const unsigned char *) libiodef_string_get_string(str), libiodef_string_get_len(str));
                        libiodef_string_destroy(str);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading record_item", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_application_read:
 * @application: Pointer to a #iodef_application_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_application from the @json message, and
 * store it into @application.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_application_read_json(iodef_application_t *application, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ application idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_url(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vendor") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_vendor(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_name(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "family") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_family(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "swid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_swid(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "patch") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_patch(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_version(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "configid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_application_new_configid(application, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading application", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_record_data_read:
 * @record_data: Pointer to a #iodef_record_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_record_data from the @json message, and
 * store it into @record_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_record_data_read_json(iodef_record_data_t *record_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ record_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_additional_data_t *additional_data;

                        ret = iodef_record_data_new_additional_data(record_data, &additional_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_additional_data_read_json(additional_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_record_data_new_description(record_data, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_pattern") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_record_pattern_t *record_pattern;

                                                ret = iodef_record_data_new_record_pattern(record_data, &record_pattern, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_record_pattern_read_json(record_pattern, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_record_data_set_date_time(record_data, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_application_t *application;

                        ret = iodef_record_data_new_application(record_data, &application);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_application_read_json(application, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_item") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_record_item_t *record_item;

                                                ret = iodef_record_data_new_record_item(record_data, &record_item, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_record_item_read_json(record_item, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_data_set_restriction(record_data, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading record_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_record_read:
 * @record: Pointer to a #iodef_record_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_record from the @json message, and
 * store it into @record.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_record_read_json(iodef_record_t *record, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ record idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_record_data_t *record_data;

                                                ret = iodef_record_new_record_data(record, &record_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_record_data_read_json(record_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_record_set_restriction(record, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading record", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_reference_read:
 * @reference: Pointer to a #iodef_reference_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_reference from the @json message, and
 * store it into @reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_reference_read_json(iodef_reference_t *reference, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ reference idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_reference_new_url(reference, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_reference_new_description(reference, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference_name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_reference_new_reference_name(reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading reference", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_method_read:
 * @method: Pointer to a #iodef_method_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_method from the @json message, and
 * store it into @method.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_method_read_json(iodef_method_t *method, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ method idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_method_new_additional_data(method, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_method_new_description(method, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_reference_t *reference;

                                                ret = iodef_method_new_reference(method, &reference, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_reference_read_json(reference, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_method_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_method_set_restriction(method, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading method", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_time_impact_read:
 * @time_impact: Pointer to a #iodef_time_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_time_impact from the @json message, and
 * store it into @time_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_time_impact_read_json(iodef_time_impact_t *time_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ time_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_metric") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_time_impact_new_ext_metric(time_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "duration") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_impact_duration_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_time_impact_set_duration(time_impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "metric") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_impact_metric_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_time_impact_set_metric(time_impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_time_impact_set_severity(time_impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_duration") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_time_impact_new_ext_duration(time_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading time_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_impact_read:
 * @impact: Pointer to a #iodef_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_impact from the @json message, and
 * store it into @impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_impact_read_json(iodef_impact_t *impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_impact_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_impact_set_lang(impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "completion") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_impact_completion_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_impact_set_completion(impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_impact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_impact_set_type(impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_impact_set_severity(impact, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_impact_new_ext_type(impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_confidence_read:
 * @confidence: Pointer to a #iodef_confidence_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_confidence from the @json message, and
 * store it into @confidence.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_confidence_read_json(iodef_confidence_t *confidence, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ confidence idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "rating") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_confidence_rating_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_confidence_set_rating(confidence, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading confidence", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_monetary_impact_read:
 * @monetary_impact: Pointer to a #iodef_monetary_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_monetary_impact from the @json message, and
 * store it into @monetary_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_monetary_impact_read_json(iodef_monetary_impact_t *monetary_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ monetary_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "currency") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_monetary_impact_new_currency(monetary_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_monetary_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_monetary_impact_set_severity(monetary_impact, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading monetary_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_counter_read:
 * @counter: Pointer to a #iodef_counter_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_counter from the @json message, and
 * store it into @counter.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_counter_read_json(iodef_counter_t *counter, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ counter idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "duration") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_counter_duration_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_counter_set_duration(counter, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_counter_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_counter_set_type(counter, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_duration") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_counter_new_ext_duration(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_counter_new_ext_type(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading counter", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_assessment_read:
 * @assessment: Pointer to a #iodef_assessment_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_assessment from the @json message, and
 * store it into @assessment.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_assessment_read_json(iodef_assessment_t *assessment, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ assessment idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "impact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_impact_t *impact;

                                                ret = iodef_assessment_new_impact(assessment, &impact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_impact_read_json(impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_assessment_new_additional_data(assessment, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "confidence") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_confidence_t *confidence;

                        ret = iodef_assessment_new_confidence(assessment, &confidence);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_confidence_read_json(confidence, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "time_impact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_time_impact_t *time_impact;

                                                ret = iodef_assessment_new_time_impact(assessment, &time_impact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_time_impact_read_json(time_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "monetary_impact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_monetary_impact_t *monetary_impact;

                                                ret = iodef_assessment_new_monetary_impact(assessment, &monetary_impact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_monetary_impact_read_json(monetary_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_counter_t *counter;

                                                ret = iodef_assessment_new_counter(assessment, &counter, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_assessment_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_assessment_set_restriction(assessment, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "occurrence") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_assessment_occurrence_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_assessment_set_occurrence(assessment, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading assessment", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_service_read:
 * @service: Pointer to a #iodef_service_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_service from the @json message, and
 * store it into @service.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_service_read_json(iodef_service_t *service, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ service idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_code") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_service_set_proto_code(service, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_flags") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_service_set_proto_flags(service, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "portlist") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_service_new_portlist(service, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_application_t *application;

                                                ret = iodef_service_new_application(service, &application, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_application_read_json(application, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_type") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_service_set_proto_type(service, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "port") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_service_set_port(service, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ip_protocol") == 0 ) {
                        ctrl->idx++;

                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodef_service_set_ip_protocol(service, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading service", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_address_read:
 * @address: Pointer to a #iodef_address_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_address from the @json message, and
 * store it into @address.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_address_read_json(iodef_address_t *address, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ address idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_address_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_address_set_category(address, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vlan_name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_address_new_vlan_name(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_address_new_ext_category(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vlan_num") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_address_new_vlan_num(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading address", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_node_role_read:
 * @node_role: Pointer to a #iodef_node_role_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_node_role from the @json message, and
 * store it into @node_role.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_node_role_read_json(iodef_node_role_t *node_role, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ node_role idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_node_role_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_node_role_set_category(node_role, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_node_role_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_node_role_set_lang(node_role, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_node_role_new_ext_category(node_role, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading node_role", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_node_read:
 * @node: Pointer to a #iodef_node_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_node from the @json message, and
 * store it into @node.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_node_read_json(iodef_node_t *node, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ node idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node_name") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_node_new_node_name(node, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_counter_t *counter;

                                                ret = iodef_node_new_counter(node, &counter, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_node_set_date_time(node, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node_role") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_node_role_t *node_role;

                                                ret = iodef_node_new_node_role(node, &node_role, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_node_role_read_json(node_role, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "location") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_node_new_location(node, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "address") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_address_t *address;

                                                ret = iodef_node_new_address(node, &address, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_address_read_json(address, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading node", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_operating_system_read:
 * @operating_system: Pointer to a #iodef_operating_system_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_operating_system from the @json message, and
 * store it into @operating_system.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_operating_system_read_json(iodef_operating_system_t *operating_system, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ operating_system idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_url(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vendor") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_vendor(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_name(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "family") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_family(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "swid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_swid(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "patch") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_patch(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_version(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "configid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_operating_system_new_configid(operating_system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading operating_system", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_system_read:
 * @system: Pointer to a #iodef_system_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_system from the @json message, and
 * store it into @system.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_system_read_json(iodef_system_t *system, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ system idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_node_t *node;

                        ret = iodef_system_new_node(system, &node);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_node_read_json(node, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_system_new_additional_data(system, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_system_new_description(system, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "service") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_service_t *service;

                                                ret = iodef_system_new_service(system, &service, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_service_read_json(service, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_counter_t *counter;

                                                ret = iodef_system_new_counter(system, &counter, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "operating_system") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_operating_system_t *operating_system;

                        ret = iodef_system_new_operating_system(system, &operating_system);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_operating_system_read_json(operating_system, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_system_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_system_set_category(system, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_system_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_system_set_restriction(system, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_system_new_ext_category(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "spoofed") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_system_spoofed_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_system_set_spoofed(system, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "interface") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_system_new_interface(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading system", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_flow_read:
 * @flow: Pointer to a #iodef_flow_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_flow from the @json message, and
 * store it into @flow.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_flow_read_json(iodef_flow_t *flow, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ flow idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "system") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_system_t *system;

                                                ret = iodef_flow_new_system(flow, &system, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_system_read_json(system, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading flow", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_event_data_read:
 * @event_data: Pointer to a #iodef_event_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_event_data from the @json message, and
 * store it into @event_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_event_data_read_json(iodef_event_data_t *event_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ event_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detect_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_event_data_set_detect_time(event_data, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_event_data_new_additional_data(event_data, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_event_data_new_description(event_data, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "flow") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_flow_t *flow;

                                                ret = iodef_event_data_new_flow(event_data, &flow, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_flow_read_json(flow, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "expectation") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_expectation_t *expectation;

                                                ret = iodef_event_data_new_expectation(event_data, &expectation, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_expectation_read_json(expectation, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_record_t *record;

                        ret = iodef_event_data_new_record(event_data, &record);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_record_read_json(record, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_contact_t *contact;

                                                ret = iodef_event_data_new_contact(event_data, &contact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_event_data_set_start_time(event_data, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "event_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_event_data_t *event_data;

                                                ret = iodef_event_data_new_event_data(event_data, &event_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_event_data_read_json(event_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_event_data_set_end_time(event_data, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "assessment") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_assessment_t *assessment;

                        ret = iodef_event_data_new_assessment(event_data, &assessment);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_assessment_read_json(assessment, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "method") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_method_t *method;

                                                ret = iodef_event_data_new_method(event_data, &method, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_method_read_json(method, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_event_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_event_data_set_restriction(event_data, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading event_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_incident_read:
 * @incident: Pointer to a #iodef_incident_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_incident from the @json message, and
 * store it into @incident.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_incident_read_json(iodef_incident_t *incident, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ incident idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detect_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_incident_set_detect_time(incident, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_additional_data_t *additional_data;

                                                ret = iodef_incident_new_additional_data(incident, &additional_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_incident_set_end_time(incident, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                        int ret;
                                        libiodef_string_t *str;

                                        ret = iodef_incident_new_description(incident, &str, IODEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;

                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
                                                
                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_contact_t *contact;

                                                ret = iodef_incident_new_contact(incident, &contact, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "alternative_id") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_alternative_id_t *alternative_id;

                        ret = iodef_incident_new_alternative_id(incident, &alternative_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_alternative_id_read_json(alternative_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "report_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_incident_set_report_time(incident, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];
                        iodef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodef_incident_set_start_time(incident, time);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "event_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_event_data_t *event_data;

                                                ret = iodef_incident_new_event_data(incident, &event_data, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_event_data_read_json(event_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "related_activity") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_related_activity_t *related_activity;

                        ret = iodef_incident_new_related_activity(incident, &related_activity);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_related_activity_read_json(related_activity, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_incident_id_t *incident_id;

                        ret = iodef_incident_new_incident_id(incident, &incident_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_id_read_json(incident_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "assessment") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_assessment_t *assessment;

                                                ret = iodef_incident_new_assessment(incident, &assessment, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_assessment_read_json(assessment, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "method") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_method_t *method;

                                                ret = iodef_incident_new_method(incident, &method, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_method_read_json(method, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "history") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        iodef_history_t *history;

                        ret = iodef_incident_new_history(incident, &history);
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_history_read_json(history, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_incident_set_lang(incident, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_incident_set_restriction(incident, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_purpose") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_incident_new_ext_purpose(incident, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "purpose") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_incident_purpose_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_incident_set_purpose(incident, ret);

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading incident", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodef_document_read:
 * @document: Pointer to a #iodef_document_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodef_document from the @json message, and
 * store it into @document.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodef_document_read_json(iodef_document_t *document, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;

        //printf("READ document idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }

                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {

                                                int ret;
                                                iodef_incident_t *incident;

                                                ret = iodef_document_new_incident(document, &incident, IODEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodef_incident_read_json(incident, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodef_document_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodef_document_set_lang(document, ret);

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "formatid") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_document_new_formatid(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;

                        int ret;
                        libiodef_string_t *str;

                        ret = iodef_document_new_version(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

                }

                else {
                        return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unexpected field '%.*s' while reading document", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

int iodef_object_new_from_json(iodef_object_t **object, const char *json_message)
{
        int ret, selfkey;
        jsmn_parser parser;
        json_data_t ctrl;

        jsmn_init(&parser);
        ctrl.idx = 0;
        ctrl.input = json_message;

        ret = ctrl.jtoksize = jsmn_parse(&parser, json_message, strlen(json_message), ctrl.jtok, sizeof(ctrl.jtok) / sizeof(*ctrl.jtok));
        if ( ret < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "error parsing json message");

        selfkey = __get_json_key(&ctrl, "_self", 0);
        if ( selfkey < 0 )
                return libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "json message miss '_self' attribute");

        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_additional_data_t") == 0 ) {
                ret = iodef_additional_data_new((iodef_additional_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_additional_data_read_json((iodef_additional_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_email_t") == 0 ) {
                ret = iodef_email_new((iodef_email_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_email_read_json((iodef_email_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_registry_handle_t") == 0 ) {
                ret = iodef_registry_handle_new((iodef_registry_handle_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_registry_handle_read_json((iodef_registry_handle_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_postal_address_t") == 0 ) {
                ret = iodef_postal_address_new((iodef_postal_address_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_postal_address_read_json((iodef_postal_address_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_contact_t") == 0 ) {
                ret = iodef_contact_new((iodef_contact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_contact_read_json((iodef_contact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_incident_id_t") == 0 ) {
                ret = iodef_incident_id_new((iodef_incident_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_incident_id_read_json((iodef_incident_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_alternative_id_t") == 0 ) {
                ret = iodef_alternative_id_new((iodef_alternative_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_alternative_id_read_json((iodef_alternative_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_related_activity_t") == 0 ) {
                ret = iodef_related_activity_new((iodef_related_activity_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_related_activity_read_json((iodef_related_activity_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_history_item_t") == 0 ) {
                ret = iodef_history_item_new((iodef_history_item_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_history_item_read_json((iodef_history_item_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_history_t") == 0 ) {
                ret = iodef_history_new((iodef_history_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_history_read_json((iodef_history_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_expectation_t") == 0 ) {
                ret = iodef_expectation_new((iodef_expectation_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_expectation_read_json((iodef_expectation_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_record_pattern_t") == 0 ) {
                ret = iodef_record_pattern_new((iodef_record_pattern_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_record_pattern_read_json((iodef_record_pattern_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_record_item_t") == 0 ) {
                ret = iodef_record_item_new((iodef_record_item_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_record_item_read_json((iodef_record_item_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_application_t") == 0 ) {
                ret = iodef_application_new((iodef_application_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_application_read_json((iodef_application_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_record_data_t") == 0 ) {
                ret = iodef_record_data_new((iodef_record_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_record_data_read_json((iodef_record_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_record_t") == 0 ) {
                ret = iodef_record_new((iodef_record_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_record_read_json((iodef_record_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_reference_t") == 0 ) {
                ret = iodef_reference_new((iodef_reference_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_reference_read_json((iodef_reference_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_method_t") == 0 ) {
                ret = iodef_method_new((iodef_method_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_method_read_json((iodef_method_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_time_impact_t") == 0 ) {
                ret = iodef_time_impact_new((iodef_time_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_time_impact_read_json((iodef_time_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_impact_t") == 0 ) {
                ret = iodef_impact_new((iodef_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_impact_read_json((iodef_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_confidence_t") == 0 ) {
                ret = iodef_confidence_new((iodef_confidence_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_confidence_read_json((iodef_confidence_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_monetary_impact_t") == 0 ) {
                ret = iodef_monetary_impact_new((iodef_monetary_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_monetary_impact_read_json((iodef_monetary_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_counter_t") == 0 ) {
                ret = iodef_counter_new((iodef_counter_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_counter_read_json((iodef_counter_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_assessment_t") == 0 ) {
                ret = iodef_assessment_new((iodef_assessment_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_assessment_read_json((iodef_assessment_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_service_t") == 0 ) {
                ret = iodef_service_new((iodef_service_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_service_read_json((iodef_service_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_address_t") == 0 ) {
                ret = iodef_address_new((iodef_address_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_address_read_json((iodef_address_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_node_role_t") == 0 ) {
                ret = iodef_node_role_new((iodef_node_role_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_node_role_read_json((iodef_node_role_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_node_t") == 0 ) {
                ret = iodef_node_new((iodef_node_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_node_read_json((iodef_node_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_operating_system_t") == 0 ) {
                ret = iodef_operating_system_new((iodef_operating_system_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_operating_system_read_json((iodef_operating_system_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_system_t") == 0 ) {
                ret = iodef_system_new((iodef_system_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_system_read_json((iodef_system_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_flow_t") == 0 ) {
                ret = iodef_flow_new((iodef_flow_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_flow_read_json((iodef_flow_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_event_data_t") == 0 ) {
                ret = iodef_event_data_new((iodef_event_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_event_data_read_json((iodef_event_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_incident_t") == 0 ) {
                ret = iodef_incident_new((iodef_incident_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_incident_read_json((iodef_incident_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodef_document_t") == 0 ) {
                ret = iodef_document_new((iodef_document_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodef_document_read_json((iodef_document_t *) *object, &ctrl);
        }
        
        else {
                ret = libiodef_error_verbose(LIBIODEF_ERROR_GENERIC, "unknown object type '%s'", "");
        }

        return ret;
}

