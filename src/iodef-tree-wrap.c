
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@libiodef-ids.com>
* Author: Nicolas Delon <nicolas.delon@libiodef-ids.com>
*
* This file is part of the LibIodef library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIODEFTreeWrapC package */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include "libiodef-inttypes.h"
#include "libiodef-list.h"
#include "libiodef-string.h"

#define LIBIODEF_ERROR_SOURCE_DEFAULT LIBIODEF_ERROR_SOURCE_IODEF_TREE_WRAP
#include "libiodef-error.h"

#include "iodef-time.h"
#include "iodef-data.h"
#include "iodef-class.h"
#include "iodef-value.h"
#include "iodef-object-prv.h"

#include "iodef-tree-wrap.h"
#include "libmissing.h"
#include "common.h"

#ifdef WIN32
# undef interface
#endif


#define LISTED_OBJECT(name, type) libiodef_list_t name
#define KEYLISTED_OBJECT(name, type) libiodef_list_t name

#define IS_KEY_LISTED(keyfield) IODEF_LINKED_OBJECT; libiodef_string_t *keyfield

#define UNION(type, var) type var; union

#define UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount
#define REQUIRED(type, name) type name
#define IGNORED(type, name) type name

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; unsigned int name ## _is_set:1

#define IDENT(name) uint64_t name


#define iodef_data_copy iodef_data_copy_dup

#ifndef ABS
# define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


/*
 * If we subtract the integer representations of two floats then that
 * will tell us how close they are. If the difference is zero, they are
 * identical. If the difference is one, they are adjacent floats.
 * In general, if the difference is n then there are n-1 floats between
 * them.
 *
 * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
 */
static int float_compare(float a, float b)
{
        union {
                float fval;
                int32_t ival;
        } au, bu;

        au.fval = a;
        bu.fval = b;

        /* Make aInt lexicographically ordered as a twos-complement int */
        if ( au.ival < 0 )
                au.ival = 0x80000000 - au.ival;

        /* Make bInt lexicographically ordered as a twos-complement int */
        if ( bu.ival < 0 )
                bu.ival = 0x80000000 - bu.ival;

        return (ABS(au.ival - bu.ival) <= 0) ? 0 : -1;
}



static int libiodef_string_copy(const libiodef_string_t *src, libiodef_string_t *dst)
{
        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! libiodef_string_is_empty(src) )
               return libiodef_string_copy_dup(src, dst);

        return 0;
}



static int get_value_from_string(iodef_value_t **value, libiodef_string_t *str, libiodef_bool_t is_ptr)
{
        int ret;

        if ( ! str ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = libiodef_string_clone(str, &str);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodef_value_new_string(value, str);
        if ( ret < 0 ) {
                libiodef_string_destroy(str);
                return ret;
        }

        if ( is_ptr )
                libiodef_string_ref(str);

        return 0;
}



static int get_value_from_data(iodef_value_t **value, iodef_data_t *data, libiodef_bool_t is_ptr)
{
        int ret;

        if ( ! data ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = iodef_data_clone(data, &data);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodef_value_new_data(value, data);
        if ( ret < 0 ) {
                iodef_data_destroy(data);
                return ret;
        }

        if ( is_ptr )
                iodef_data_ref(data);

        return 0;
}


static int get_value_from_time(iodef_value_t **value, iodef_time_t *time, libiodef_bool_t is_ptr)
{
        int ret;

        if ( ! time ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = iodef_time_clone(time, &time);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodef_value_new_time(value, time);
        if ( ret < 0 ) {
                iodef_time_destroy(time);
                return ret;
        }

        if ( is_ptr )
                iodef_time_ref(time);

        return 0;
}


static void list_insert(libiodef_list_t *head, libiodef_list_t *item, int pos)
{
        int i = 0;
        libiodef_list_t *tmp;

        if ( pos == IODEF_LIST_APPEND )
                libiodef_list_add_tail(head, item);

        else if ( pos == IODEF_LIST_PREPEND )
                libiodef_list_add(head, item);

        else if ( pos >= 0 ) {
                libiodef_list_for_each(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libiodef_list_add_tail(tmp, item);
        }

        else if ( pos < 0 ) {
                pos = -pos;
                pos--;

                libiodef_list_for_each_reversed(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libiodef_list_add(tmp, item);
        }
}


/**
 * iodef_additional_data_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_additional_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_additional_data_restriction_t iodef_additional_data_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_additional_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for additional_data_restriction", name);
}

/**
 * iodef_additional_data_restriction_to_string:
 * @val: an enumeration value for #iodef_additional_data_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_additional_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_additional_data_restriction_to_string(iodef_additional_data_restriction_t val)
{
        const struct {
              iodef_additional_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_additional_data_type_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_additional_data_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_additional_data_type_t iodef_additional_data_type_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_additional_data_type_t val;
              const char *name;
        } tbl[] = {
            { IODEF_ADDITIONAL_DATA_TYPE_STRING, "string" },
            { IODEF_ADDITIONAL_DATA_TYPE_BYTE, "byte" },
            { IODEF_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },
            { IODEF_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },
            { IODEF_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },
            { IODEF_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },
            { IODEF_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },
            { IODEF_ADDITIONAL_DATA_TYPE_REAL, "real" },
            { IODEF_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },
            { IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING, "byte-string" },
            { IODEF_ADDITIONAL_DATA_TYPE_XML, "xml" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for additional_data_type", name);
}

/**
 * iodef_additional_data_type_to_string:
 * @val: an enumeration value for #iodef_additional_data_type_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_additional_data_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_additional_data_type_to_string(iodef_additional_data_type_t val)
{
        const struct {
              iodef_additional_data_type_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_ADDITIONAL_DATA_TYPE_STRING, "string" },
                { IODEF_ADDITIONAL_DATA_TYPE_BYTE, "byte" },
                { IODEF_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },
                { IODEF_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },
                { IODEF_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },
                { IODEF_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },
                { IODEF_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },
                { IODEF_ADDITIONAL_DATA_TYPE_REAL, "real" },
                { IODEF_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },
                { IODEF_ADDITIONAL_DATA_TYPE_BYTE_STRING, "byte-string" },
                { IODEF_ADDITIONAL_DATA_TYPE_XML, "xml" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_additional_data {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
         IGNORED(libiodef_bool_t, _type_is_set);
 
         iodef_additional_data_restriction_t restriction;
         iodef_additional_data_type_t type;
         libiodef_string_t *formatid;
         libiodef_string_t *meaning;
         libiodef_string_t *ext_dtype;
         REQUIRED(iodef_data_t, *data);
 
};


/**
 * iodef_email_meaning_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_email_meaning_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_email_meaning_t iodef_email_meaning_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_email_meaning_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for email_meaning", name);
}

/**
 * iodef_email_meaning_to_string:
 * @val: an enumeration value for #iodef_email_meaning_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_email_meaning_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_email_meaning_to_string(iodef_email_meaning_t val)
{
        const struct {
              iodef_email_meaning_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_email {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_email_meaning_t meaning;
         REQUIRED(libiodef_string_t, *email);
 
};


/**
 * iodef_registry_handle_registry_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_registry_handle_registry_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_registry_handle_registry_t iodef_registry_handle_registry_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_registry_handle_registry_t val;
              const char *name;
        } tbl[] = {
            { IODEF_REGISTRY_HANDLE_REGISTRY_INTERNIC, "internic" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_APNIC, "apnic" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_ARIN, "arin" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_LACNIC, "lacnic" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_RIPE, "ripe" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_AFRINIC, "afrinic" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_LOCAL, "local" },
            { IODEF_REGISTRY_HANDLE_REGISTRY_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for registry_handle_registry", name);
}

/**
 * iodef_registry_handle_registry_to_string:
 * @val: an enumeration value for #iodef_registry_handle_registry_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_registry_handle_registry_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_registry_handle_registry_to_string(iodef_registry_handle_registry_t val)
{
        const struct {
              iodef_registry_handle_registry_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_REGISTRY_HANDLE_REGISTRY_INTERNIC, "internic" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_APNIC, "apnic" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_ARIN, "arin" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_LACNIC, "lacnic" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_RIPE, "ripe" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_AFRINIC, "afrinic" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_LOCAL, "local" },
                { IODEF_REGISTRY_HANDLE_REGISTRY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_registry_handle {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_registry_handle_registry_t registry;
         libiodef_string_t *ext_registry;
 
};


/**
 * iodef_postal_address_lang_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_postal_address_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_postal_address_lang_t iodef_postal_address_lang_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_postal_address_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for postal_address_lang", name);
}

/**
 * iodef_postal_address_lang_to_string:
 * @val: an enumeration value for #iodef_postal_address_lang_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_postal_address_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_postal_address_lang_to_string(iodef_postal_address_lang_t val)
{
        const struct {
              iodef_postal_address_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_postal_address_meaning_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_postal_address_meaning_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_postal_address_meaning_t iodef_postal_address_meaning_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_postal_address_meaning_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for postal_address_meaning", name);
}

/**
 * iodef_postal_address_meaning_to_string:
 * @val: an enumeration value for #iodef_postal_address_meaning_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_postal_address_meaning_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_postal_address_meaning_to_string(iodef_postal_address_meaning_t val)
{
        const struct {
              iodef_postal_address_meaning_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_postal_address {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         iodef_postal_address_lang_t lang;
         iodef_postal_address_meaning_t meaning;
 
};


/**
 * iodef_contact_type_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_contact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_contact_type_t iodef_contact_type_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_contact_type_t val;
              const char *name;
        } tbl[] = {
            { IODEF_CONTACT_TYPE_PERSON, "person" },
            { IODEF_CONTACT_TYPE_ORGANIZATION, "organization" },
            { IODEF_CONTACT_TYPE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_type", name);
}

/**
 * iodef_contact_type_to_string:
 * @val: an enumeration value for #iodef_contact_type_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_contact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_contact_type_to_string(iodef_contact_type_t val)
{
        const struct {
              iodef_contact_type_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_CONTACT_TYPE_PERSON, "person" },
                { IODEF_CONTACT_TYPE_ORGANIZATION, "organization" },
                { IODEF_CONTACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_contact_role_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_contact_role_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_contact_role_t iodef_contact_role_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_contact_role_t val;
              const char *name;
        } tbl[] = {
            { IODEF_CONTACT_ROLE_CREATOR, "creator" },
            { IODEF_CONTACT_ROLE_ADMIN, "admin" },
            { IODEF_CONTACT_ROLE_TECH, "tech" },
            { IODEF_CONTACT_ROLE_IRT, "irt" },
            { IODEF_CONTACT_ROLE_CC, "cc" },
            { IODEF_CONTACT_ROLE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_role", name);
}

/**
 * iodef_contact_role_to_string:
 * @val: an enumeration value for #iodef_contact_role_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_contact_role_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_contact_role_to_string(iodef_contact_role_t val)
{
        const struct {
              iodef_contact_role_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_CONTACT_ROLE_CREATOR, "creator" },
                { IODEF_CONTACT_ROLE_ADMIN, "admin" },
                { IODEF_CONTACT_ROLE_TECH, "tech" },
                { IODEF_CONTACT_ROLE_IRT, "irt" },
                { IODEF_CONTACT_ROLE_CC, "cc" },
                { IODEF_CONTACT_ROLE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_contact_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_contact_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_contact_restriction_t iodef_contact_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_contact_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_restriction", name);
}

/**
 * iodef_contact_restriction_to_string:
 * @val: an enumeration value for #iodef_contact_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_contact_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_contact_restriction_to_string(iodef_contact_restriction_t val)
{
        const struct {
              iodef_contact_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_contact {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         libiodef_string_t *fax;
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(telephone_list, libiodef_string_t);
         LISTED_OBJECT(registry_handle_list, iodef_registry_handle_t);
         LISTED_OBJECT(contact_list, iodef_contact_t);
         libiodef_string_t *contact_name;
         libiodef_string_t *timezone;
         iodef_postal_address_t *postal_address;
         LISTED_OBJECT(email_list, iodef_email_t);
         iodef_contact_type_t type;
         iodef_contact_role_t role;
         libiodef_string_t *ext_type;
         libiodef_string_t *ext_role;
         iodef_contact_restriction_t restriction;
 
};


/**
 * iodef_incident_id_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_incident_id_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_incident_id_restriction_t iodef_incident_id_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_incident_id_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_id_restriction", name);
}

/**
 * iodef_incident_id_restriction_to_string:
 * @val: an enumeration value for #iodef_incident_id_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_incident_id_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_incident_id_restriction_to_string(iodef_incident_id_restriction_t val)
{
        const struct {
              iodef_incident_id_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_incident_id {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         libiodef_string_t *instance;
         REQUIRED(libiodef_string_t, *name);
         iodef_incident_id_restriction_t restriction;
 
};


/**
 * iodef_alternative_id_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_alternative_id_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_alternative_id_restriction_t iodef_alternative_id_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_alternative_id_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for alternative_id_restriction", name);
}

/**
 * iodef_alternative_id_restriction_to_string:
 * @val: an enumeration value for #iodef_alternative_id_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_alternative_id_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_alternative_id_restriction_to_string(iodef_alternative_id_restriction_t val)
{
        const struct {
              iodef_alternative_id_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_alternative_id {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(incident_id_list, iodef_incident_id_t);
         iodef_alternative_id_restriction_t restriction;
 
};


/**
 * iodef_related_activity_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_related_activity_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_related_activity_restriction_t iodef_related_activity_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_related_activity_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for related_activity_restriction", name);
}

/**
 * iodef_related_activity_restriction_to_string:
 * @val: an enumeration value for #iodef_related_activity_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_related_activity_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_related_activity_restriction_to_string(iodef_related_activity_restriction_t val)
{
        const struct {
              iodef_related_activity_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_related_activity {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(url_list, libiodef_string_t);
         LISTED_OBJECT(incident_id_list, iodef_incident_id_t);
         iodef_related_activity_restriction_t restriction;
 
};


/**
 * iodef_history_item_action_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_history_item_action_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_history_item_action_t iodef_history_item_action_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_history_item_action_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_item_action", name);
}

/**
 * iodef_history_item_action_to_string:
 * @val: an enumeration value for #iodef_history_item_action_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_history_item_action_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_history_item_action_to_string(iodef_history_item_action_t val)
{
        const struct {
              iodef_history_item_action_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_history_item_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_history_item_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_history_item_restriction_t iodef_history_item_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_history_item_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_item_restriction", name);
}

/**
 * iodef_history_item_restriction_to_string:
 * @val: an enumeration value for #iodef_history_item_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_history_item_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_history_item_restriction_to_string(iodef_history_item_restriction_t val)
{
        const struct {
              iodef_history_item_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_history_item {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         iodef_incident_id_t *incident_id;
         LISTED_OBJECT(description_list, libiodef_string_t);
         iodef_contact_t *contact;
         REQUIRED(iodef_time_t, *date_time);
         iodef_history_item_action_t action;
         iodef_history_item_restriction_t restriction;
         libiodef_string_t *ext_action;
 
};


/**
 * iodef_history_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_history_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_history_restriction_t iodef_history_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_history_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_restriction", name);
}

/**
 * iodef_history_restriction_to_string:
 * @val: an enumeration value for #iodef_history_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_history_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_history_restriction_to_string(iodef_history_restriction_t val)
{
        const struct {
              iodef_history_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_history {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(history_item_list, iodef_history_item_t);
         iodef_history_restriction_t restriction;
 
};


/**
 * iodef_expectation_action_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_expectation_action_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_expectation_action_t iodef_expectation_action_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_expectation_action_t val;
              const char *name;
        } tbl[] = {
            { IODEF_EXPECTATION_ACTION_NOTHING, "nothing" },
            { IODEF_EXPECTATION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },
            { IODEF_EXPECTATION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },
            { IODEF_EXPECTATION_ACTION_CONTACT_SENDER, "contact-sender" },
            { IODEF_EXPECTATION_ACTION_INVESTIGATE, "investigate" },
            { IODEF_EXPECTATION_ACTION_BLOCK_HOST, "block-host" },
            { IODEF_EXPECTATION_ACTION_BLOCK_NETWORK, "block-network" },
            { IODEF_EXPECTATION_ACTION_BLOCK_PORT, "block-port" },
            { IODEF_EXPECTATION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },
            { IODEF_EXPECTATION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },
            { IODEF_EXPECTATION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },
            { IODEF_EXPECTATION_ACTION_REMEDIATE_OTHER, "remediate-other" },
            { IODEF_EXPECTATION_ACTION_STATUS_TRIAGE, "status-triage" },
            { IODEF_EXPECTATION_ACTION_STATUS_NEW_INFO, "status-new-info" },
            { IODEF_EXPECTATION_ACTION_OTHER, "other" },
            { IODEF_EXPECTATION_ACTION_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_action", name);
}

/**
 * iodef_expectation_action_to_string:
 * @val: an enumeration value for #iodef_expectation_action_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_expectation_action_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_expectation_action_to_string(iodef_expectation_action_t val)
{
        const struct {
              iodef_expectation_action_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_EXPECTATION_ACTION_NOTHING, "nothing" },
                { IODEF_EXPECTATION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },
                { IODEF_EXPECTATION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },
                { IODEF_EXPECTATION_ACTION_CONTACT_SENDER, "contact-sender" },
                { IODEF_EXPECTATION_ACTION_INVESTIGATE, "investigate" },
                { IODEF_EXPECTATION_ACTION_BLOCK_HOST, "block-host" },
                { IODEF_EXPECTATION_ACTION_BLOCK_NETWORK, "block-network" },
                { IODEF_EXPECTATION_ACTION_BLOCK_PORT, "block-port" },
                { IODEF_EXPECTATION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },
                { IODEF_EXPECTATION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },
                { IODEF_EXPECTATION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },
                { IODEF_EXPECTATION_ACTION_REMEDIATE_OTHER, "remediate-other" },
                { IODEF_EXPECTATION_ACTION_STATUS_TRIAGE, "status-triage" },
                { IODEF_EXPECTATION_ACTION_STATUS_NEW_INFO, "status-new-info" },
                { IODEF_EXPECTATION_ACTION_OTHER, "other" },
                { IODEF_EXPECTATION_ACTION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_expectation_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_expectation_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_expectation_restriction_t iodef_expectation_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_expectation_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_restriction", name);
}

/**
 * iodef_expectation_restriction_to_string:
 * @val: an enumeration value for #iodef_expectation_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_expectation_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_expectation_restriction_to_string(iodef_expectation_restriction_t val)
{
        const struct {
              iodef_expectation_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_expectation_severity_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_expectation_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_expectation_severity_t iodef_expectation_severity_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_expectation_severity_t val;
              const char *name;
        } tbl[] = {
            { IODEF_EXPECTATION_SEVERITY_LOW, "low" },
            { IODEF_EXPECTATION_SEVERITY_MEDIUM, "medium" },
            { IODEF_EXPECTATION_SEVERITY_HIGH, "high" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_severity", name);
}

/**
 * iodef_expectation_severity_to_string:
 * @val: an enumeration value for #iodef_expectation_severity_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_expectation_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_expectation_severity_to_string(iodef_expectation_severity_t val)
{
        const struct {
              iodef_expectation_severity_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_EXPECTATION_SEVERITY_LOW, "low" },
                { IODEF_EXPECTATION_SEVERITY_MEDIUM, "medium" },
                { IODEF_EXPECTATION_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_expectation {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_time_t *end_time;
         LISTED_OBJECT(description_list, libiodef_string_t);
         iodef_time_t *start_time;
         iodef_contact_t *contact;
         iodef_expectation_action_t action;
         iodef_expectation_restriction_t restriction;
         libiodef_string_t *ext_action;
         iodef_expectation_severity_t severity;
 
};


/**
 * iodef_record_pattern_offsetunit_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_pattern_offsetunit_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_pattern_offsetunit_t iodef_record_pattern_offsetunit_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_pattern_offsetunit_t val;
              const char *name;
        } tbl[] = {
            { IODEF_RECORD_PATTERN_OFFSETUNIT_LINE, "line" },
            { IODEF_RECORD_PATTERN_OFFSETUNIT_BINARY, "binary" },
            { IODEF_RECORD_PATTERN_OFFSETUNIT_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_pattern_offsetunit", name);
}

/**
 * iodef_record_pattern_offsetunit_to_string:
 * @val: an enumeration value for #iodef_record_pattern_offsetunit_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_pattern_offsetunit_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_pattern_offsetunit_to_string(iodef_record_pattern_offsetunit_t val)
{
        const struct {
              iodef_record_pattern_offsetunit_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_RECORD_PATTERN_OFFSETUNIT_LINE, "line" },
                { IODEF_RECORD_PATTERN_OFFSETUNIT_BINARY, "binary" },
                { IODEF_RECORD_PATTERN_OFFSETUNIT_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_record_pattern_type_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_pattern_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_pattern_type_t iodef_record_pattern_type_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_pattern_type_t val;
              const char *name;
        } tbl[] = {
            { IODEF_RECORD_PATTERN_TYPE_REGEX, "regex" },
            { IODEF_RECORD_PATTERN_TYPE_BINARY, "binary" },
            { IODEF_RECORD_PATTERN_TYPE_XPATH, "xpath" },
            { IODEF_RECORD_PATTERN_TYPE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_pattern_type", name);
}

/**
 * iodef_record_pattern_type_to_string:
 * @val: an enumeration value for #iodef_record_pattern_type_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_pattern_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_pattern_type_to_string(iodef_record_pattern_type_t val)
{
        const struct {
              iodef_record_pattern_type_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_RECORD_PATTERN_TYPE_REGEX, "regex" },
                { IODEF_RECORD_PATTERN_TYPE_BINARY, "binary" },
                { IODEF_RECORD_PATTERN_TYPE_XPATH, "xpath" },
                { IODEF_RECORD_PATTERN_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_record_pattern {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_record_pattern_offsetunit_t offsetunit;
         OPTIONAL_INT(uint32_t, instance);
         libiodef_string_t *ext_type;
         OPTIONAL_INT(uint32_t, offset);
         libiodef_string_t *ext_offsetunit;
         iodef_record_pattern_type_t type;
 
};


/**
 * iodef_record_item_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_item_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_item_restriction_t iodef_record_item_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_item_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_item_restriction", name);
}

/**
 * iodef_record_item_restriction_to_string:
 * @val: an enumeration value for #iodef_record_item_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_item_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_item_restriction_to_string(iodef_record_item_restriction_t val)
{
        const struct {
              iodef_record_item_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_record_item_dtype_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_item_dtype_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_item_dtype_t iodef_record_item_dtype_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_item_dtype_t val;
              const char *name;
        } tbl[] = {
            { IODEF_RECORD_ITEM_DTYPE_BOOLEAN, "boolean" },
            { IODEF_RECORD_ITEM_DTYPE_BYTE, "byte" },
            { IODEF_RECORD_ITEM_DTYPE_CHARACTER, "character" },
            { IODEF_RECORD_ITEM_DTYPE_DATE_TIME, "date-time" },
            { IODEF_RECORD_ITEM_DTYPE_INTEGER, "integer" },
            { IODEF_RECORD_ITEM_DTYPE_PORTLIST, "portlist" },
            { IODEF_RECORD_ITEM_DTYPE_REAL, "real" },
            { IODEF_RECORD_ITEM_DTYPE_STRING, "string" },
            { IODEF_RECORD_ITEM_DTYPE_FILE, "file" },
            { IODEF_RECORD_ITEM_DTYPE_FRAME, "frame" },
            { IODEF_RECORD_ITEM_DTYPE_PACKET, "packet" },
            { IODEF_RECORD_ITEM_DTYPE_IPV4_PACKET, "ipv4-packet" },
            { IODEF_RECORD_ITEM_DTYPE_IPV6_PACKET, "ipv6-packet" },
            { IODEF_RECORD_ITEM_DTYPE_PATH, "path" },
            { IODEF_RECORD_ITEM_DTYPE_URL, "url" },
            { IODEF_RECORD_ITEM_DTYPE_CSV, "csv" },
            { IODEF_RECORD_ITEM_DTYPE_WINREG, "winreg" },
            { IODEF_RECORD_ITEM_DTYPE_XML, "xml" },
            { IODEF_RECORD_ITEM_DTYPE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_item_dtype", name);
}

/**
 * iodef_record_item_dtype_to_string:
 * @val: an enumeration value for #iodef_record_item_dtype_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_item_dtype_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_item_dtype_to_string(iodef_record_item_dtype_t val)
{
        const struct {
              iodef_record_item_dtype_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_RECORD_ITEM_DTYPE_BOOLEAN, "boolean" },
                { IODEF_RECORD_ITEM_DTYPE_BYTE, "byte" },
                { IODEF_RECORD_ITEM_DTYPE_CHARACTER, "character" },
                { IODEF_RECORD_ITEM_DTYPE_DATE_TIME, "date-time" },
                { IODEF_RECORD_ITEM_DTYPE_INTEGER, "integer" },
                { IODEF_RECORD_ITEM_DTYPE_PORTLIST, "portlist" },
                { IODEF_RECORD_ITEM_DTYPE_REAL, "real" },
                { IODEF_RECORD_ITEM_DTYPE_STRING, "string" },
                { IODEF_RECORD_ITEM_DTYPE_FILE, "file" },
                { IODEF_RECORD_ITEM_DTYPE_FRAME, "frame" },
                { IODEF_RECORD_ITEM_DTYPE_PACKET, "packet" },
                { IODEF_RECORD_ITEM_DTYPE_IPV4_PACKET, "ipv4-packet" },
                { IODEF_RECORD_ITEM_DTYPE_IPV6_PACKET, "ipv6-packet" },
                { IODEF_RECORD_ITEM_DTYPE_PATH, "path" },
                { IODEF_RECORD_ITEM_DTYPE_URL, "url" },
                { IODEF_RECORD_ITEM_DTYPE_CSV, "csv" },
                { IODEF_RECORD_ITEM_DTYPE_WINREG, "winreg" },
                { IODEF_RECORD_ITEM_DTYPE_XML, "xml" },
                { IODEF_RECORD_ITEM_DTYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_record_item {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_record_item_restriction_t restriction;
         iodef_record_item_dtype_t dtype;
         libiodef_string_t *formatid;
         libiodef_string_t *meaning;
         libiodef_string_t *ext_dtype;
         iodef_data_t *data;
 
};



struct iodef_application {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         libiodef_string_t *url;
         libiodef_string_t *vendor;
         libiodef_string_t *name;
         libiodef_string_t *family;
         libiodef_string_t *swid;
         libiodef_string_t *patch;
         libiodef_string_t *version;
         libiodef_string_t *configid;
 
};


/**
 * iodef_record_data_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_data_restriction_t iodef_record_data_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_data_restriction", name);
}

/**
 * iodef_record_data_restriction_to_string:
 * @val: an enumeration value for #iodef_record_data_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_data_restriction_to_string(iodef_record_data_restriction_t val)
{
        const struct {
              iodef_record_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_record_data {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_additional_data_t *additional_data;
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(record_pattern_list, iodef_record_pattern_t);
         iodef_time_t *date_time;
         iodef_application_t *application;
         LISTED_OBJECT(record_item_list, iodef_record_item_t);
         iodef_record_data_restriction_t restriction;
 
};


/**
 * iodef_record_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_record_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_record_restriction_t iodef_record_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_record_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_restriction", name);
}

/**
 * iodef_record_restriction_to_string:
 * @val: an enumeration value for #iodef_record_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_record_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_record_restriction_to_string(iodef_record_restriction_t val)
{
        const struct {
              iodef_record_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_record {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(record_data_list, iodef_record_data_t);
         iodef_record_restriction_t restriction;
 
};



struct iodef_reference {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(url_list, libiodef_string_t);
         LISTED_OBJECT(description_list, libiodef_string_t);
         REQUIRED(libiodef_string_t, *reference_name);
 
};


/**
 * iodef_method_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_method_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_method_restriction_t iodef_method_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_method_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for method_restriction", name);
}

/**
 * iodef_method_restriction_to_string:
 * @val: an enumeration value for #iodef_method_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_method_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_method_restriction_to_string(iodef_method_restriction_t val)
{
        const struct {
              iodef_method_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_method {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(reference_list, iodef_reference_t);
         iodef_method_restriction_t restriction;
 
};


/**
 * iodef_time_impact_duration_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_time_impact_duration_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_time_impact_duration_t iodef_time_impact_duration_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_time_impact_duration_t val;
              const char *name;
        } tbl[] = {
            { IODEF_TIME_IMPACT_DURATION_SECOND, "second" },
            { IODEF_TIME_IMPACT_DURATION_MINUTE, "minute" },
            { IODEF_TIME_IMPACT_DURATION_HOUR, "hour" },
            { IODEF_TIME_IMPACT_DURATION_DAY, "day" },
            { IODEF_TIME_IMPACT_DURATION_MONTH, "month" },
            { IODEF_TIME_IMPACT_DURATION_QUARTER, "quarter" },
            { IODEF_TIME_IMPACT_DURATION_YEAR, "year" },
            { IODEF_TIME_IMPACT_DURATION_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_duration", name);
}

/**
 * iodef_time_impact_duration_to_string:
 * @val: an enumeration value for #iodef_time_impact_duration_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_time_impact_duration_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_time_impact_duration_to_string(iodef_time_impact_duration_t val)
{
        const struct {
              iodef_time_impact_duration_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_TIME_IMPACT_DURATION_SECOND, "second" },
                { IODEF_TIME_IMPACT_DURATION_MINUTE, "minute" },
                { IODEF_TIME_IMPACT_DURATION_HOUR, "hour" },
                { IODEF_TIME_IMPACT_DURATION_DAY, "day" },
                { IODEF_TIME_IMPACT_DURATION_MONTH, "month" },
                { IODEF_TIME_IMPACT_DURATION_QUARTER, "quarter" },
                { IODEF_TIME_IMPACT_DURATION_YEAR, "year" },
                { IODEF_TIME_IMPACT_DURATION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_time_impact_metric_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_time_impact_metric_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_time_impact_metric_t iodef_time_impact_metric_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_time_impact_metric_t val;
              const char *name;
        } tbl[] = {
            { IODEF_TIME_IMPACT_METRIC_LABOR, "labor" },
            { IODEF_TIME_IMPACT_METRIC_ELAPSED, "elapsed" },
            { IODEF_TIME_IMPACT_METRIC_DOWNTIME, "downtime" },
            { IODEF_TIME_IMPACT_METRIC_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_metric", name);
}

/**
 * iodef_time_impact_metric_to_string:
 * @val: an enumeration value for #iodef_time_impact_metric_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_time_impact_metric_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_time_impact_metric_to_string(iodef_time_impact_metric_t val)
{
        const struct {
              iodef_time_impact_metric_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_TIME_IMPACT_METRIC_LABOR, "labor" },
                { IODEF_TIME_IMPACT_METRIC_ELAPSED, "elapsed" },
                { IODEF_TIME_IMPACT_METRIC_DOWNTIME, "downtime" },
                { IODEF_TIME_IMPACT_METRIC_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_time_impact_severity_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_time_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_time_impact_severity_t iodef_time_impact_severity_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_time_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { IODEF_TIME_IMPACT_SEVERITY_LOW, "low" },
            { IODEF_TIME_IMPACT_SEVERITY_MEDIUM, "medium" },
            { IODEF_TIME_IMPACT_SEVERITY_HIGH, "high" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_severity", name);
}

/**
 * iodef_time_impact_severity_to_string:
 * @val: an enumeration value for #iodef_time_impact_severity_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_time_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_time_impact_severity_to_string(iodef_time_impact_severity_t val)
{
        const struct {
              iodef_time_impact_severity_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_TIME_IMPACT_SEVERITY_LOW, "low" },
                { IODEF_TIME_IMPACT_SEVERITY_MEDIUM, "medium" },
                { IODEF_TIME_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_time_impact {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         libiodef_string_t *ext_metric;
         iodef_time_impact_duration_t duration;
         iodef_time_impact_metric_t metric;
         iodef_time_impact_severity_t severity;
         libiodef_string_t *ext_duration;
 
};


/**
 * iodef_impact_lang_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_impact_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_impact_lang_t iodef_impact_lang_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_impact_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_lang", name);
}

/**
 * iodef_impact_lang_to_string:
 * @val: an enumeration value for #iodef_impact_lang_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_impact_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_impact_lang_to_string(iodef_impact_lang_t val)
{
        const struct {
              iodef_impact_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_impact_completion_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_impact_completion_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_impact_completion_t iodef_impact_completion_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_impact_completion_t val;
              const char *name;
        } tbl[] = {
            { IODEF_IMPACT_COMPLETION_FAILED, "failed" },
            { IODEF_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_completion", name);
}

/**
 * iodef_impact_completion_to_string:
 * @val: an enumeration value for #iodef_impact_completion_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_impact_completion_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_impact_completion_to_string(iodef_impact_completion_t val)
{
        const struct {
              iodef_impact_completion_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_IMPACT_COMPLETION_FAILED, "failed" },
                { IODEF_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_impact_type_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_impact_type_t iodef_impact_type_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_impact_type_t val;
              const char *name;
        } tbl[] = {
            { IODEF_IMPACT_TYPE_ADMIN, "admin" },
            { IODEF_IMPACT_TYPE_DOS, "dos" },
            { IODEF_IMPACT_TYPE_FILE, "file" },
            { IODEF_IMPACT_TYPE_INFO_LEAK, "info-leak" },
            { IODEF_IMPACT_TYPE_MISCONFIGURATION, "misconfiguration" },
            { IODEF_IMPACT_TYPE_POLICY, "policy" },
            { IODEF_IMPACT_TYPE_RECON, "recon" },
            { IODEF_IMPACT_TYPE_SOCIAL_ENGINEERING, "social-engineering" },
            { IODEF_IMPACT_TYPE_USER, "user" },
            { IODEF_IMPACT_TYPE_UNKNOWN, "unknown" },
            { IODEF_IMPACT_TYPE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_type", name);
}

/**
 * iodef_impact_type_to_string:
 * @val: an enumeration value for #iodef_impact_type_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_impact_type_to_string(iodef_impact_type_t val)
{
        const struct {
              iodef_impact_type_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_IMPACT_TYPE_ADMIN, "admin" },
                { IODEF_IMPACT_TYPE_DOS, "dos" },
                { IODEF_IMPACT_TYPE_FILE, "file" },
                { IODEF_IMPACT_TYPE_INFO_LEAK, "info-leak" },
                { IODEF_IMPACT_TYPE_MISCONFIGURATION, "misconfiguration" },
                { IODEF_IMPACT_TYPE_POLICY, "policy" },
                { IODEF_IMPACT_TYPE_RECON, "recon" },
                { IODEF_IMPACT_TYPE_SOCIAL_ENGINEERING, "social-engineering" },
                { IODEF_IMPACT_TYPE_USER, "user" },
                { IODEF_IMPACT_TYPE_UNKNOWN, "unknown" },
                { IODEF_IMPACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_impact_severity_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_impact_severity_t iodef_impact_severity_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { IODEF_IMPACT_SEVERITY_LOW, "low" },
            { IODEF_IMPACT_SEVERITY_MEDIUM, "medium" },
            { IODEF_IMPACT_SEVERITY_HIGH, "high" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for impact_severity", name);
}

/**
 * iodef_impact_severity_to_string:
 * @val: an enumeration value for #iodef_impact_severity_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_impact_severity_to_string(iodef_impact_severity_t val)
{
        const struct {
              iodef_impact_severity_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_IMPACT_SEVERITY_LOW, "low" },
                { IODEF_IMPACT_SEVERITY_MEDIUM, "medium" },
                { IODEF_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_impact {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_impact_lang_t lang;
         iodef_impact_completion_t completion;
         iodef_impact_type_t type;
         iodef_impact_severity_t severity;
         libiodef_string_t *ext_type;
 
};


/**
 * iodef_confidence_rating_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_confidence_rating_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_confidence_rating_t iodef_confidence_rating_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_confidence_rating_t val;
              const char *name;
        } tbl[] = {
            { IODEF_CONFIDENCE_RATING_LOW, "low" },
            { IODEF_CONFIDENCE_RATING_MEDIUM, "medium" },
            { IODEF_CONFIDENCE_RATING_HIGH, "high" },
            { IODEF_CONFIDENCE_RATING_NUMERIC, "numeric" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for confidence_rating", name);
}

/**
 * iodef_confidence_rating_to_string:
 * @val: an enumeration value for #iodef_confidence_rating_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_confidence_rating_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_confidence_rating_to_string(iodef_confidence_rating_t val)
{
        const struct {
              iodef_confidence_rating_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_CONFIDENCE_RATING_LOW, "low" },
                { IODEF_CONFIDENCE_RATING_MEDIUM, "medium" },
                { IODEF_CONFIDENCE_RATING_HIGH, "high" },
                { IODEF_CONFIDENCE_RATING_NUMERIC, "numeric" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_confidence {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         iodef_confidence_rating_t rating;
 
};


/**
 * iodef_monetary_impact_severity_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_monetary_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_monetary_impact_severity_t iodef_monetary_impact_severity_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_monetary_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { IODEF_MONETARY_IMPACT_SEVERITY_LOW, "low" },
            { IODEF_MONETARY_IMPACT_SEVERITY_MEDIUM, "medium" },
            { IODEF_MONETARY_IMPACT_SEVERITY_HIGH, "high" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for monetary_impact_severity", name);
}

/**
 * iodef_monetary_impact_severity_to_string:
 * @val: an enumeration value for #iodef_monetary_impact_severity_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_monetary_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_monetary_impact_severity_to_string(iodef_monetary_impact_severity_t val)
{
        const struct {
              iodef_monetary_impact_severity_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_MONETARY_IMPACT_SEVERITY_LOW, "low" },
                { IODEF_MONETARY_IMPACT_SEVERITY_MEDIUM, "medium" },
                { IODEF_MONETARY_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_monetary_impact {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         REQUIRED(libiodef_string_t, *currency);
         iodef_monetary_impact_severity_t severity;
 
};


/**
 * iodef_counter_duration_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_counter_duration_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_counter_duration_t iodef_counter_duration_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_counter_duration_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for counter_duration", name);
}

/**
 * iodef_counter_duration_to_string:
 * @val: an enumeration value for #iodef_counter_duration_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_counter_duration_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_counter_duration_to_string(iodef_counter_duration_t val)
{
        const struct {
              iodef_counter_duration_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_counter_type_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_counter_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_counter_type_t iodef_counter_type_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_counter_type_t val;
              const char *name;
        } tbl[] = {
            { IODEF_COUNTER_TYPE_BYTE, "byte" },
            { IODEF_COUNTER_TYPE_PACKET, "packet" },
            { IODEF_COUNTER_TYPE_FLOW, "flow" },
            { IODEF_COUNTER_TYPE_SESSION, "session" },
            { IODEF_COUNTER_TYPE_ALERT, "alert" },
            { IODEF_COUNTER_TYPE_MESSAGE, "message" },
            { IODEF_COUNTER_TYPE_EVENT, "event" },
            { IODEF_COUNTER_TYPE_HOST, "host" },
            { IODEF_COUNTER_TYPE_SITE, "site" },
            { IODEF_COUNTER_TYPE_ORGANIZATION, "organization" },
            { IODEF_COUNTER_TYPE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for counter_type", name);
}

/**
 * iodef_counter_type_to_string:
 * @val: an enumeration value for #iodef_counter_type_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_counter_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_counter_type_to_string(iodef_counter_type_t val)
{
        const struct {
              iodef_counter_type_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_COUNTER_TYPE_BYTE, "byte" },
                { IODEF_COUNTER_TYPE_PACKET, "packet" },
                { IODEF_COUNTER_TYPE_FLOW, "flow" },
                { IODEF_COUNTER_TYPE_SESSION, "session" },
                { IODEF_COUNTER_TYPE_ALERT, "alert" },
                { IODEF_COUNTER_TYPE_MESSAGE, "message" },
                { IODEF_COUNTER_TYPE_EVENT, "event" },
                { IODEF_COUNTER_TYPE_HOST, "host" },
                { IODEF_COUNTER_TYPE_SITE, "site" },
                { IODEF_COUNTER_TYPE_ORGANIZATION, "organization" },
                { IODEF_COUNTER_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_counter {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_counter_duration_t duration;
         iodef_counter_type_t type;
         libiodef_string_t *ext_duration;
         libiodef_string_t *ext_type;
 
};


/**
 * iodef_assessment_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_assessment_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_assessment_restriction_t iodef_assessment_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_assessment_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for assessment_restriction", name);
}

/**
 * iodef_assessment_restriction_to_string:
 * @val: an enumeration value for #iodef_assessment_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_assessment_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_assessment_restriction_to_string(iodef_assessment_restriction_t val)
{
        const struct {
              iodef_assessment_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_assessment_occurrence_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_assessment_occurrence_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_assessment_occurrence_t iodef_assessment_occurrence_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_assessment_occurrence_t val;
              const char *name;
        } tbl[] = {
            { IODEF_ASSESSMENT_OCCURRENCE_ACTUAL, "actual" },
            { IODEF_ASSESSMENT_OCCURRENCE_POTENTIAL, "potential" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for assessment_occurrence", name);
}

/**
 * iodef_assessment_occurrence_to_string:
 * @val: an enumeration value for #iodef_assessment_occurrence_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_assessment_occurrence_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_assessment_occurrence_to_string(iodef_assessment_occurrence_t val)
{
        const struct {
              iodef_assessment_occurrence_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_ASSESSMENT_OCCURRENCE_ACTUAL, "actual" },
                { IODEF_ASSESSMENT_OCCURRENCE_POTENTIAL, "potential" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_assessment {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(impact_list, iodef_impact_t);
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         iodef_confidence_t *confidence;
         LISTED_OBJECT(time_impact_list, iodef_time_impact_t);
         LISTED_OBJECT(monetary_impact_list, iodef_monetary_impact_t);
         LISTED_OBJECT(counter_list, iodef_counter_t);
         iodef_assessment_restriction_t restriction;
         iodef_assessment_occurrence_t occurrence;
 
};



struct iodef_service {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         OPTIONAL_INT(uint32_t, proto_code);
         OPTIONAL_INT(uint32_t, proto_flags);
         libiodef_string_t *portlist;
         LISTED_OBJECT(application_list, iodef_application_t);
         OPTIONAL_INT(uint32_t, proto_type);
         OPTIONAL_INT(uint32_t, port);
         OPTIONAL_INT(uint32_t, ip_protocol);
 
};


/**
 * iodef_address_category_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_address_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_address_category_t iodef_address_category_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_address_category_t val;
              const char *name;
        } tbl[] = {
            { IODEF_ADDRESS_CATEGORY_ASN, "asn" },
            { IODEF_ADDRESS_CATEGORY_ATM, "atm" },
            { IODEF_ADDRESS_CATEGORY_E_MAIL, "e-mail" },
            { IODEF_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },
            { IODEF_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },
            { IODEF_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },
            { IODEF_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },
            { IODEF_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },
            { IODEF_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },
            { IODEF_ADDRESS_CATEGORY_MAC, "mac" },
            { IODEF_ADDRESS_CATEGORY_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for address_category", name);
}

/**
 * iodef_address_category_to_string:
 * @val: an enumeration value for #iodef_address_category_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_address_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_address_category_to_string(iodef_address_category_t val)
{
        const struct {
              iodef_address_category_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_ADDRESS_CATEGORY_ASN, "asn" },
                { IODEF_ADDRESS_CATEGORY_ATM, "atm" },
                { IODEF_ADDRESS_CATEGORY_E_MAIL, "e-mail" },
                { IODEF_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },
                { IODEF_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },
                { IODEF_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },
                { IODEF_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },
                { IODEF_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },
                { IODEF_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },
                { IODEF_ADDRESS_CATEGORY_MAC, "mac" },
                { IODEF_ADDRESS_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_address {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_address_category_t category;
         libiodef_string_t *vlan_name;
         libiodef_string_t *ext_category;
         libiodef_string_t *vlan_num;
 
};


/**
 * iodef_node_role_category_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_node_role_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_node_role_category_t iodef_node_role_category_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_node_role_category_t val;
              const char *name;
        } tbl[] = {
            { IODEF_NODE_ROLE_CATEGORY_CLIENT, "client" },
            { IODEF_NODE_ROLE_CATEGORY_SERVER_INTERNAL, "server-internal" },
            { IODEF_NODE_ROLE_CATEGORY_SERVER_PUBLIC, "server-public" },
            { IODEF_NODE_ROLE_CATEGORY_WWW, "www" },
            { IODEF_NODE_ROLE_CATEGORY_MAIL, "mail" },
            { IODEF_NODE_ROLE_CATEGORY_MESSAGING, "messaging" },
            { IODEF_NODE_ROLE_CATEGORY_STREAMING, "streaming" },
            { IODEF_NODE_ROLE_CATEGORY_VOICE, "voice" },
            { IODEF_NODE_ROLE_CATEGORY_FILE, "file" },
            { IODEF_NODE_ROLE_CATEGORY_FTP, "ftp" },
            { IODEF_NODE_ROLE_CATEGORY_P2P, "p2p" },
            { IODEF_NODE_ROLE_CATEGORY_NAME, "name" },
            { IODEF_NODE_ROLE_CATEGORY_DIRECTORY, "directory" },
            { IODEF_NODE_ROLE_CATEGORY_CREDENTIAL, "credential" },
            { IODEF_NODE_ROLE_CATEGORY_PRINT, "print" },
            { IODEF_NODE_ROLE_CATEGORY_APPLICATION, "application" },
            { IODEF_NODE_ROLE_CATEGORY_DATABASE, "database" },
            { IODEF_NODE_ROLE_CATEGORY_INFRA, "infra" },
            { IODEF_NODE_ROLE_CATEGORY_LOG, "log" },
            { IODEF_NODE_ROLE_CATEGORY_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for node_role_category", name);
}

/**
 * iodef_node_role_category_to_string:
 * @val: an enumeration value for #iodef_node_role_category_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_node_role_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_node_role_category_to_string(iodef_node_role_category_t val)
{
        const struct {
              iodef_node_role_category_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_NODE_ROLE_CATEGORY_CLIENT, "client" },
                { IODEF_NODE_ROLE_CATEGORY_SERVER_INTERNAL, "server-internal" },
                { IODEF_NODE_ROLE_CATEGORY_SERVER_PUBLIC, "server-public" },
                { IODEF_NODE_ROLE_CATEGORY_WWW, "www" },
                { IODEF_NODE_ROLE_CATEGORY_MAIL, "mail" },
                { IODEF_NODE_ROLE_CATEGORY_MESSAGING, "messaging" },
                { IODEF_NODE_ROLE_CATEGORY_STREAMING, "streaming" },
                { IODEF_NODE_ROLE_CATEGORY_VOICE, "voice" },
                { IODEF_NODE_ROLE_CATEGORY_FILE, "file" },
                { IODEF_NODE_ROLE_CATEGORY_FTP, "ftp" },
                { IODEF_NODE_ROLE_CATEGORY_P2P, "p2p" },
                { IODEF_NODE_ROLE_CATEGORY_NAME, "name" },
                { IODEF_NODE_ROLE_CATEGORY_DIRECTORY, "directory" },
                { IODEF_NODE_ROLE_CATEGORY_CREDENTIAL, "credential" },
                { IODEF_NODE_ROLE_CATEGORY_PRINT, "print" },
                { IODEF_NODE_ROLE_CATEGORY_APPLICATION, "application" },
                { IODEF_NODE_ROLE_CATEGORY_DATABASE, "database" },
                { IODEF_NODE_ROLE_CATEGORY_INFRA, "infra" },
                { IODEF_NODE_ROLE_CATEGORY_LOG, "log" },
                { IODEF_NODE_ROLE_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_node_role_lang_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_node_role_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_node_role_lang_t iodef_node_role_lang_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_node_role_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for node_role_lang", name);
}

/**
 * iodef_node_role_lang_to_string:
 * @val: an enumeration value for #iodef_node_role_lang_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_node_role_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_node_role_lang_to_string(iodef_node_role_lang_t val)
{
        const struct {
              iodef_node_role_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_node_role {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_node_role_category_t category;
         iodef_node_role_lang_t lang;
         libiodef_string_t *ext_category;
 
};



struct iodef_node {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(node_name_list, libiodef_string_t);
         LISTED_OBJECT(counter_list, iodef_counter_t);
         iodef_time_t *date_time;
         LISTED_OBJECT(node_role_list, iodef_node_role_t);
         libiodef_string_t *location;
         LISTED_OBJECT(address_list, iodef_address_t);
 
};



struct iodef_operating_system {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         libiodef_string_t *url;
         libiodef_string_t *vendor;
         libiodef_string_t *name;
         libiodef_string_t *family;
         libiodef_string_t *swid;
         libiodef_string_t *patch;
         libiodef_string_t *version;
         libiodef_string_t *configid;
 
};


/**
 * iodef_system_category_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_system_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_system_category_t iodef_system_category_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_system_category_t val;
              const char *name;
        } tbl[] = {
            { IODEF_SYSTEM_CATEGORY_SOURCE, "source" },
            { IODEF_SYSTEM_CATEGORY_TARGET, "target" },
            { IODEF_SYSTEM_CATEGORY_INTERMEDIATE, "intermediate" },
            { IODEF_SYSTEM_CATEGORY_SENSOR, "sensor" },
            { IODEF_SYSTEM_CATEGORY_INFRASTRUCTURE, "infrastructure" },
            { IODEF_SYSTEM_CATEGORY_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_category", name);
}

/**
 * iodef_system_category_to_string:
 * @val: an enumeration value for #iodef_system_category_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_system_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_system_category_to_string(iodef_system_category_t val)
{
        const struct {
              iodef_system_category_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_SYSTEM_CATEGORY_SOURCE, "source" },
                { IODEF_SYSTEM_CATEGORY_TARGET, "target" },
                { IODEF_SYSTEM_CATEGORY_INTERMEDIATE, "intermediate" },
                { IODEF_SYSTEM_CATEGORY_SENSOR, "sensor" },
                { IODEF_SYSTEM_CATEGORY_INFRASTRUCTURE, "infrastructure" },
                { IODEF_SYSTEM_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_system_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_system_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_system_restriction_t iodef_system_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_system_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_restriction", name);
}

/**
 * iodef_system_restriction_to_string:
 * @val: an enumeration value for #iodef_system_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_system_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_system_restriction_to_string(iodef_system_restriction_t val)
{
        const struct {
              iodef_system_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_system_spoofed_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_system_spoofed_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_system_spoofed_t iodef_system_spoofed_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_system_spoofed_t val;
              const char *name;
        } tbl[] = {
            { IODEF_SYSTEM_SPOOFED_UNKNOWN, "unknown" },
            { IODEF_SYSTEM_SPOOFED_YES, "yes" },
            { IODEF_SYSTEM_SPOOFED_NO, "no" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_spoofed", name);
}

/**
 * iodef_system_spoofed_to_string:
 * @val: an enumeration value for #iodef_system_spoofed_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_system_spoofed_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_system_spoofed_to_string(iodef_system_spoofed_t val)
{
        const struct {
              iodef_system_spoofed_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_SYSTEM_SPOOFED_UNKNOWN, "unknown" },
                { IODEF_SYSTEM_SPOOFED_YES, "yes" },
                { IODEF_SYSTEM_SPOOFED_NO, "no" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_system {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         REQUIRED(iodef_node_t, *node);
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(service_list, iodef_service_t);
         LISTED_OBJECT(counter_list, iodef_counter_t);
         iodef_operating_system_t *operating_system;
         iodef_system_category_t category;
         iodef_system_restriction_t restriction;
         libiodef_string_t *ext_category;
         iodef_system_spoofed_t spoofed;
         libiodef_string_t *interface;
 
};



struct iodef_flow {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(system_list, iodef_system_t);
 
};


/**
 * iodef_event_data_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_event_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_event_data_restriction_t iodef_event_data_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_event_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for event_data_restriction", name);
}

/**
 * iodef_event_data_restriction_to_string:
 * @val: an enumeration value for #iodef_event_data_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_event_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_event_data_restriction_to_string(iodef_event_data_restriction_t val)
{
        const struct {
              iodef_event_data_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_event_data {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_time_t *detect_time;
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(flow_list, iodef_flow_t);
         LISTED_OBJECT(expectation_list, iodef_expectation_t);
         iodef_record_t *record;
         LISTED_OBJECT(contact_list, iodef_contact_t);
         iodef_time_t *start_time;
         LISTED_OBJECT(event_data_list, iodef_event_data_t);
         iodef_time_t *end_time;
         iodef_assessment_t *assessment;
         LISTED_OBJECT(method_list, iodef_method_t);
         iodef_event_data_restriction_t restriction;
 
};


/**
 * iodef_incident_lang_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_incident_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_incident_lang_t iodef_incident_lang_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_incident_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_lang", name);
}

/**
 * iodef_incident_lang_to_string:
 * @val: an enumeration value for #iodef_incident_lang_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_incident_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_incident_lang_to_string(iodef_incident_lang_t val)
{
        const struct {
              iodef_incident_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_incident_restriction_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_incident_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_incident_restriction_t iodef_incident_restriction_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_incident_restriction_t val;
              const char *name;
        } tbl[] = {
            { IODEF_INCIDENT_RESTRICTION_PUBLIC, "public" },
            { IODEF_INCIDENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },
            { IODEF_INCIDENT_RESTRICTION_PRIVATE, "private" },
            { IODEF_INCIDENT_RESTRICTION_DEFAULT, "default" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_restriction", name);
}

/**
 * iodef_incident_restriction_to_string:
 * @val: an enumeration value for #iodef_incident_restriction_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_incident_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_incident_restriction_to_string(iodef_incident_restriction_t val)
{
        const struct {
              iodef_incident_restriction_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_INCIDENT_RESTRICTION_PUBLIC, "public" },
                { IODEF_INCIDENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },
                { IODEF_INCIDENT_RESTRICTION_PRIVATE, "private" },
                { IODEF_INCIDENT_RESTRICTION_DEFAULT, "default" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}

/**
 * iodef_incident_purpose_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_incident_purpose_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_incident_purpose_t iodef_incident_purpose_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_incident_purpose_t val;
              const char *name;
        } tbl[] = {
            { IODEF_INCIDENT_PURPOSE_TRACEBACK, "traceback" },
            { IODEF_INCIDENT_PURPOSE_MITIGATION, "mitigation" },
            { IODEF_INCIDENT_PURPOSE_REPORTING, "reporting" },
            { IODEF_INCIDENT_PURPOSE_OTHER, "other" },
            { IODEF_INCIDENT_PURPOSE_EXT_VALUE, "ext-value" },
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_purpose", name);
}

/**
 * iodef_incident_purpose_to_string:
 * @val: an enumeration value for #iodef_incident_purpose_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_incident_purpose_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_incident_purpose_to_string(iodef_incident_purpose_t val)
{
        const struct {
              iodef_incident_purpose_t val;
              const char *name;
        } tbl[] = {{ 0, NULL },
                { IODEF_INCIDENT_PURPOSE_TRACEBACK, "traceback" },
                { IODEF_INCIDENT_PURPOSE_MITIGATION, "mitigation" },
                { IODEF_INCIDENT_PURPOSE_REPORTING, "reporting" },
                { IODEF_INCIDENT_PURPOSE_OTHER, "other" },
                { IODEF_INCIDENT_PURPOSE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_incident {
 
         IODEF_LINKED_OBJECT;
         REFCOUNT;
 
         iodef_time_t *detect_time;
         LISTED_OBJECT(additional_data_list, iodef_additional_data_t);
         iodef_time_t *end_time;
         LISTED_OBJECT(description_list, libiodef_string_t);
         LISTED_OBJECT(contact_list, iodef_contact_t);
         iodef_alternative_id_t *alternative_id;
         REQUIRED(iodef_time_t, *report_time);
         iodef_time_t *start_time;
         LISTED_OBJECT(event_data_list, iodef_event_data_t);
         iodef_related_activity_t *related_activity;
         REQUIRED(iodef_incident_id_t, *incident_id);
         LISTED_OBJECT(assessment_list, iodef_assessment_t);
         LISTED_OBJECT(method_list, iodef_method_t);
         iodef_history_t *history;
         iodef_incident_lang_t lang;
         iodef_incident_restriction_t restriction;
         libiodef_string_t *ext_purpose;
         iodef_incident_purpose_t purpose;
 
};


/**
 * iodef_document_lang_to_numeric:
 * @name: pointer to an IODEF string representation of a #iodef_document_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodef_document_lang_t iodef_document_lang_to_numeric(const char *name)
{
        size_t i;
        const struct {
              iodef_document_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodef_return_val_if_fail(name, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodef_error_verbose(LIBIODEF_ERROR_IODEF_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for document_lang", name);
}

/**
 * iodef_document_lang_to_string:
 * @val: an enumeration value for #iodef_document_lang_t.
 *
 * Return the IODEF string equivalent of @val provided #iodef_document_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodef_document_lang_to_string(iodef_document_lang_t val)
{
        const struct {
              iodef_document_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
}


struct iodef_document {
 
         IODEF_OBJECT;
         REFCOUNT;
 
         LISTED_OBJECT(incident_list, iodef_incident_t);
         iodef_document_lang_t lang;
         libiodef_string_t *formatid;
         REQUIRED(libiodef_string_t, *version);
 
};


/**
 * iodef_additional_data_new:
 * @ret: Pointer where to store the created #iodef_additional_data_t object.
 *
 * Create a new #iodef_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_additional_data_new(iodef_additional_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_ADDITIONAL_DATA;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
                int retval = iodef_data_new(&(*ret)->data);

                if ( retval < 0 ) {
                        iodef_additional_data_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_additional_data_ref:
 * @additional_data: pointer to a #iodef_additional_data_t object.
 *
 * Increase @additional_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @additional_data.
 */
iodef_additional_data_t *iodef_additional_data_ref(iodef_additional_data_t *additional_data)
{
        libiodef_return_val_if_fail(additional_data, NULL);
        additional_data->refcount++;

        return additional_data;
}

int _iodef_additional_data_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_additional_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ADDITIONAL_DATA_RESTRICTION, ptr->restriction);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ADDITIONAL_DATA_TYPE, ptr->type);

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->formatid, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->meaning, TRUE);
                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_dtype, TRUE);
                case 5:
                       return get_value_from_data((iodef_value_t **) childptr,  ptr->data, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_additional_data_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_additional_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_additional_data_new_restriction(ptr, (iodef_additional_data_restriction_t **) ret);

                case 1:
                        return iodef_additional_data_new_type(ptr, (iodef_additional_data_type_t **) ret);

                case 2:
                        return iodef_additional_data_new_formatid(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_additional_data_new_meaning(ptr, (libiodef_string_t **) ret);

                case 4:
                        return iodef_additional_data_new_ext_dtype(ptr, (libiodef_string_t **) ret);

                case 5:
                        return iodef_additional_data_new_data(ptr, (iodef_data_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_additional_data_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_additional_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->restriction = 0;
                        return 0;

                case 1:
                        ptr->type = 0;
                        return 0;

                case 2:
                        if ( ptr->formatid ) {
                                libiodef_string_destroy(ptr->formatid);
                                ptr->formatid = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->meaning ) {
                                libiodef_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->ext_dtype ) {
                                libiodef_string_destroy(ptr->ext_dtype);
                                ptr->ext_dtype = NULL;
                        }

                        return 0;

                case 5:
                        if ( ptr->data ) {
                                iodef_data_destroy(ptr->data);
                                ptr->data = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_additional_data_destroy_internal(iodef_additional_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->formatid ) {
                libiodef_string_destroy(ptr->formatid);
                ptr->formatid = NULL;
        }

        if ( ptr->meaning ) {
                libiodef_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }

        if ( ptr->ext_dtype ) {
                libiodef_string_destroy(ptr->ext_dtype);
                ptr->ext_dtype = NULL;
        }

        if ( ptr->data ) {
                iodef_data_destroy(ptr->data);
                ptr->data = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_additional_data_destroy:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_additional_data_destroy(iodef_additional_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_additional_data_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_additional_data_get_restriction:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get restriction children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a iodef_additional_data_restriction_t object, or NULL if the children object is not set.
 */
iodef_additional_data_restriction_t iodef_additional_data_get_restriction(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_additional_data_set_restriction:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @restriction: pointer to a #iodef_additional_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_additional_data_set_restriction(iodef_additional_data_t *ptr, iodef_additional_data_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_additional_data_new_restriction:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_additional_data_t.
 * If @ptr already contain a #iodef_additional_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_restriction(iodef_additional_data_t *ptr, iodef_additional_data_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_additional_data_get_type:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get type children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a iodef_additional_data_type_t object, or NULL if the children object is not set.
 */
iodef_additional_data_type_t iodef_additional_data_get_type(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;
}

/**
 * iodef_additional_data_set_type:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @type: pointer to a #iodef_additional_data_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void iodef_additional_data_set_type(iodef_additional_data_t *ptr, iodef_additional_data_type_t type)
{
        libiodef_return_if_fail(ptr);
        ptr->type = type;

        ptr->_type_is_set = TRUE;

}

/**
 * iodef_additional_data_new_type:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_type_t object.
 *
 * Create a new type object, children of #iodef_additional_data_t.
 * If @ptr already contain a #iodef_additional_data_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_type(iodef_additional_data_t *ptr, iodef_additional_data_type_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->_type_is_set = TRUE;
        *ret = &ptr->type;
        return 0;
}

/**
 * iodef_additional_data_get_formatid:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get formatid children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_additional_data_get_formatid(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->formatid;
}

/**
 * iodef_additional_data_set_formatid:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @formatid: pointer to a #libiodef_string_t object.
 *
 * Set @formatid object as a children of @ptr.
 * if @ptr already contain an @formatid object, then it is destroyed,
 * and updated to point to the provided @formatid object.
 */

void iodef_additional_data_set_formatid(iodef_additional_data_t *ptr, libiodef_string_t *formatid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->formatid )
                libiodef_string_destroy(ptr->formatid);

        ptr->formatid = formatid;
}

/**
 * iodef_additional_data_new_formatid:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new formatid object, children of #iodef_additional_data_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_formatid(iodef_additional_data_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->formatid ) {
                retval = libiodef_string_new(&ptr->formatid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->formatid;
        return 0;
}

/**
 * iodef_additional_data_get_meaning:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get meaning children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_additional_data_get_meaning(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;
}

/**
 * iodef_additional_data_set_meaning:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @meaning: pointer to a #libiodef_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodef_additional_data_set_meaning(iodef_additional_data_t *ptr, libiodef_string_t *meaning)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->meaning )
                libiodef_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}

/**
 * iodef_additional_data_new_meaning:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new meaning object, children of #iodef_additional_data_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_meaning(iodef_additional_data_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libiodef_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->meaning;
        return 0;
}

/**
 * iodef_additional_data_get_ext_dtype:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get ext_dtype children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_additional_data_get_ext_dtype(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_dtype;
}

/**
 * iodef_additional_data_set_ext_dtype:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ext_dtype: pointer to a #libiodef_string_t object.
 *
 * Set @ext_dtype object as a children of @ptr.
 * if @ptr already contain an @ext_dtype object, then it is destroyed,
 * and updated to point to the provided @ext_dtype object.
 */

void iodef_additional_data_set_ext_dtype(iodef_additional_data_t *ptr, libiodef_string_t *ext_dtype)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_dtype )
                libiodef_string_destroy(ptr->ext_dtype);

        ptr->ext_dtype = ext_dtype;
}

/**
 * iodef_additional_data_new_ext_dtype:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_dtype object, children of #iodef_additional_data_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_ext_dtype(iodef_additional_data_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_dtype ) {
                retval = libiodef_string_new(&ptr->ext_dtype);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_dtype;
        return 0;
}

/**
 * iodef_additional_data_get_data:
 * @ptr: pointer to a #iodef_additional_data_t object.
 *
 * Get data children of the #iodef_additional_data_t object.
 *
 * Returns: a pointer to a iodef_data_t object, or NULL if the children object is not set.
 */
iodef_data_t *iodef_additional_data_get_data(iodef_additional_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data;
}

/**
 * iodef_additional_data_set_data:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @data: pointer to a #iodef_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void iodef_additional_data_set_data(iodef_additional_data_t *ptr, iodef_data_t *data)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->data )
                iodef_data_destroy(ptr->data);

        ptr->data = data;
}

/**
 * iodef_additional_data_new_data:
 * @ptr: pointer to a #iodef_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodef_data_t object.
 *
 * Create a new data object, children of #iodef_additional_data_t.
 * If @ptr already contain a #iodef_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_additional_data_new_data(iodef_additional_data_t *ptr, iodef_data_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->data ) {
                retval = iodef_data_new(&ptr->data);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->data;
        return 0;
}

/**
 * iodef_additional_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_additional_data_copy(const iodef_additional_data_t *src, iodef_additional_data_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->restriction = src->restriction;

        dst->type = src->type;

        if ( dst->formatid ) {
                libiodef_string_destroy(dst->formatid);
                dst->formatid = NULL;
        }

        if ( src->formatid ) {
                ret = libiodef_string_clone(src->formatid, &dst->formatid);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->meaning ) {
                libiodef_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libiodef_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->ext_dtype ) {
                libiodef_string_destroy(dst->ext_dtype);
                dst->ext_dtype = NULL;
        }

        if ( src->ext_dtype ) {
                ret = libiodef_string_clone(src->ext_dtype, &dst->ext_dtype);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->data ) {
                ret = iodef_data_copy(src->data, dst->data);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_additional_data_clone(iodef_additional_data_t *src, iodef_additional_data_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_additional_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_additional_data_copy(src, *dst);
}

/**
 * iodef_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_additional_data_compare(const iodef_additional_data_t *obj1, const iodef_additional_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        if ( obj1->type != obj2->type )
                return -1;

        ret = libiodef_string_compare(obj1->formatid, obj2->formatid);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->ext_dtype, obj2->ext_dtype);
        if ( ret != 0 )
                return ret;

        ret = iodef_data_compare(obj1->data, obj2->data);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_email_new:
 * @ret: Pointer where to store the created #iodef_email_t object.
 *
 * Create a new #iodef_email_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_email_new(iodef_email_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_EMAIL;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
                int retval = libiodef_string_new(&(*ret)->email);

                if ( retval < 0 ) {
                        iodef_email_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_email_ref:
 * @email: pointer to a #iodef_email_t object.
 *
 * Increase @email reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @email.
 */
iodef_email_t *iodef_email_ref(iodef_email_t *email)
{
        libiodef_return_val_if_fail(email, NULL);
        email->refcount++;

        return email;
}

int _iodef_email_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_email_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_EMAIL_MEANING, ptr->meaning);

                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->email, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_email_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_email_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_email_new_meaning(ptr, (iodef_email_meaning_t **) ret);

                case 1:
                        return iodef_email_new_email(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_email_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_email_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->meaning = 0;
                        return 0;

                case 1:
                        if ( ptr->email ) {
                                libiodef_string_destroy(ptr->email);
                                ptr->email = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_email_destroy_internal(iodef_email_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->email ) {
                libiodef_string_destroy(ptr->email);
                ptr->email = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_email_destroy:
 * @ptr: pointer to a #iodef_email_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_email_destroy(iodef_email_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_email_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_email_get_meaning:
 * @ptr: pointer to a #iodef_email_t object.
 *
 * Get meaning children of the #iodef_email_t object.
 *
 * Returns: a pointer to a iodef_email_meaning_t object, or NULL if the children object is not set.
 */
iodef_email_meaning_t iodef_email_get_meaning(iodef_email_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;
}

/**
 * iodef_email_set_meaning:
 * @ptr: pointer to a #iodef_email_t object.
 * @meaning: pointer to a #iodef_email_meaning_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodef_email_set_meaning(iodef_email_t *ptr, iodef_email_meaning_t meaning)
{
        libiodef_return_if_fail(ptr);
        ptr->meaning = meaning;
}

/**
 * iodef_email_new_meaning:
 * @ptr: pointer to a #iodef_email_t object.
 * @ret: pointer to an address where to store the created #iodef_email_meaning_t object.
 *
 * Create a new meaning object, children of #iodef_email_t.
 * If @ptr already contain a #iodef_email_meaning_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_email_new_meaning(iodef_email_t *ptr, iodef_email_meaning_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->meaning;
        return 0;
}

/**
 * iodef_email_get_email:
 * @ptr: pointer to a #iodef_email_t object.
 *
 * Get email children of the #iodef_email_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_email_get_email(iodef_email_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email;
}

/**
 * iodef_email_set_email:
 * @ptr: pointer to a #iodef_email_t object.
 * @email: pointer to a #libiodef_string_t object.
 *
 * Set @email object as a children of @ptr.
 * if @ptr already contain an @email object, then it is destroyed,
 * and updated to point to the provided @email object.
 */

void iodef_email_set_email(iodef_email_t *ptr, libiodef_string_t *email)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->email )
                libiodef_string_destroy(ptr->email);

        ptr->email = email;
}

/**
 * iodef_email_new_email:
 * @ptr: pointer to a #iodef_email_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new email object, children of #iodef_email_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_email_new_email(iodef_email_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->email ) {
                retval = libiodef_string_new(&ptr->email);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->email;
        return 0;
}

/**
 * iodef_email_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_email_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_email_copy(const iodef_email_t *src, iodef_email_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->meaning = src->meaning;

        if ( src->email ) {
                ret = libiodef_string_copy(src->email, dst->email);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_email_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_email_clone(iodef_email_t *src, iodef_email_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_email_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_email_copy(src, *dst);
}

/**
 * iodef_email_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_email_compare(const iodef_email_t *obj1, const iodef_email_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->meaning != obj2->meaning )
                return -1;

        ret = libiodef_string_compare(obj1->email, obj2->email);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_registry_handle_new:
 * @ret: Pointer where to store the created #iodef_registry_handle_t object.
 *
 * Create a new #iodef_registry_handle_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_registry_handle_new(iodef_registry_handle_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_REGISTRY_HANDLE;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_registry_handle_ref:
 * @registry_handle: pointer to a #iodef_registry_handle_t object.
 *
 * Increase @registry_handle reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @registry_handle.
 */
iodef_registry_handle_t *iodef_registry_handle_ref(iodef_registry_handle_t *registry_handle)
{
        libiodef_return_val_if_fail(registry_handle, NULL);
        registry_handle->refcount++;

        return registry_handle;
}

int _iodef_registry_handle_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_registry_handle_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_REGISTRY_HANDLE_REGISTRY, ptr->registry);

                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_registry, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_registry_handle_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_registry_handle_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_registry_handle_new_registry(ptr, (iodef_registry_handle_registry_t **) ret);

                case 1:
                        return iodef_registry_handle_new_ext_registry(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_registry_handle_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_registry_handle_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->registry = 0;
                        return 0;

                case 1:
                        if ( ptr->ext_registry ) {
                                libiodef_string_destroy(ptr->ext_registry);
                                ptr->ext_registry = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_registry_handle_destroy_internal(iodef_registry_handle_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_registry ) {
                libiodef_string_destroy(ptr->ext_registry);
                ptr->ext_registry = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_registry_handle_destroy:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_registry_handle_destroy(iodef_registry_handle_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_registry_handle_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_registry_handle_get_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 *
 * Get registry children of the #iodef_registry_handle_t object.
 *
 * Returns: a pointer to a iodef_registry_handle_registry_t object, or NULL if the children object is not set.
 */
iodef_registry_handle_registry_t iodef_registry_handle_get_registry(iodef_registry_handle_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->registry;
}

/**
 * iodef_registry_handle_set_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 * @registry: pointer to a #iodef_registry_handle_registry_t object.
 *
 * Set @registry object as a children of @ptr.
 * if @ptr already contain an @registry object, then it is destroyed,
 * and updated to point to the provided @registry object.
 */

void iodef_registry_handle_set_registry(iodef_registry_handle_t *ptr, iodef_registry_handle_registry_t registry)
{
        libiodef_return_if_fail(ptr);
        ptr->registry = registry;
}

/**
 * iodef_registry_handle_new_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 * @ret: pointer to an address where to store the created #iodef_registry_handle_registry_t object.
 *
 * Create a new registry object, children of #iodef_registry_handle_t.
 * If @ptr already contain a #iodef_registry_handle_registry_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_registry_handle_new_registry(iodef_registry_handle_t *ptr, iodef_registry_handle_registry_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->registry;
        return 0;
}

/**
 * iodef_registry_handle_get_ext_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 *
 * Get ext_registry children of the #iodef_registry_handle_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_registry_handle_get_ext_registry(iodef_registry_handle_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_registry;
}

/**
 * iodef_registry_handle_set_ext_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 * @ext_registry: pointer to a #libiodef_string_t object.
 *
 * Set @ext_registry object as a children of @ptr.
 * if @ptr already contain an @ext_registry object, then it is destroyed,
 * and updated to point to the provided @ext_registry object.
 */

void iodef_registry_handle_set_ext_registry(iodef_registry_handle_t *ptr, libiodef_string_t *ext_registry)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_registry )
                libiodef_string_destroy(ptr->ext_registry);

        ptr->ext_registry = ext_registry;
}

/**
 * iodef_registry_handle_new_ext_registry:
 * @ptr: pointer to a #iodef_registry_handle_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_registry object, children of #iodef_registry_handle_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_registry_handle_new_ext_registry(iodef_registry_handle_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_registry ) {
                retval = libiodef_string_new(&ptr->ext_registry);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_registry;
        return 0;
}

/**
 * iodef_registry_handle_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_registry_handle_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_registry_handle_copy(const iodef_registry_handle_t *src, iodef_registry_handle_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->registry = src->registry;

        if ( dst->ext_registry ) {
                libiodef_string_destroy(dst->ext_registry);
                dst->ext_registry = NULL;
        }

        if ( src->ext_registry ) {
                ret = libiodef_string_clone(src->ext_registry, &dst->ext_registry);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_registry_handle_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_registry_handle_clone(iodef_registry_handle_t *src, iodef_registry_handle_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_registry_handle_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_registry_handle_copy(src, *dst);
}

/**
 * iodef_registry_handle_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_registry_handle_compare(const iodef_registry_handle_t *obj1, const iodef_registry_handle_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->registry != obj2->registry )
                return -1;

        ret = libiodef_string_compare(obj1->ext_registry, obj2->ext_registry);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_postal_address_new:
 * @ret: Pointer where to store the created #iodef_postal_address_t object.
 *
 * Create a new #iodef_postal_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_postal_address_new(iodef_postal_address_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_POSTAL_ADDRESS;

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_postal_address_ref:
 * @postal_address: pointer to a #iodef_postal_address_t object.
 *
 * Increase @postal_address reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @postal_address.
 */
iodef_postal_address_t *iodef_postal_address_ref(iodef_postal_address_t *postal_address)
{
        libiodef_return_val_if_fail(postal_address, NULL);
        postal_address->refcount++;

        return postal_address;
}

int _iodef_postal_address_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_postal_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_POSTAL_ADDRESS_LANG, ptr->lang);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_POSTAL_ADDRESS_MEANING, ptr->meaning);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_postal_address_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_postal_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_postal_address_new_lang(ptr, (iodef_postal_address_lang_t **) ret);

                case 1:
                        return iodef_postal_address_new_meaning(ptr, (iodef_postal_address_meaning_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_postal_address_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_postal_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->lang = 0;
                        return 0;

                case 1:
                        ptr->meaning = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_postal_address_destroy_internal(iodef_postal_address_t *ptr)
{
        libiodef_return_if_fail(ptr);


        /* free() should be done by the caller */
}

/**
 * iodef_postal_address_destroy:
 * @ptr: pointer to a #iodef_postal_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_postal_address_destroy(iodef_postal_address_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_postal_address_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_postal_address_get_lang:
 * @ptr: pointer to a #iodef_postal_address_t object.
 *
 * Get lang children of the #iodef_postal_address_t object.
 *
 * Returns: a pointer to a iodef_postal_address_lang_t object, or NULL if the children object is not set.
 */
iodef_postal_address_lang_t iodef_postal_address_get_lang(iodef_postal_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;
}

/**
 * iodef_postal_address_set_lang:
 * @ptr: pointer to a #iodef_postal_address_t object.
 * @lang: pointer to a #iodef_postal_address_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */

void iodef_postal_address_set_lang(iodef_postal_address_t *ptr, iodef_postal_address_lang_t lang)
{
        libiodef_return_if_fail(ptr);
        ptr->lang = lang;
}

/**
 * iodef_postal_address_new_lang:
 * @ptr: pointer to a #iodef_postal_address_t object.
 * @ret: pointer to an address where to store the created #iodef_postal_address_lang_t object.
 *
 * Create a new lang object, children of #iodef_postal_address_t.
 * If @ptr already contain a #iodef_postal_address_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_postal_address_new_lang(iodef_postal_address_t *ptr, iodef_postal_address_lang_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->lang;
        return 0;
}

/**
 * iodef_postal_address_get_meaning:
 * @ptr: pointer to a #iodef_postal_address_t object.
 *
 * Get meaning children of the #iodef_postal_address_t object.
 *
 * Returns: a pointer to a iodef_postal_address_meaning_t object, or NULL if the children object is not set.
 */
iodef_postal_address_meaning_t iodef_postal_address_get_meaning(iodef_postal_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;
}

/**
 * iodef_postal_address_set_meaning:
 * @ptr: pointer to a #iodef_postal_address_t object.
 * @meaning: pointer to a #iodef_postal_address_meaning_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodef_postal_address_set_meaning(iodef_postal_address_t *ptr, iodef_postal_address_meaning_t meaning)
{
        libiodef_return_if_fail(ptr);
        ptr->meaning = meaning;
}

/**
 * iodef_postal_address_new_meaning:
 * @ptr: pointer to a #iodef_postal_address_t object.
 * @ret: pointer to an address where to store the created #iodef_postal_address_meaning_t object.
 *
 * Create a new meaning object, children of #iodef_postal_address_t.
 * If @ptr already contain a #iodef_postal_address_meaning_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_postal_address_new_meaning(iodef_postal_address_t *ptr, iodef_postal_address_meaning_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->meaning;
        return 0;
}

/**
 * iodef_postal_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_postal_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_postal_address_copy(const iodef_postal_address_t *src, iodef_postal_address_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->lang = src->lang;

        dst->meaning = src->meaning;

        return 0;
}

/**
 * iodef_postal_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_postal_address_clone(iodef_postal_address_t *src, iodef_postal_address_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_postal_address_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_postal_address_copy(src, *dst);
}

/**
 * iodef_postal_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_postal_address_compare(const iodef_postal_address_t *obj1, const iodef_postal_address_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->lang != obj2->lang )
                return -1;

        if ( obj1->meaning != obj2->meaning )
                return -1;

        return ret;
}

/**
 * iodef_contact_new:
 * @ret: Pointer where to store the created #iodef_contact_t object.
 *
 * Create a new #iodef_contact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_contact_new(iodef_contact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_CONTACT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->telephone_list);


        libiodef_list_init(&(*ret)->registry_handle_list);


        libiodef_list_init(&(*ret)->contact_list);


        libiodef_list_init(&(*ret)->email_list);


        return 0;

}

/**
 * iodef_contact_ref:
 * @contact: pointer to a #iodef_contact_t object.
 *
 * Increase @contact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @contact.
 */
iodef_contact_t *iodef_contact_ref(iodef_contact_t *contact)
{
        libiodef_return_val_if_fail(contact, NULL);
        contact->refcount++;

        return contact;
}

int _iodef_contact_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_contact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->fax, TRUE);
                case 2:
                        *childptr = &ptr->description_list;
                        return 0;

                case 3:
                        *childptr = &ptr->telephone_list;
                        return 0;

                case 4:
                        *childptr = &ptr->registry_handle_list;
                        return 0;

                case 5:
                        *childptr = &ptr->contact_list;
                        return 0;

                case 6:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->contact_name, TRUE);
                case 7:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->timezone, TRUE);
                case 8:
                        *childptr = ptr->postal_address;
                        return 0;

                case 9:
                        *childptr = &ptr->email_list;
                        return 0;

                case 10:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_CONTACT_TYPE, ptr->type);

                case 11:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_CONTACT_ROLE, ptr->role);

                case 12:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_type, TRUE);
                case 13:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_role, TRUE);
                case 14:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_CONTACT_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_contact_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_contact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 1:
                        return iodef_contact_new_fax(ptr, (libiodef_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_telephone(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->telephone_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->telephone_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_telephone(ptr, (libiodef_string_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_registry_handle(ptr, (iodef_registry_handle_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_registry_handle(ptr, (iodef_registry_handle_t **) ret, n);
                }

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_contact(ptr, (iodef_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_contact(ptr, (iodef_contact_t **) ret, n);
                }

                case 6:
                        return iodef_contact_new_contact_name(ptr, (libiodef_string_t **) ret);

                case 7:
                        return iodef_contact_new_timezone(ptr, (libiodef_string_t **) ret);

                case 8:
                        return iodef_contact_new_postal_address(ptr, (iodef_postal_address_t **) ret);

                case 9: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_contact_new_email(ptr, (iodef_email_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->email_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->email_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_contact_new_email(ptr, (iodef_email_t **) ret, n);
                }

                case 10:
                        return iodef_contact_new_type(ptr, (iodef_contact_type_t **) ret);

                case 11:
                        return iodef_contact_new_role(ptr, (iodef_contact_role_t **) ret);

                case 12:
                        return iodef_contact_new_ext_type(ptr, (libiodef_string_t **) ret);

                case 13:
                        return iodef_contact_new_ext_role(ptr, (libiodef_string_t **) ret);

                case 14:
                        return iodef_contact_new_restriction(ptr, (iodef_contact_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_contact_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_contact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        if ( ptr->fax ) {
                                libiodef_string_destroy(ptr->fax);
                                ptr->fax = NULL;
                        }

                        return 0;

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->telephone_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->telephone_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_registry_handle_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_registry_handle_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 6:
                        if ( ptr->contact_name ) {
                                libiodef_string_destroy(ptr->contact_name);
                                ptr->contact_name = NULL;
                        }

                        return 0;

                case 7:
                        if ( ptr->timezone ) {
                                libiodef_string_destroy(ptr->timezone);
                                ptr->timezone = NULL;
                        }

                        return 0;

                case 8:
                        if ( ptr->postal_address ) {
                                iodef_postal_address_destroy(ptr->postal_address);
                                ptr->postal_address = NULL;
                        }

                        return 0;

                case 9: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->email_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_email_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->email_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_email_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 10:
                        ptr->type = 0;
                        return 0;

                case 11:
                        ptr->role = 0;
                        return 0;

                case 12:
                        if ( ptr->ext_type ) {
                                libiodef_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                case 13:
                        if ( ptr->ext_role ) {
                                libiodef_string_destroy(ptr->ext_role);
                                ptr->ext_role = NULL;
                        }

                        return 0;

                case 14:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_contact_destroy_internal(iodef_contact_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        if ( ptr->fax ) {
                libiodef_string_destroy(ptr->fax);
                ptr->fax = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->telephone_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_registry_handle_t *entry;

                libiodef_list_for_each_safe(&ptr->registry_handle_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_registry_handle_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry;

                libiodef_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_contact_destroy(entry);
                }
        }

        if ( ptr->contact_name ) {
                libiodef_string_destroy(ptr->contact_name);
                ptr->contact_name = NULL;
        }

        if ( ptr->timezone ) {
                libiodef_string_destroy(ptr->timezone);
                ptr->timezone = NULL;
        }

        if ( ptr->postal_address ) {
                iodef_postal_address_destroy(ptr->postal_address);
                ptr->postal_address = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_email_t *entry;

                libiodef_list_for_each_safe(&ptr->email_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_email_destroy(entry);
                }
        }

        if ( ptr->ext_type ) {
                libiodef_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }

        if ( ptr->ext_role ) {
                libiodef_string_destroy(ptr->ext_role);
                ptr->ext_role = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_contact_destroy:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_contact_destroy(iodef_contact_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_contact_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_contact_get_next_additional_data:
 * @contact: pointer to a #iodef_contact_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_contact_get_next_additional_data(iodef_contact_t *contact, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_additional_data:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_additional_data(iodef_contact_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_additional_data:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_additional_data(iodef_contact_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_fax:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get fax children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_contact_get_fax(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->fax;
}

/**
 * iodef_contact_set_fax:
 * @ptr: pointer to a #iodef_contact_t object.
 * @fax: pointer to a #libiodef_string_t object.
 *
 * Set @fax object as a children of @ptr.
 * if @ptr already contain an @fax object, then it is destroyed,
 * and updated to point to the provided @fax object.
 */

void iodef_contact_set_fax(iodef_contact_t *ptr, libiodef_string_t *fax)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->fax )
                libiodef_string_destroy(ptr->fax);

        ptr->fax = fax;
}

/**
 * iodef_contact_new_fax:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new fax object, children of #iodef_contact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_fax(iodef_contact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->fax ) {
                retval = libiodef_string_new(&ptr->fax);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->fax;
        return 0;
}

/**
 * iodef_contact_get_next_description:
 * @contact: pointer to a #iodef_contact_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_contact_get_next_description(iodef_contact_t *contact, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_description:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_description(iodef_contact_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_description:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_description(iodef_contact_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_next_telephone:
 * @contact: pointer to a #iodef_contact_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_contact_get_next_telephone(iodef_contact_t *contact, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->telephone_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_telephone:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_telephone(iodef_contact_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->telephone_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_telephone:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_telephone(iodef_contact_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->telephone_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_next_registry_handle:
 * @contact: pointer to a #iodef_contact_t object.
 * @registry_handle_cur: pointer to a #iodef_registry_handle_t object.
 *
 * Get the next #iodef_registry_handle_t object listed in @ptr.
 * When iterating over the iodef_registry_handle_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_registry_handle_t object.
 *
 * Returns: the next #iodef_registry_handle_t in the list.
 */
iodef_registry_handle_t *iodef_contact_get_next_registry_handle(iodef_contact_t *contact, iodef_registry_handle_t *registry_handle_cur)
{
        libiodef_list_t *tmp = (registry_handle_cur) ? &((libiodef_linked_object_t *) registry_handle_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->registry_handle_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_registry_handle:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #iodef_registry_handle_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_registry_handle_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_registry_handle(iodef_contact_t *ptr, iodef_registry_handle_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->registry_handle_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_registry_handle:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_registry_handle_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_registry_handle_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_registry_handle_t object. The created #iodef_registry_handle_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_registry_handle(iodef_contact_t *ptr, iodef_registry_handle_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_registry_handle_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->registry_handle_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_next_contact:
 * @contact: pointer to a #iodef_contact_t object.
 * @contact_cur: pointer to a #iodef_contact_t object.
 *
 * Get the next #iodef_contact_t object listed in @ptr.
 * When iterating over the iodef_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_contact_t object.
 *
 * Returns: the next #iodef_contact_t in the list.
 */
iodef_contact_t *iodef_contact_get_next_contact(iodef_contact_t *contact, iodef_contact_t *contact_cur)
{
        libiodef_list_t *tmp = (contact_cur) ? &((libiodef_linked_object_t *) contact_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->contact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_contact:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #iodef_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_contact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_contact(iodef_contact_t *ptr, iodef_contact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_contact:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_contact_t object. The created #iodef_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_contact(iodef_contact_t *ptr, iodef_contact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_contact_name:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get contact_name children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_contact_get_contact_name(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact_name;
}

/**
 * iodef_contact_set_contact_name:
 * @ptr: pointer to a #iodef_contact_t object.
 * @contact_name: pointer to a #libiodef_string_t object.
 *
 * Set @contact_name object as a children of @ptr.
 * if @ptr already contain an @contact_name object, then it is destroyed,
 * and updated to point to the provided @contact_name object.
 */

void iodef_contact_set_contact_name(iodef_contact_t *ptr, libiodef_string_t *contact_name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->contact_name )
                libiodef_string_destroy(ptr->contact_name);

        ptr->contact_name = contact_name;
}

/**
 * iodef_contact_new_contact_name:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new contact_name object, children of #iodef_contact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_contact_name(iodef_contact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->contact_name ) {
                retval = libiodef_string_new(&ptr->contact_name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->contact_name;
        return 0;
}

/**
 * iodef_contact_get_timezone:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get timezone children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_contact_get_timezone(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->timezone;
}

/**
 * iodef_contact_set_timezone:
 * @ptr: pointer to a #iodef_contact_t object.
 * @timezone: pointer to a #libiodef_string_t object.
 *
 * Set @timezone object as a children of @ptr.
 * if @ptr already contain an @timezone object, then it is destroyed,
 * and updated to point to the provided @timezone object.
 */

void iodef_contact_set_timezone(iodef_contact_t *ptr, libiodef_string_t *timezone)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->timezone )
                libiodef_string_destroy(ptr->timezone);

        ptr->timezone = timezone;
}

/**
 * iodef_contact_new_timezone:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new timezone object, children of #iodef_contact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_timezone(iodef_contact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->timezone ) {
                retval = libiodef_string_new(&ptr->timezone);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->timezone;
        return 0;
}

/**
 * iodef_contact_get_postal_address:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get postal_address children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a iodef_postal_address_t object, or NULL if the children object is not set.
 */
iodef_postal_address_t *iodef_contact_get_postal_address(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->postal_address;
}

/**
 * iodef_contact_set_postal_address:
 * @ptr: pointer to a #iodef_contact_t object.
 * @postal_address: pointer to a #iodef_postal_address_t object.
 *
 * Set @postal_address object as a children of @ptr.
 * if @ptr already contain an @postal_address object, then it is destroyed,
 * and updated to point to the provided @postal_address object.
 */

void iodef_contact_set_postal_address(iodef_contact_t *ptr, iodef_postal_address_t *postal_address)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->postal_address )
                iodef_postal_address_destroy(ptr->postal_address);

        ptr->postal_address = postal_address;
}

/**
 * iodef_contact_new_postal_address:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_postal_address_t object.
 *
 * Create a new postal_address object, children of #iodef_contact_t.
 * If @ptr already contain a #iodef_postal_address_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_postal_address(iodef_contact_t *ptr, iodef_postal_address_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->postal_address ) {
                retval = iodef_postal_address_new(&ptr->postal_address);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->postal_address;
        return 0;
}

/**
 * iodef_contact_get_next_email:
 * @contact: pointer to a #iodef_contact_t object.
 * @email_cur: pointer to a #iodef_email_t object.
 *
 * Get the next #iodef_email_t object listed in @ptr.
 * When iterating over the iodef_email_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_email_t object.
 *
 * Returns: the next #iodef_email_t in the list.
 */
iodef_email_t *iodef_contact_get_next_email(iodef_contact_t *contact, iodef_email_t *email_cur)
{
        libiodef_list_t *tmp = (email_cur) ? &((libiodef_linked_object_t *) email_cur)->_list : NULL;

        libiodef_return_val_if_fail(contact, NULL);

        libiodef_list_for_each_continue(&contact->email_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_contact_set_email:
 * @ptr: pointer to a #iodef_contact_t object.
 * @object: pointer to a #iodef_email_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_email_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_contact_set_email(iodef_contact_t *ptr, iodef_email_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->email_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_contact_new_email:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_email_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_email_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_email_t object. The created #iodef_email_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_email(iodef_contact_t *ptr, iodef_email_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_email_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->email_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_contact_get_type:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get type children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a iodef_contact_type_t object, or NULL if the children object is not set.
 */
iodef_contact_type_t iodef_contact_get_type(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;
}

/**
 * iodef_contact_set_type:
 * @ptr: pointer to a #iodef_contact_t object.
 * @type: pointer to a #iodef_contact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void iodef_contact_set_type(iodef_contact_t *ptr, iodef_contact_type_t type)
{
        libiodef_return_if_fail(ptr);
        ptr->type = type;
}

/**
 * iodef_contact_new_type:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_type_t object.
 *
 * Create a new type object, children of #iodef_contact_t.
 * If @ptr already contain a #iodef_contact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_type(iodef_contact_t *ptr, iodef_contact_type_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->type;
        return 0;
}

/**
 * iodef_contact_get_role:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get role children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a iodef_contact_role_t object, or NULL if the children object is not set.
 */
iodef_contact_role_t iodef_contact_get_role(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->role;
}

/**
 * iodef_contact_set_role:
 * @ptr: pointer to a #iodef_contact_t object.
 * @role: pointer to a #iodef_contact_role_t object.
 *
 * Set @role object as a children of @ptr.
 * if @ptr already contain an @role object, then it is destroyed,
 * and updated to point to the provided @role object.
 */

void iodef_contact_set_role(iodef_contact_t *ptr, iodef_contact_role_t role)
{
        libiodef_return_if_fail(ptr);
        ptr->role = role;
}

/**
 * iodef_contact_new_role:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_role_t object.
 *
 * Create a new role object, children of #iodef_contact_t.
 * If @ptr already contain a #iodef_contact_role_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_role(iodef_contact_t *ptr, iodef_contact_role_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->role;
        return 0;
}

/**
 * iodef_contact_get_ext_type:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get ext_type children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_contact_get_ext_type(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;
}

/**
 * iodef_contact_set_ext_type:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ext_type: pointer to a #libiodef_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodef_contact_set_ext_type(iodef_contact_t *ptr, libiodef_string_t *ext_type)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_type )
                libiodef_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}

/**
 * iodef_contact_new_ext_type:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_type object, children of #iodef_contact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_ext_type(iodef_contact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodef_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_type;
        return 0;
}

/**
 * iodef_contact_get_ext_role:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get ext_role children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_contact_get_ext_role(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_role;
}

/**
 * iodef_contact_set_ext_role:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ext_role: pointer to a #libiodef_string_t object.
 *
 * Set @ext_role object as a children of @ptr.
 * if @ptr already contain an @ext_role object, then it is destroyed,
 * and updated to point to the provided @ext_role object.
 */

void iodef_contact_set_ext_role(iodef_contact_t *ptr, libiodef_string_t *ext_role)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_role )
                libiodef_string_destroy(ptr->ext_role);

        ptr->ext_role = ext_role;
}

/**
 * iodef_contact_new_ext_role:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_role object, children of #iodef_contact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_ext_role(iodef_contact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_role ) {
                retval = libiodef_string_new(&ptr->ext_role);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_role;
        return 0;
}

/**
 * iodef_contact_get_restriction:
 * @ptr: pointer to a #iodef_contact_t object.
 *
 * Get restriction children of the #iodef_contact_t object.
 *
 * Returns: a pointer to a iodef_contact_restriction_t object, or NULL if the children object is not set.
 */
iodef_contact_restriction_t iodef_contact_get_restriction(iodef_contact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_contact_set_restriction:
 * @ptr: pointer to a #iodef_contact_t object.
 * @restriction: pointer to a #iodef_contact_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_contact_set_restriction(iodef_contact_t *ptr, iodef_contact_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_contact_new_restriction:
 * @ptr: pointer to a #iodef_contact_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_contact_t.
 * If @ptr already contain a #iodef_contact_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_contact_new_restriction(iodef_contact_t *ptr, iodef_contact_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_contact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_contact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_contact_copy(const iodef_contact_t *src, iodef_contact_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->fax ) {
                libiodef_string_destroy(dst->fax);
                dst->fax = NULL;
        }

        if ( src->fax ) {
                ret = libiodef_string_clone(src->fax, &dst->fax);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->telephone_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->telephone_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->telephone_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_registry_handle_t *entry, *new;

                libiodef_list_for_each_safe(&dst->registry_handle_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_registry_handle_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->registry_handle_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_registry_handle_clone(entry, &new);
                        libiodef_list_add_tail(&dst->registry_handle_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->contact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->contact_name ) {
                libiodef_string_destroy(dst->contact_name);
                dst->contact_name = NULL;
        }

        if ( src->contact_name ) {
                ret = libiodef_string_clone(src->contact_name, &dst->contact_name);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->timezone ) {
                libiodef_string_destroy(dst->timezone);
                dst->timezone = NULL;
        }

        if ( src->timezone ) {
                ret = libiodef_string_clone(src->timezone, &dst->timezone);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->postal_address ) {
                iodef_postal_address_destroy(dst->postal_address);
                dst->postal_address = NULL;
        }

        if ( src->postal_address ) {
                ret = iodef_postal_address_clone(src->postal_address, &dst->postal_address);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_email_t *entry, *new;

                libiodef_list_for_each_safe(&dst->email_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_email_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->email_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_email_clone(entry, &new);
                        libiodef_list_add_tail(&dst->email_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->type = src->type;

        dst->role = src->role;

        if ( dst->ext_type ) {
                libiodef_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodef_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->ext_role ) {
                libiodef_string_destroy(dst->ext_role);
                dst->ext_role = NULL;
        }

        if ( src->ext_role ) {
                ret = libiodef_string_clone(src->ext_role, &dst->ext_role);
                if ( ret < 0 )
                        return ret;
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_contact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_contact_clone(iodef_contact_t *src, iodef_contact_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_contact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_contact_copy(src, *dst);
}

/**
 * iodef_contact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_contact_compare(const iodef_contact_t *obj1, const iodef_contact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = libiodef_string_compare(obj1->fax, obj2->fax);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->telephone_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->telephone_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_registry_handle_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->registry_handle_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->registry_handle_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_registry_handle_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_contact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->contact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = libiodef_string_compare(obj1->contact_name, obj2->contact_name);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->timezone, obj2->timezone);
        if ( ret != 0 )
                return ret;

        ret = iodef_postal_address_compare(obj1->postal_address, obj2->postal_address);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_email_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->email_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->email_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_email_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->type != obj2->type )
                return -1;

        if ( obj1->role != obj2->role )
                return -1;

        ret = libiodef_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->ext_role, obj2->ext_role);
        if ( ret != 0 )
                return ret;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_incident_id_new:
 * @ret: Pointer where to store the created #iodef_incident_id_t object.
 *
 * Create a new #iodef_incident_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_id_new(iodef_incident_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_INCIDENT_ID;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
                int retval = libiodef_string_new(&(*ret)->name);

                if ( retval < 0 ) {
                        iodef_incident_id_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_incident_id_ref:
 * @incident_id: pointer to a #iodef_incident_id_t object.
 *
 * Increase @incident_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @incident_id.
 */
iodef_incident_id_t *iodef_incident_id_ref(iodef_incident_id_t *incident_id)
{
        libiodef_return_val_if_fail(incident_id, NULL);
        incident_id->refcount++;

        return incident_id;
}

int _iodef_incident_id_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_incident_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->instance, TRUE);
                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->name, TRUE);
                case 2:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_INCIDENT_ID_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_incident_id_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_incident_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_incident_id_new_instance(ptr, (libiodef_string_t **) ret);

                case 1:
                        return iodef_incident_id_new_name(ptr, (libiodef_string_t **) ret);

                case 2:
                        return iodef_incident_id_new_restriction(ptr, (iodef_incident_id_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_incident_id_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_incident_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->instance ) {
                                libiodef_string_destroy(ptr->instance);
                                ptr->instance = NULL;
                        }

                        return 0;

                case 1:
                        if ( ptr->name ) {
                                libiodef_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 2:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_incident_id_destroy_internal(iodef_incident_id_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->instance ) {
                libiodef_string_destroy(ptr->instance);
                ptr->instance = NULL;
        }

        if ( ptr->name ) {
                libiodef_string_destroy(ptr->name);
                ptr->name = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_incident_id_destroy:
 * @ptr: pointer to a #iodef_incident_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_incident_id_destroy(iodef_incident_id_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_incident_id_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_incident_id_get_instance:
 * @ptr: pointer to a #iodef_incident_id_t object.
 *
 * Get instance children of the #iodef_incident_id_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_incident_id_get_instance(iodef_incident_id_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->instance;
}

/**
 * iodef_incident_id_set_instance:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @instance: pointer to a #libiodef_string_t object.
 *
 * Set @instance object as a children of @ptr.
 * if @ptr already contain an @instance object, then it is destroyed,
 * and updated to point to the provided @instance object.
 */

void iodef_incident_id_set_instance(iodef_incident_id_t *ptr, libiodef_string_t *instance)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->instance )
                libiodef_string_destroy(ptr->instance);

        ptr->instance = instance;
}

/**
 * iodef_incident_id_new_instance:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new instance object, children of #iodef_incident_id_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_id_new_instance(iodef_incident_id_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->instance ) {
                retval = libiodef_string_new(&ptr->instance);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->instance;
        return 0;
}

/**
 * iodef_incident_id_get_name:
 * @ptr: pointer to a #iodef_incident_id_t object.
 *
 * Get name children of the #iodef_incident_id_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_incident_id_get_name(iodef_incident_id_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;
}

/**
 * iodef_incident_id_set_name:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @name: pointer to a #libiodef_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodef_incident_id_set_name(iodef_incident_id_t *ptr, libiodef_string_t *name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->name )
                libiodef_string_destroy(ptr->name);

        ptr->name = name;
}

/**
 * iodef_incident_id_new_name:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new name object, children of #iodef_incident_id_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_id_new_name(iodef_incident_id_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodef_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->name;
        return 0;
}

/**
 * iodef_incident_id_get_restriction:
 * @ptr: pointer to a #iodef_incident_id_t object.
 *
 * Get restriction children of the #iodef_incident_id_t object.
 *
 * Returns: a pointer to a iodef_incident_id_restriction_t object, or NULL if the children object is not set.
 */
iodef_incident_id_restriction_t iodef_incident_id_get_restriction(iodef_incident_id_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_incident_id_set_restriction:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @restriction: pointer to a #iodef_incident_id_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_incident_id_set_restriction(iodef_incident_id_t *ptr, iodef_incident_id_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_incident_id_new_restriction:
 * @ptr: pointer to a #iodef_incident_id_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_id_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_incident_id_t.
 * If @ptr already contain a #iodef_incident_id_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_id_new_restriction(iodef_incident_id_t *ptr, iodef_incident_id_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_incident_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_incident_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_id_copy(const iodef_incident_id_t *src, iodef_incident_id_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->instance ) {
                libiodef_string_destroy(dst->instance);
                dst->instance = NULL;
        }

        if ( src->instance ) {
                ret = libiodef_string_clone(src->instance, &dst->instance);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->name ) {
                ret = libiodef_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_incident_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_id_clone(iodef_incident_id_t *src, iodef_incident_id_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_incident_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_incident_id_copy(src, *dst);
}

/**
 * iodef_incident_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_incident_id_compare(const iodef_incident_id_t *obj1, const iodef_incident_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = libiodef_string_compare(obj1->instance, obj2->instance);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_alternative_id_new:
 * @ret: Pointer where to store the created #iodef_alternative_id_t object.
 *
 * Create a new #iodef_alternative_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_alternative_id_new(iodef_alternative_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_ALTERNATIVE_ID;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->incident_id_list);


        return 0;

}

/**
 * iodef_alternative_id_ref:
 * @alternative_id: pointer to a #iodef_alternative_id_t object.
 *
 * Increase @alternative_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @alternative_id.
 */
iodef_alternative_id_t *iodef_alternative_id_ref(iodef_alternative_id_t *alternative_id)
{
        libiodef_return_val_if_fail(alternative_id, NULL);
        alternative_id->refcount++;

        return alternative_id;
}

int _iodef_alternative_id_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_alternative_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->incident_id_list;
                        return 0;

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ALTERNATIVE_ID_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_alternative_id_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_alternative_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_alternative_id_new_incident_id(ptr, (iodef_incident_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_alternative_id_new_incident_id(ptr, (iodef_incident_id_t **) ret, n);
                }

                case 1:
                        return iodef_alternative_id_new_restriction(ptr, (iodef_alternative_id_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_alternative_id_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_alternative_id_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_id_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_id_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_alternative_id_destroy_internal(iodef_alternative_id_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_id_t *entry;

                libiodef_list_for_each_safe(&ptr->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_incident_id_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_alternative_id_destroy:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_alternative_id_destroy(iodef_alternative_id_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_alternative_id_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_alternative_id_get_next_incident_id:
 * @alternative_id: pointer to a #iodef_alternative_id_t object.
 * @incident_id_cur: pointer to a #iodef_incident_id_t object.
 *
 * Get the next #iodef_incident_id_t object listed in @ptr.
 * When iterating over the iodef_incident_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_incident_id_t object.
 *
 * Returns: the next #iodef_incident_id_t in the list.
 */
iodef_incident_id_t *iodef_alternative_id_get_next_incident_id(iodef_alternative_id_t *alternative_id, iodef_incident_id_t *incident_id_cur)
{
        libiodef_list_t *tmp = (incident_id_cur) ? &((libiodef_linked_object_t *) incident_id_cur)->_list : NULL;

        libiodef_return_val_if_fail(alternative_id, NULL);

        libiodef_list_for_each_continue(&alternative_id->incident_id_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_alternative_id_set_incident_id:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 * @object: pointer to a #iodef_incident_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_incident_id_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_alternative_id_set_incident_id(iodef_alternative_id_t *ptr, iodef_incident_id_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_id_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_alternative_id_new_incident_id:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_id_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_incident_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_incident_id_t object. The created #iodef_incident_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_alternative_id_new_incident_id(iodef_alternative_id_t *ptr, iodef_incident_id_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_incident_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_id_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_alternative_id_get_restriction:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 *
 * Get restriction children of the #iodef_alternative_id_t object.
 *
 * Returns: a pointer to a iodef_alternative_id_restriction_t object, or NULL if the children object is not set.
 */
iodef_alternative_id_restriction_t iodef_alternative_id_get_restriction(iodef_alternative_id_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_alternative_id_set_restriction:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 * @restriction: pointer to a #iodef_alternative_id_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_alternative_id_set_restriction(iodef_alternative_id_t *ptr, iodef_alternative_id_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_alternative_id_new_restriction:
 * @ptr: pointer to a #iodef_alternative_id_t object.
 * @ret: pointer to an address where to store the created #iodef_alternative_id_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_alternative_id_t.
 * If @ptr already contain a #iodef_alternative_id_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_alternative_id_new_restriction(iodef_alternative_id_t *ptr, iodef_alternative_id_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_alternative_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_alternative_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_alternative_id_copy(const iodef_alternative_id_t *src, iodef_alternative_id_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_id_t *entry, *new;

                libiodef_list_for_each_safe(&dst->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_id_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_id_clone(entry, &new);
                        libiodef_list_add_tail(&dst->incident_id_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_alternative_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_alternative_id_clone(iodef_alternative_id_t *src, iodef_alternative_id_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_alternative_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_alternative_id_copy(src, *dst);
}

/**
 * iodef_alternative_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_alternative_id_compare(const iodef_alternative_id_t *obj1, const iodef_alternative_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_incident_id_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->incident_id_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->incident_id_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_incident_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_related_activity_new:
 * @ret: Pointer where to store the created #iodef_related_activity_t object.
 *
 * Create a new #iodef_related_activity_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_related_activity_new(iodef_related_activity_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_RELATED_ACTIVITY;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->url_list);


        libiodef_list_init(&(*ret)->incident_id_list);


        return 0;

}

/**
 * iodef_related_activity_ref:
 * @related_activity: pointer to a #iodef_related_activity_t object.
 *
 * Increase @related_activity reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @related_activity.
 */
iodef_related_activity_t *iodef_related_activity_ref(iodef_related_activity_t *related_activity)
{
        libiodef_return_val_if_fail(related_activity, NULL);
        related_activity->refcount++;

        return related_activity;
}

int _iodef_related_activity_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_related_activity_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->url_list;
                        return 0;

                case 1:
                        *childptr = &ptr->incident_id_list;
                        return 0;

                case 2:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RELATED_ACTIVITY_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_related_activity_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_related_activity_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_related_activity_new_url(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->url_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->url_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_related_activity_new_url(ptr, (libiodef_string_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_related_activity_new_incident_id(ptr, (iodef_incident_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_related_activity_new_incident_id(ptr, (iodef_incident_id_t **) ret, n);
                }

                case 2:
                        return iodef_related_activity_new_restriction(ptr, (iodef_related_activity_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_related_activity_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_related_activity_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->url_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->url_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_id_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_id_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_related_activity_destroy_internal(iodef_related_activity_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_id_t *entry;

                libiodef_list_for_each_safe(&ptr->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_incident_id_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_related_activity_destroy:
 * @ptr: pointer to a #iodef_related_activity_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_related_activity_destroy(iodef_related_activity_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_related_activity_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_related_activity_get_next_url:
 * @related_activity: pointer to a #iodef_related_activity_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_related_activity_get_next_url(iodef_related_activity_t *related_activity, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(related_activity, NULL);

        libiodef_list_for_each_continue(&related_activity->url_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_related_activity_set_url:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_related_activity_set_url(iodef_related_activity_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->url_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_related_activity_new_url:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_related_activity_new_url(iodef_related_activity_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->url_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_related_activity_get_next_incident_id:
 * @related_activity: pointer to a #iodef_related_activity_t object.
 * @incident_id_cur: pointer to a #iodef_incident_id_t object.
 *
 * Get the next #iodef_incident_id_t object listed in @ptr.
 * When iterating over the iodef_incident_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_incident_id_t object.
 *
 * Returns: the next #iodef_incident_id_t in the list.
 */
iodef_incident_id_t *iodef_related_activity_get_next_incident_id(iodef_related_activity_t *related_activity, iodef_incident_id_t *incident_id_cur)
{
        libiodef_list_t *tmp = (incident_id_cur) ? &((libiodef_linked_object_t *) incident_id_cur)->_list : NULL;

        libiodef_return_val_if_fail(related_activity, NULL);

        libiodef_list_for_each_continue(&related_activity->incident_id_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_related_activity_set_incident_id:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @object: pointer to a #iodef_incident_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_incident_id_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_related_activity_set_incident_id(iodef_related_activity_t *ptr, iodef_incident_id_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_id_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_related_activity_new_incident_id:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_id_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_incident_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_incident_id_t object. The created #iodef_incident_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_related_activity_new_incident_id(iodef_related_activity_t *ptr, iodef_incident_id_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_incident_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_id_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_related_activity_get_restriction:
 * @ptr: pointer to a #iodef_related_activity_t object.
 *
 * Get restriction children of the #iodef_related_activity_t object.
 *
 * Returns: a pointer to a iodef_related_activity_restriction_t object, or NULL if the children object is not set.
 */
iodef_related_activity_restriction_t iodef_related_activity_get_restriction(iodef_related_activity_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_related_activity_set_restriction:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @restriction: pointer to a #iodef_related_activity_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_related_activity_set_restriction(iodef_related_activity_t *ptr, iodef_related_activity_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_related_activity_new_restriction:
 * @ptr: pointer to a #iodef_related_activity_t object.
 * @ret: pointer to an address where to store the created #iodef_related_activity_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_related_activity_t.
 * If @ptr already contain a #iodef_related_activity_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_related_activity_new_restriction(iodef_related_activity_t *ptr, iodef_related_activity_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_related_activity_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_related_activity_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_related_activity_copy(const iodef_related_activity_t *src, iodef_related_activity_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->url_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_id_t *entry, *new;

                libiodef_list_for_each_safe(&dst->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_id_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->incident_id_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_id_clone(entry, &new);
                        libiodef_list_add_tail(&dst->incident_id_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_related_activity_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_related_activity_clone(iodef_related_activity_t *src, iodef_related_activity_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_related_activity_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_related_activity_copy(src, *dst);
}

/**
 * iodef_related_activity_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_related_activity_compare(const iodef_related_activity_t *obj1, const iodef_related_activity_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->url_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->url_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_incident_id_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->incident_id_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->incident_id_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_incident_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_history_item_new:
 * @ret: Pointer where to store the created #iodef_history_item_t object.
 *
 * Create a new #iodef_history_item_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_item_new(iodef_history_item_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_HISTORY_ITEM;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        {
                int retval = iodef_time_new(&(*ret)->date_time);

                if ( retval < 0 ) {
                        iodef_history_item_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_history_item_ref:
 * @history_item: pointer to a #iodef_history_item_t object.
 *
 * Increase @history_item reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @history_item.
 */
iodef_history_item_t *iodef_history_item_ref(iodef_history_item_t *history_item)
{
        libiodef_return_val_if_fail(history_item, NULL);
        history_item->refcount++;

        return history_item;
}

int _iodef_history_item_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_history_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 1:
                        *childptr = ptr->incident_id;
                        return 0;

                case 2:
                        *childptr = &ptr->description_list;
                        return 0;

                case 3:
                        *childptr = ptr->contact;
                        return 0;

                case 4:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->date_time, TRUE);
                case 5:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_HISTORY_ITEM_ACTION, ptr->action);

                case 6:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_HISTORY_ITEM_RESTRICTION, ptr->restriction);

                case 7:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_action, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_history_item_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_history_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_history_item_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_history_item_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 1:
                        return iodef_history_item_new_incident_id(ptr, (iodef_incident_id_t **) ret);

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_history_item_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_history_item_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 3:
                        return iodef_history_item_new_contact(ptr, (iodef_contact_t **) ret);

                case 4:
                        return iodef_history_item_new_date_time(ptr, (iodef_time_t **) ret);

                case 5:
                        return iodef_history_item_new_action(ptr, (iodef_history_item_action_t **) ret);

                case 6:
                        return iodef_history_item_new_restriction(ptr, (iodef_history_item_restriction_t **) ret);

                case 7:
                        return iodef_history_item_new_ext_action(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_history_item_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_history_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        if ( ptr->incident_id ) {
                                iodef_incident_id_destroy(ptr->incident_id);
                                ptr->incident_id = NULL;
                        }

                        return 0;

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3:
                        if ( ptr->contact ) {
                                iodef_contact_destroy(ptr->contact);
                                ptr->contact = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->date_time ) {
                                iodef_time_destroy(ptr->date_time);
                                ptr->date_time = NULL;
                        }

                        return 0;

                case 5:
                        ptr->action = 0;
                        return 0;

                case 6:
                        ptr->restriction = 0;
                        return 0;

                case 7:
                        if ( ptr->ext_action ) {
                                libiodef_string_destroy(ptr->ext_action);
                                ptr->ext_action = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_history_item_destroy_internal(iodef_history_item_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        if ( ptr->incident_id ) {
                iodef_incident_id_destroy(ptr->incident_id);
                ptr->incident_id = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        if ( ptr->contact ) {
                iodef_contact_destroy(ptr->contact);
                ptr->contact = NULL;
        }

        if ( ptr->date_time ) {
                iodef_time_destroy(ptr->date_time);
                ptr->date_time = NULL;
        }

        if ( ptr->ext_action ) {
                libiodef_string_destroy(ptr->ext_action);
                ptr->ext_action = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_history_item_destroy:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_history_item_destroy(iodef_history_item_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_history_item_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_history_item_get_next_additional_data:
 * @history_item: pointer to a #iodef_history_item_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_history_item_get_next_additional_data(iodef_history_item_t *history_item, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(history_item, NULL);

        libiodef_list_for_each_continue(&history_item->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_history_item_set_additional_data:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_history_item_set_additional_data(iodef_history_item_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_history_item_new_additional_data:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_additional_data(iodef_history_item_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_history_item_get_incident_id:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get incident_id children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a iodef_incident_id_t object, or NULL if the children object is not set.
 */
iodef_incident_id_t *iodef_history_item_get_incident_id(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->incident_id;
}

/**
 * iodef_history_item_set_incident_id:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @incident_id: pointer to a #iodef_incident_id_t object.
 *
 * Set @incident_id object as a children of @ptr.
 * if @ptr already contain an @incident_id object, then it is destroyed,
 * and updated to point to the provided @incident_id object.
 */

void iodef_history_item_set_incident_id(iodef_history_item_t *ptr, iodef_incident_id_t *incident_id)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->incident_id )
                iodef_incident_id_destroy(ptr->incident_id);

        ptr->incident_id = incident_id;
}

/**
 * iodef_history_item_new_incident_id:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_id_t object.
 *
 * Create a new incident_id object, children of #iodef_history_item_t.
 * If @ptr already contain a #iodef_incident_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_incident_id(iodef_history_item_t *ptr, iodef_incident_id_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->incident_id ) {
                retval = iodef_incident_id_new(&ptr->incident_id);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->incident_id;
        return 0;
}

/**
 * iodef_history_item_get_next_description:
 * @history_item: pointer to a #iodef_history_item_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_history_item_get_next_description(iodef_history_item_t *history_item, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(history_item, NULL);

        libiodef_list_for_each_continue(&history_item->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_history_item_set_description:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_history_item_set_description(iodef_history_item_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_history_item_new_description:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_description(iodef_history_item_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_history_item_get_contact:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get contact children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a iodef_contact_t object, or NULL if the children object is not set.
 */
iodef_contact_t *iodef_history_item_get_contact(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact;
}

/**
 * iodef_history_item_set_contact:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @contact: pointer to a #iodef_contact_t object.
 *
 * Set @contact object as a children of @ptr.
 * if @ptr already contain an @contact object, then it is destroyed,
 * and updated to point to the provided @contact object.
 */

void iodef_history_item_set_contact(iodef_history_item_t *ptr, iodef_contact_t *contact)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->contact )
                iodef_contact_destroy(ptr->contact);

        ptr->contact = contact;
}

/**
 * iodef_history_item_new_contact:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_t object.
 *
 * Create a new contact object, children of #iodef_history_item_t.
 * If @ptr already contain a #iodef_contact_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_contact(iodef_history_item_t *ptr, iodef_contact_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->contact ) {
                retval = iodef_contact_new(&ptr->contact);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->contact;
        return 0;
}

/**
 * iodef_history_item_get_date_time:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get date_time children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_history_item_get_date_time(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_time;
}

/**
 * iodef_history_item_set_date_time:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @date_time: pointer to a #iodef_time_t object.
 *
 * Set @date_time object as a children of @ptr.
 * if @ptr already contain an @date_time object, then it is destroyed,
 * and updated to point to the provided @date_time object.
 */

void iodef_history_item_set_date_time(iodef_history_item_t *ptr, iodef_time_t *date_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->date_time )
                iodef_time_destroy(ptr->date_time);

        ptr->date_time = date_time;
}

/**
 * iodef_history_item_new_date_time:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new date_time object, children of #iodef_history_item_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_date_time(iodef_history_item_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->date_time ) {
                retval = iodef_time_new(&ptr->date_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->date_time;
        return 0;
}

/**
 * iodef_history_item_get_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get action children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a iodef_history_item_action_t object, or NULL if the children object is not set.
 */
iodef_history_item_action_t iodef_history_item_get_action(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->action;
}

/**
 * iodef_history_item_set_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @action: pointer to a #iodef_history_item_action_t object.
 *
 * Set @action object as a children of @ptr.
 * if @ptr already contain an @action object, then it is destroyed,
 * and updated to point to the provided @action object.
 */

void iodef_history_item_set_action(iodef_history_item_t *ptr, iodef_history_item_action_t action)
{
        libiodef_return_if_fail(ptr);
        ptr->action = action;
}

/**
 * iodef_history_item_new_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_history_item_action_t object.
 *
 * Create a new action object, children of #iodef_history_item_t.
 * If @ptr already contain a #iodef_history_item_action_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_action(iodef_history_item_t *ptr, iodef_history_item_action_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->action;
        return 0;
}

/**
 * iodef_history_item_get_restriction:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get restriction children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a iodef_history_item_restriction_t object, or NULL if the children object is not set.
 */
iodef_history_item_restriction_t iodef_history_item_get_restriction(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_history_item_set_restriction:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @restriction: pointer to a #iodef_history_item_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_history_item_set_restriction(iodef_history_item_t *ptr, iodef_history_item_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_history_item_new_restriction:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #iodef_history_item_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_history_item_t.
 * If @ptr already contain a #iodef_history_item_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_restriction(iodef_history_item_t *ptr, iodef_history_item_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_history_item_get_ext_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 *
 * Get ext_action children of the #iodef_history_item_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_history_item_get_ext_action(iodef_history_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_action;
}

/**
 * iodef_history_item_set_ext_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ext_action: pointer to a #libiodef_string_t object.
 *
 * Set @ext_action object as a children of @ptr.
 * if @ptr already contain an @ext_action object, then it is destroyed,
 * and updated to point to the provided @ext_action object.
 */

void iodef_history_item_set_ext_action(iodef_history_item_t *ptr, libiodef_string_t *ext_action)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_action )
                libiodef_string_destroy(ptr->ext_action);

        ptr->ext_action = ext_action;
}

/**
 * iodef_history_item_new_ext_action:
 * @ptr: pointer to a #iodef_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_action object, children of #iodef_history_item_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_item_new_ext_action(iodef_history_item_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_action ) {
                retval = libiodef_string_new(&ptr->ext_action);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_action;
        return 0;
}

/**
 * iodef_history_item_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_history_item_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_item_copy(const iodef_history_item_t *src, iodef_history_item_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->incident_id ) {
                iodef_incident_id_destroy(dst->incident_id);
                dst->incident_id = NULL;
        }

        if ( src->incident_id ) {
                ret = iodef_incident_id_clone(src->incident_id, &dst->incident_id);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->contact ) {
                iodef_contact_destroy(dst->contact);
                dst->contact = NULL;
        }

        if ( src->contact ) {
                ret = iodef_contact_clone(src->contact, &dst->contact);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->date_time ) {
                ret = iodef_time_copy(src->date_time, dst->date_time);
                if ( ret < 0 )
                        return ret;
        }

        dst->action = src->action;

        dst->restriction = src->restriction;

        if ( dst->ext_action ) {
                libiodef_string_destroy(dst->ext_action);
                dst->ext_action = NULL;
        }

        if ( src->ext_action ) {
                ret = libiodef_string_clone(src->ext_action, &dst->ext_action);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_history_item_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_item_clone(iodef_history_item_t *src, iodef_history_item_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_history_item_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_history_item_copy(src, *dst);
}

/**
 * iodef_history_item_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_history_item_compare(const iodef_history_item_t *obj1, const iodef_history_item_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_incident_id_compare(obj1->incident_id, obj2->incident_id);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_contact_compare(obj1->contact, obj2->contact);
        if ( ret != 0 )
                return ret;

        ret = iodef_time_compare(obj1->date_time, obj2->date_time);
        if ( ret != 0 )
                return ret;

        if ( obj1->action != obj2->action )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        ret = libiodef_string_compare(obj1->ext_action, obj2->ext_action);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_history_new:
 * @ret: Pointer where to store the created #iodef_history_t object.
 *
 * Create a new #iodef_history_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_new(iodef_history_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_HISTORY;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->history_item_list);


        return 0;

}

/**
 * iodef_history_ref:
 * @history: pointer to a #iodef_history_t object.
 *
 * Increase @history reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @history.
 */
iodef_history_t *iodef_history_ref(iodef_history_t *history)
{
        libiodef_return_val_if_fail(history, NULL);
        history->refcount++;

        return history;
}

int _iodef_history_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_history_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->history_item_list;
                        return 0;

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_HISTORY_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_history_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_history_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_history_new_history_item(ptr, (iodef_history_item_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->history_item_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->history_item_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_history_new_history_item(ptr, (iodef_history_item_t **) ret, n);
                }

                case 1:
                        return iodef_history_new_restriction(ptr, (iodef_history_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_history_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_history_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->history_item_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_history_item_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->history_item_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_history_item_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_history_destroy_internal(iodef_history_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                iodef_history_item_t *entry;

                libiodef_list_for_each_safe(&ptr->history_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_history_item_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_history_destroy:
 * @ptr: pointer to a #iodef_history_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_history_destroy(iodef_history_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_history_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_history_get_next_history_item:
 * @history: pointer to a #iodef_history_t object.
 * @history_item_cur: pointer to a #iodef_history_item_t object.
 *
 * Get the next #iodef_history_item_t object listed in @ptr.
 * When iterating over the iodef_history_item_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_history_item_t object.
 *
 * Returns: the next #iodef_history_item_t in the list.
 */
iodef_history_item_t *iodef_history_get_next_history_item(iodef_history_t *history, iodef_history_item_t *history_item_cur)
{
        libiodef_list_t *tmp = (history_item_cur) ? &((libiodef_linked_object_t *) history_item_cur)->_list : NULL;

        libiodef_return_val_if_fail(history, NULL);

        libiodef_list_for_each_continue(&history->history_item_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_history_set_history_item:
 * @ptr: pointer to a #iodef_history_t object.
 * @object: pointer to a #iodef_history_item_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_history_item_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_history_set_history_item(iodef_history_t *ptr, iodef_history_item_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->history_item_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_history_new_history_item:
 * @ptr: pointer to a #iodef_history_t object.
 * @ret: pointer to an address where to store the created #iodef_history_item_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_history_item_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_history_item_t object. The created #iodef_history_item_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_new_history_item(iodef_history_t *ptr, iodef_history_item_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_history_item_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->history_item_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_history_get_restriction:
 * @ptr: pointer to a #iodef_history_t object.
 *
 * Get restriction children of the #iodef_history_t object.
 *
 * Returns: a pointer to a iodef_history_restriction_t object, or NULL if the children object is not set.
 */
iodef_history_restriction_t iodef_history_get_restriction(iodef_history_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_history_set_restriction:
 * @ptr: pointer to a #iodef_history_t object.
 * @restriction: pointer to a #iodef_history_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_history_set_restriction(iodef_history_t *ptr, iodef_history_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_history_new_restriction:
 * @ptr: pointer to a #iodef_history_t object.
 * @ret: pointer to an address where to store the created #iodef_history_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_history_t.
 * If @ptr already contain a #iodef_history_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_history_new_restriction(iodef_history_t *ptr, iodef_history_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_history_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_history_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_copy(const iodef_history_t *src, iodef_history_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_history_item_t *entry, *new;

                libiodef_list_for_each_safe(&dst->history_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_history_item_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->history_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_history_item_clone(entry, &new);
                        libiodef_list_add_tail(&dst->history_item_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_history_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_history_clone(iodef_history_t *src, iodef_history_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_history_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_history_copy(src, *dst);
}

/**
 * iodef_history_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_history_compare(const iodef_history_t *obj1, const iodef_history_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_history_item_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->history_item_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->history_item_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_history_item_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_expectation_new:
 * @ret: Pointer where to store the created #iodef_expectation_t object.
 *
 * Create a new #iodef_expectation_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_expectation_new(iodef_expectation_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_EXPECTATION;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->description_list);


        return 0;

}

/**
 * iodef_expectation_ref:
 * @expectation: pointer to a #iodef_expectation_t object.
 *
 * Increase @expectation reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @expectation.
 */
iodef_expectation_t *iodef_expectation_ref(iodef_expectation_t *expectation)
{
        libiodef_return_val_if_fail(expectation, NULL);
        expectation->refcount++;

        return expectation;
}

int _iodef_expectation_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_expectation_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->end_time, TRUE);
                case 1:
                        *childptr = &ptr->description_list;
                        return 0;

                case 2:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->start_time, TRUE);
                case 3:
                        *childptr = ptr->contact;
                        return 0;

                case 4:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_EXPECTATION_ACTION, ptr->action);

                case 5:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_EXPECTATION_RESTRICTION, ptr->restriction);

                case 6:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_action, TRUE);
                case 7:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_EXPECTATION_SEVERITY, ptr->severity);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_expectation_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_expectation_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_expectation_new_end_time(ptr, (iodef_time_t **) ret);

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_expectation_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_expectation_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 2:
                        return iodef_expectation_new_start_time(ptr, (iodef_time_t **) ret);

                case 3:
                        return iodef_expectation_new_contact(ptr, (iodef_contact_t **) ret);

                case 4:
                        return iodef_expectation_new_action(ptr, (iodef_expectation_action_t **) ret);

                case 5:
                        return iodef_expectation_new_restriction(ptr, (iodef_expectation_restriction_t **) ret);

                case 6:
                        return iodef_expectation_new_ext_action(ptr, (libiodef_string_t **) ret);

                case 7:
                        return iodef_expectation_new_severity(ptr, (iodef_expectation_severity_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_expectation_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_expectation_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->end_time ) {
                                iodef_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        if ( ptr->start_time ) {
                                iodef_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->contact ) {
                                iodef_contact_destroy(ptr->contact);
                                ptr->contact = NULL;
                        }

                        return 0;

                case 4:
                        ptr->action = 0;
                        return 0;

                case 5:
                        ptr->restriction = 0;
                        return 0;

                case 6:
                        if ( ptr->ext_action ) {
                                libiodef_string_destroy(ptr->ext_action);
                                ptr->ext_action = NULL;
                        }

                        return 0;

                case 7:
                        ptr->severity = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_expectation_destroy_internal(iodef_expectation_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->end_time ) {
                iodef_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        if ( ptr->start_time ) {
                iodef_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }

        if ( ptr->contact ) {
                iodef_contact_destroy(ptr->contact);
                ptr->contact = NULL;
        }

        if ( ptr->ext_action ) {
                libiodef_string_destroy(ptr->ext_action);
                ptr->ext_action = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_expectation_destroy:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_expectation_destroy(iodef_expectation_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_expectation_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_expectation_get_end_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get end_time children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_expectation_get_end_time(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;
}

/**
 * iodef_expectation_set_end_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @end_time: pointer to a #iodef_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodef_expectation_set_end_time(iodef_expectation_t *ptr, iodef_time_t *end_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->end_time )
                iodef_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}

/**
 * iodef_expectation_new_end_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new end_time object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_end_time(iodef_expectation_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodef_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->end_time;
        return 0;
}

/**
 * iodef_expectation_get_next_description:
 * @expectation: pointer to a #iodef_expectation_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_expectation_get_next_description(iodef_expectation_t *expectation, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(expectation, NULL);

        libiodef_list_for_each_continue(&expectation->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_expectation_set_description:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_expectation_set_description(iodef_expectation_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_expectation_new_description:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_description(iodef_expectation_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_expectation_get_start_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get start_time children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_expectation_get_start_time(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;
}

/**
 * iodef_expectation_set_start_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @start_time: pointer to a #iodef_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodef_expectation_set_start_time(iodef_expectation_t *ptr, iodef_time_t *start_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->start_time )
                iodef_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}

/**
 * iodef_expectation_new_start_time:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new start_time object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_start_time(iodef_expectation_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodef_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->start_time;
        return 0;
}

/**
 * iodef_expectation_get_contact:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get contact children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_contact_t object, or NULL if the children object is not set.
 */
iodef_contact_t *iodef_expectation_get_contact(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact;
}

/**
 * iodef_expectation_set_contact:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @contact: pointer to a #iodef_contact_t object.
 *
 * Set @contact object as a children of @ptr.
 * if @ptr already contain an @contact object, then it is destroyed,
 * and updated to point to the provided @contact object.
 */

void iodef_expectation_set_contact(iodef_expectation_t *ptr, iodef_contact_t *contact)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->contact )
                iodef_contact_destroy(ptr->contact);

        ptr->contact = contact;
}

/**
 * iodef_expectation_new_contact:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_t object.
 *
 * Create a new contact object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_contact_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_contact(iodef_expectation_t *ptr, iodef_contact_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->contact ) {
                retval = iodef_contact_new(&ptr->contact);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->contact;
        return 0;
}

/**
 * iodef_expectation_get_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get action children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_expectation_action_t object, or NULL if the children object is not set.
 */
iodef_expectation_action_t iodef_expectation_get_action(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->action;
}

/**
 * iodef_expectation_set_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @action: pointer to a #iodef_expectation_action_t object.
 *
 * Set @action object as a children of @ptr.
 * if @ptr already contain an @action object, then it is destroyed,
 * and updated to point to the provided @action object.
 */

void iodef_expectation_set_action(iodef_expectation_t *ptr, iodef_expectation_action_t action)
{
        libiodef_return_if_fail(ptr);
        ptr->action = action;
}

/**
 * iodef_expectation_new_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_expectation_action_t object.
 *
 * Create a new action object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_expectation_action_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_action(iodef_expectation_t *ptr, iodef_expectation_action_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->action;
        return 0;
}

/**
 * iodef_expectation_get_restriction:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get restriction children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_expectation_restriction_t object, or NULL if the children object is not set.
 */
iodef_expectation_restriction_t iodef_expectation_get_restriction(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_expectation_set_restriction:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @restriction: pointer to a #iodef_expectation_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_expectation_set_restriction(iodef_expectation_t *ptr, iodef_expectation_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_expectation_new_restriction:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_expectation_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_expectation_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_restriction(iodef_expectation_t *ptr, iodef_expectation_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_expectation_get_ext_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get ext_action children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_expectation_get_ext_action(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_action;
}

/**
 * iodef_expectation_set_ext_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ext_action: pointer to a #libiodef_string_t object.
 *
 * Set @ext_action object as a children of @ptr.
 * if @ptr already contain an @ext_action object, then it is destroyed,
 * and updated to point to the provided @ext_action object.
 */

void iodef_expectation_set_ext_action(iodef_expectation_t *ptr, libiodef_string_t *ext_action)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_action )
                libiodef_string_destroy(ptr->ext_action);

        ptr->ext_action = ext_action;
}

/**
 * iodef_expectation_new_ext_action:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_action object, children of #iodef_expectation_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_ext_action(iodef_expectation_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_action ) {
                retval = libiodef_string_new(&ptr->ext_action);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_action;
        return 0;
}

/**
 * iodef_expectation_get_severity:
 * @ptr: pointer to a #iodef_expectation_t object.
 *
 * Get severity children of the #iodef_expectation_t object.
 *
 * Returns: a pointer to a iodef_expectation_severity_t object, or NULL if the children object is not set.
 */
iodef_expectation_severity_t iodef_expectation_get_severity(iodef_expectation_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity;
}

/**
 * iodef_expectation_set_severity:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @severity: pointer to a #iodef_expectation_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */

void iodef_expectation_set_severity(iodef_expectation_t *ptr, iodef_expectation_severity_t severity)
{
        libiodef_return_if_fail(ptr);
        ptr->severity = severity;
}

/**
 * iodef_expectation_new_severity:
 * @ptr: pointer to a #iodef_expectation_t object.
 * @ret: pointer to an address where to store the created #iodef_expectation_severity_t object.
 *
 * Create a new severity object, children of #iodef_expectation_t.
 * If @ptr already contain a #iodef_expectation_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_expectation_new_severity(iodef_expectation_t *ptr, iodef_expectation_severity_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->severity;
        return 0;
}

/**
 * iodef_expectation_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_expectation_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_expectation_copy(const iodef_expectation_t *src, iodef_expectation_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->end_time ) {
                iodef_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodef_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->start_time ) {
                iodef_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodef_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->contact ) {
                iodef_contact_destroy(dst->contact);
                dst->contact = NULL;
        }

        if ( src->contact ) {
                ret = iodef_contact_clone(src->contact, &dst->contact);
                if ( ret < 0 )
                        return ret;
        }

        dst->action = src->action;

        dst->restriction = src->restriction;

        if ( dst->ext_action ) {
                libiodef_string_destroy(dst->ext_action);
                dst->ext_action = NULL;
        }

        if ( src->ext_action ) {
                ret = libiodef_string_clone(src->ext_action, &dst->ext_action);
                if ( ret < 0 )
                        return ret;
        }

        dst->severity = src->severity;

        return 0;
}

/**
 * iodef_expectation_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_expectation_clone(iodef_expectation_t *src, iodef_expectation_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_expectation_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_expectation_copy(src, *dst);
}

/**
 * iodef_expectation_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_expectation_compare(const iodef_expectation_t *obj1, const iodef_expectation_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = iodef_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;

        ret = iodef_contact_compare(obj1->contact, obj2->contact);
        if ( ret != 0 )
                return ret;

        if ( obj1->action != obj2->action )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        ret = libiodef_string_compare(obj1->ext_action, obj2->ext_action);
        if ( ret != 0 )
                return ret;

        if ( obj1->severity != obj2->severity )
                return -1;

        return ret;
}

/**
 * iodef_record_pattern_new:
 * @ret: Pointer where to store the created #iodef_record_pattern_t object.
 *
 * Create a new #iodef_record_pattern_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_pattern_new(iodef_record_pattern_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_RECORD_PATTERN;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_record_pattern_ref:
 * @record_pattern: pointer to a #iodef_record_pattern_t object.
 *
 * Increase @record_pattern reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record_pattern.
 */
iodef_record_pattern_t *iodef_record_pattern_ref(iodef_record_pattern_t *record_pattern)
{
        libiodef_return_val_if_fail(record_pattern, NULL);
        record_pattern->refcount++;

        return record_pattern;
}

int _iodef_record_pattern_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_record_pattern_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_PATTERN_OFFSETUNIT, ptr->offsetunit);

                case 1:
                       return (ptr->instance_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->instance) : 0;

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_type, TRUE);
                case 3:
                       return (ptr->offset_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->offset) : 0;

                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_offsetunit, TRUE);
                case 5:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_PATTERN_TYPE, ptr->type);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_pattern_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_record_pattern_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_record_pattern_new_offsetunit(ptr, (iodef_record_pattern_offsetunit_t **) ret);

                case 1:
                        return iodef_record_pattern_new_instance(ptr, (uint32_t **) ret);

                case 2:
                        return iodef_record_pattern_new_ext_type(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_record_pattern_new_offset(ptr, (uint32_t **) ret);

                case 4:
                        return iodef_record_pattern_new_ext_offsetunit(ptr, (libiodef_string_t **) ret);

                case 5:
                        return iodef_record_pattern_new_type(ptr, (iodef_record_pattern_type_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_pattern_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_record_pattern_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->offsetunit = 0;
                        return 0;

                case 1:
                        ptr->instance_is_set = 0;
                        return 0;

                case 2:
                        if ( ptr->ext_type ) {
                                libiodef_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                case 3:
                        ptr->offset_is_set = 0;
                        return 0;

                case 4:
                        if ( ptr->ext_offsetunit ) {
                                libiodef_string_destroy(ptr->ext_offsetunit);
                                ptr->ext_offsetunit = NULL;
                        }

                        return 0;

                case 5:
                        ptr->type = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_record_pattern_destroy_internal(iodef_record_pattern_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_type ) {
                libiodef_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }

        if ( ptr->ext_offsetunit ) {
                libiodef_string_destroy(ptr->ext_offsetunit);
                ptr->ext_offsetunit = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_record_pattern_destroy:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_record_pattern_destroy(iodef_record_pattern_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_record_pattern_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_record_pattern_get_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get offsetunit children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a iodef_record_pattern_offsetunit_t object, or NULL if the children object is not set.
 */
iodef_record_pattern_offsetunit_t iodef_record_pattern_get_offsetunit(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offsetunit;
}

/**
 * iodef_record_pattern_set_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @offsetunit: pointer to a #iodef_record_pattern_offsetunit_t object.
 *
 * Set @offsetunit object as a children of @ptr.
 * if @ptr already contain an @offsetunit object, then it is destroyed,
 * and updated to point to the provided @offsetunit object.
 */

void iodef_record_pattern_set_offsetunit(iodef_record_pattern_t *ptr, iodef_record_pattern_offsetunit_t offsetunit)
{
        libiodef_return_if_fail(ptr);
        ptr->offsetunit = offsetunit;
}

/**
 * iodef_record_pattern_new_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #iodef_record_pattern_offsetunit_t object.
 *
 * Create a new offsetunit object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #iodef_record_pattern_offsetunit_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_offsetunit(iodef_record_pattern_t *ptr, iodef_record_pattern_offsetunit_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->offsetunit;
        return 0;
}

/**
 * iodef_record_pattern_get_instance:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get instance children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_record_pattern_get_instance(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->instance_is_set ? &ptr->instance : NULL;
}

/**
 * iodef_record_pattern_set_instance:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @instance: pointer to a #uint32_t object.
 *
 * Set @instance object as a children of @ptr.
 * if @ptr already contain an @instance object, then it is destroyed,
 * and updated to point to the provided @instance object.
 */

void iodef_record_pattern_set_instance(iodef_record_pattern_t *ptr, uint32_t instance)
{
        libiodef_return_if_fail(ptr);
        ptr->instance = instance;
        ptr->instance_is_set = 1;
}


void iodef_record_pattern_unset_instance(iodef_record_pattern_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->instance_is_set = 0;
}


/**
 * iodef_record_pattern_new_instance:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new instance object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_instance(iodef_record_pattern_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->instance_is_set = 1;

        *ret = &ptr->instance;
        return 0;
}

/**
 * iodef_record_pattern_get_ext_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get ext_type children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_record_pattern_get_ext_type(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;
}

/**
 * iodef_record_pattern_set_ext_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ext_type: pointer to a #libiodef_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodef_record_pattern_set_ext_type(iodef_record_pattern_t *ptr, libiodef_string_t *ext_type)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_type )
                libiodef_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}

/**
 * iodef_record_pattern_new_ext_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_type object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_ext_type(iodef_record_pattern_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodef_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_type;
        return 0;
}

/**
 * iodef_record_pattern_get_offset:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get offset children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_record_pattern_get_offset(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offset_is_set ? &ptr->offset : NULL;
}

/**
 * iodef_record_pattern_set_offset:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @offset: pointer to a #uint32_t object.
 *
 * Set @offset object as a children of @ptr.
 * if @ptr already contain an @offset object, then it is destroyed,
 * and updated to point to the provided @offset object.
 */

void iodef_record_pattern_set_offset(iodef_record_pattern_t *ptr, uint32_t offset)
{
        libiodef_return_if_fail(ptr);
        ptr->offset = offset;
        ptr->offset_is_set = 1;
}


void iodef_record_pattern_unset_offset(iodef_record_pattern_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->offset_is_set = 0;
}


/**
 * iodef_record_pattern_new_offset:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new offset object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_offset(iodef_record_pattern_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->offset_is_set = 1;

        *ret = &ptr->offset;
        return 0;
}

/**
 * iodef_record_pattern_get_ext_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get ext_offsetunit children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_record_pattern_get_ext_offsetunit(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_offsetunit;
}

/**
 * iodef_record_pattern_set_ext_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ext_offsetunit: pointer to a #libiodef_string_t object.
 *
 * Set @ext_offsetunit object as a children of @ptr.
 * if @ptr already contain an @ext_offsetunit object, then it is destroyed,
 * and updated to point to the provided @ext_offsetunit object.
 */

void iodef_record_pattern_set_ext_offsetunit(iodef_record_pattern_t *ptr, libiodef_string_t *ext_offsetunit)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_offsetunit )
                libiodef_string_destroy(ptr->ext_offsetunit);

        ptr->ext_offsetunit = ext_offsetunit;
}

/**
 * iodef_record_pattern_new_ext_offsetunit:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_offsetunit object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_ext_offsetunit(iodef_record_pattern_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_offsetunit ) {
                retval = libiodef_string_new(&ptr->ext_offsetunit);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_offsetunit;
        return 0;
}

/**
 * iodef_record_pattern_get_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 *
 * Get type children of the #iodef_record_pattern_t object.
 *
 * Returns: a pointer to a iodef_record_pattern_type_t object, or NULL if the children object is not set.
 */
iodef_record_pattern_type_t iodef_record_pattern_get_type(iodef_record_pattern_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;
}

/**
 * iodef_record_pattern_set_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @type: pointer to a #iodef_record_pattern_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void iodef_record_pattern_set_type(iodef_record_pattern_t *ptr, iodef_record_pattern_type_t type)
{
        libiodef_return_if_fail(ptr);
        ptr->type = type;
}

/**
 * iodef_record_pattern_new_type:
 * @ptr: pointer to a #iodef_record_pattern_t object.
 * @ret: pointer to an address where to store the created #iodef_record_pattern_type_t object.
 *
 * Create a new type object, children of #iodef_record_pattern_t.
 * If @ptr already contain a #iodef_record_pattern_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_pattern_new_type(iodef_record_pattern_t *ptr, iodef_record_pattern_type_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->type;
        return 0;
}

/**
 * iodef_record_pattern_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_record_pattern_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_pattern_copy(const iodef_record_pattern_t *src, iodef_record_pattern_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->offsetunit = src->offsetunit;

        dst->instance_is_set = src->instance_is_set;

        dst->instance = src->instance;

        if ( dst->ext_type ) {
                libiodef_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodef_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }

        dst->offset_is_set = src->offset_is_set;

        dst->offset = src->offset;

        if ( dst->ext_offsetunit ) {
                libiodef_string_destroy(dst->ext_offsetunit);
                dst->ext_offsetunit = NULL;
        }

        if ( src->ext_offsetunit ) {
                ret = libiodef_string_clone(src->ext_offsetunit, &dst->ext_offsetunit);
                if ( ret < 0 )
                        return ret;
        }

        dst->type = src->type;

        return 0;
}

/**
 * iodef_record_pattern_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_pattern_clone(iodef_record_pattern_t *src, iodef_record_pattern_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_record_pattern_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_record_pattern_copy(src, *dst);
}

/**
 * iodef_record_pattern_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_record_pattern_compare(const iodef_record_pattern_t *obj1, const iodef_record_pattern_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->offsetunit != obj2->offsetunit )
                return -1;

        if ( obj1->instance_is_set != obj2->instance_is_set )
                return -1;

        if ( obj1->instance_is_set && obj1->instance != obj2->instance )
                return -1;

        ret = libiodef_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        if ( obj1->offset_is_set != obj2->offset_is_set )
                return -1;

        if ( obj1->offset_is_set && obj1->offset != obj2->offset )
                return -1;

        ret = libiodef_string_compare(obj1->ext_offsetunit, obj2->ext_offsetunit);
        if ( ret != 0 )
                return ret;

        if ( obj1->type != obj2->type )
                return -1;

        return ret;
}

/**
 * iodef_record_item_new:
 * @ret: Pointer where to store the created #iodef_record_item_t object.
 *
 * Create a new #iodef_record_item_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_item_new(iodef_record_item_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_RECORD_ITEM;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_record_item_ref:
 * @record_item: pointer to a #iodef_record_item_t object.
 *
 * Increase @record_item reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record_item.
 */
iodef_record_item_t *iodef_record_item_ref(iodef_record_item_t *record_item)
{
        libiodef_return_val_if_fail(record_item, NULL);
        record_item->refcount++;

        return record_item;
}

int _iodef_record_item_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_record_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_ITEM_RESTRICTION, ptr->restriction);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_ITEM_DTYPE, ptr->dtype);

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->formatid, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->meaning, TRUE);
                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_dtype, TRUE);
                case 5:
                       return get_value_from_data((iodef_value_t **) childptr,  ptr->data, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_item_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_record_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_record_item_new_restriction(ptr, (iodef_record_item_restriction_t **) ret);

                case 1:
                        return iodef_record_item_new_dtype(ptr, (iodef_record_item_dtype_t **) ret);

                case 2:
                        return iodef_record_item_new_formatid(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_record_item_new_meaning(ptr, (libiodef_string_t **) ret);

                case 4:
                        return iodef_record_item_new_ext_dtype(ptr, (libiodef_string_t **) ret);

                case 5:
                        return iodef_record_item_new_data(ptr, (iodef_data_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_item_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_record_item_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->restriction = 0;
                        return 0;

                case 1:
                        ptr->dtype = 0;
                        return 0;

                case 2:
                        if ( ptr->formatid ) {
                                libiodef_string_destroy(ptr->formatid);
                                ptr->formatid = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->meaning ) {
                                libiodef_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->ext_dtype ) {
                                libiodef_string_destroy(ptr->ext_dtype);
                                ptr->ext_dtype = NULL;
                        }

                        return 0;

                case 5:
                        if ( ptr->data ) {
                                iodef_data_destroy(ptr->data);
                                ptr->data = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_record_item_destroy_internal(iodef_record_item_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->formatid ) {
                libiodef_string_destroy(ptr->formatid);
                ptr->formatid = NULL;
        }

        if ( ptr->meaning ) {
                libiodef_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }

        if ( ptr->ext_dtype ) {
                libiodef_string_destroy(ptr->ext_dtype);
                ptr->ext_dtype = NULL;
        }

        if ( ptr->data ) {
                iodef_data_destroy(ptr->data);
                ptr->data = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_record_item_destroy:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_record_item_destroy(iodef_record_item_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_record_item_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_record_item_get_restriction:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get restriction children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a iodef_record_item_restriction_t object, or NULL if the children object is not set.
 */
iodef_record_item_restriction_t iodef_record_item_get_restriction(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_record_item_set_restriction:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @restriction: pointer to a #iodef_record_item_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_record_item_set_restriction(iodef_record_item_t *ptr, iodef_record_item_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_record_item_new_restriction:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #iodef_record_item_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_record_item_t.
 * If @ptr already contain a #iodef_record_item_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_restriction(iodef_record_item_t *ptr, iodef_record_item_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_record_item_get_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get dtype children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a iodef_record_item_dtype_t object, or NULL if the children object is not set.
 */
iodef_record_item_dtype_t iodef_record_item_get_dtype(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->dtype;
}

/**
 * iodef_record_item_set_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @dtype: pointer to a #iodef_record_item_dtype_t object.
 *
 * Set @dtype object as a children of @ptr.
 * if @ptr already contain an @dtype object, then it is destroyed,
 * and updated to point to the provided @dtype object.
 */

void iodef_record_item_set_dtype(iodef_record_item_t *ptr, iodef_record_item_dtype_t dtype)
{
        libiodef_return_if_fail(ptr);
        ptr->dtype = dtype;
}

/**
 * iodef_record_item_new_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #iodef_record_item_dtype_t object.
 *
 * Create a new dtype object, children of #iodef_record_item_t.
 * If @ptr already contain a #iodef_record_item_dtype_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_dtype(iodef_record_item_t *ptr, iodef_record_item_dtype_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->dtype;
        return 0;
}

/**
 * iodef_record_item_get_formatid:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get formatid children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_record_item_get_formatid(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->formatid;
}

/**
 * iodef_record_item_set_formatid:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @formatid: pointer to a #libiodef_string_t object.
 *
 * Set @formatid object as a children of @ptr.
 * if @ptr already contain an @formatid object, then it is destroyed,
 * and updated to point to the provided @formatid object.
 */

void iodef_record_item_set_formatid(iodef_record_item_t *ptr, libiodef_string_t *formatid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->formatid )
                libiodef_string_destroy(ptr->formatid);

        ptr->formatid = formatid;
}

/**
 * iodef_record_item_new_formatid:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new formatid object, children of #iodef_record_item_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_formatid(iodef_record_item_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->formatid ) {
                retval = libiodef_string_new(&ptr->formatid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->formatid;
        return 0;
}

/**
 * iodef_record_item_get_meaning:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get meaning children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_record_item_get_meaning(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;
}

/**
 * iodef_record_item_set_meaning:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @meaning: pointer to a #libiodef_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodef_record_item_set_meaning(iodef_record_item_t *ptr, libiodef_string_t *meaning)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->meaning )
                libiodef_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}

/**
 * iodef_record_item_new_meaning:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new meaning object, children of #iodef_record_item_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_meaning(iodef_record_item_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libiodef_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->meaning;
        return 0;
}

/**
 * iodef_record_item_get_ext_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get ext_dtype children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_record_item_get_ext_dtype(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_dtype;
}

/**
 * iodef_record_item_set_ext_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ext_dtype: pointer to a #libiodef_string_t object.
 *
 * Set @ext_dtype object as a children of @ptr.
 * if @ptr already contain an @ext_dtype object, then it is destroyed,
 * and updated to point to the provided @ext_dtype object.
 */

void iodef_record_item_set_ext_dtype(iodef_record_item_t *ptr, libiodef_string_t *ext_dtype)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_dtype )
                libiodef_string_destroy(ptr->ext_dtype);

        ptr->ext_dtype = ext_dtype;
}

/**
 * iodef_record_item_new_ext_dtype:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_dtype object, children of #iodef_record_item_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_ext_dtype(iodef_record_item_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_dtype ) {
                retval = libiodef_string_new(&ptr->ext_dtype);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_dtype;
        return 0;
}

/**
 * iodef_record_item_get_data:
 * @ptr: pointer to a #iodef_record_item_t object.
 *
 * Get data children of the #iodef_record_item_t object.
 *
 * Returns: a pointer to a iodef_data_t object, or NULL if the children object is not set.
 */
iodef_data_t *iodef_record_item_get_data(iodef_record_item_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data;
}

/**
 * iodef_record_item_set_data:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @data: pointer to a #iodef_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void iodef_record_item_set_data(iodef_record_item_t *ptr, iodef_data_t *data)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->data )
                iodef_data_destroy(ptr->data);

        ptr->data = data;
}

/**
 * iodef_record_item_new_data:
 * @ptr: pointer to a #iodef_record_item_t object.
 * @ret: pointer to an address where to store the created #iodef_data_t object.
 *
 * Create a new data object, children of #iodef_record_item_t.
 * If @ptr already contain a #iodef_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_item_new_data(iodef_record_item_t *ptr, iodef_data_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->data ) {
                retval = iodef_data_new(&ptr->data);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->data;
        return 0;
}

/**
 * iodef_record_item_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_record_item_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_item_copy(const iodef_record_item_t *src, iodef_record_item_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->restriction = src->restriction;

        dst->dtype = src->dtype;

        if ( dst->formatid ) {
                libiodef_string_destroy(dst->formatid);
                dst->formatid = NULL;
        }

        if ( src->formatid ) {
                ret = libiodef_string_clone(src->formatid, &dst->formatid);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->meaning ) {
                libiodef_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libiodef_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->ext_dtype ) {
                libiodef_string_destroy(dst->ext_dtype);
                dst->ext_dtype = NULL;
        }

        if ( src->ext_dtype ) {
                ret = libiodef_string_clone(src->ext_dtype, &dst->ext_dtype);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->data ) {
                iodef_data_destroy(dst->data);
                dst->data = NULL;
        }

        if ( src->data ) {
                ret = iodef_data_clone(src->data, &dst->data);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_record_item_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_item_clone(iodef_record_item_t *src, iodef_record_item_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_record_item_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_record_item_copy(src, *dst);
}

/**
 * iodef_record_item_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_record_item_compare(const iodef_record_item_t *obj1, const iodef_record_item_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        if ( obj1->dtype != obj2->dtype )
                return -1;

        ret = libiodef_string_compare(obj1->formatid, obj2->formatid);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->ext_dtype, obj2->ext_dtype);
        if ( ret != 0 )
                return ret;

        ret = iodef_data_compare(obj1->data, obj2->data);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_application_new:
 * @ret: Pointer where to store the created #iodef_application_t object.
 *
 * Create a new #iodef_application_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_application_new(iodef_application_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_APPLICATION;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_application_ref:
 * @application: pointer to a #iodef_application_t object.
 *
 * Increase @application reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @application.
 */
iodef_application_t *iodef_application_ref(iodef_application_t *application)
{
        libiodef_return_val_if_fail(application, NULL);
        application->refcount++;

        return application;
}

int _iodef_application_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_application_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->url, TRUE);
                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->vendor, TRUE);
                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->name, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->family, TRUE);
                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->swid, TRUE);
                case 5:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->patch, TRUE);
                case 6:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->version, TRUE);
                case 7:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->configid, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_application_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_application_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_application_new_url(ptr, (libiodef_string_t **) ret);

                case 1:
                        return iodef_application_new_vendor(ptr, (libiodef_string_t **) ret);

                case 2:
                        return iodef_application_new_name(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_application_new_family(ptr, (libiodef_string_t **) ret);

                case 4:
                        return iodef_application_new_swid(ptr, (libiodef_string_t **) ret);

                case 5:
                        return iodef_application_new_patch(ptr, (libiodef_string_t **) ret);

                case 6:
                        return iodef_application_new_version(ptr, (libiodef_string_t **) ret);

                case 7:
                        return iodef_application_new_configid(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_application_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_application_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->url ) {
                                libiodef_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

                case 1:
                        if ( ptr->vendor ) {
                                libiodef_string_destroy(ptr->vendor);
                                ptr->vendor = NULL;
                        }

                        return 0;

                case 2:
                        if ( ptr->name ) {
                                libiodef_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->family ) {
                                libiodef_string_destroy(ptr->family);
                                ptr->family = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->swid ) {
                                libiodef_string_destroy(ptr->swid);
                                ptr->swid = NULL;
                        }

                        return 0;

                case 5:
                        if ( ptr->patch ) {
                                libiodef_string_destroy(ptr->patch);
                                ptr->patch = NULL;
                        }

                        return 0;

                case 6:
                        if ( ptr->version ) {
                                libiodef_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;

                case 7:
                        if ( ptr->configid ) {
                                libiodef_string_destroy(ptr->configid);
                                ptr->configid = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_application_destroy_internal(iodef_application_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->url ) {
                libiodef_string_destroy(ptr->url);
                ptr->url = NULL;
        }

        if ( ptr->vendor ) {
                libiodef_string_destroy(ptr->vendor);
                ptr->vendor = NULL;
        }

        if ( ptr->name ) {
                libiodef_string_destroy(ptr->name);
                ptr->name = NULL;
        }

        if ( ptr->family ) {
                libiodef_string_destroy(ptr->family);
                ptr->family = NULL;
        }

        if ( ptr->swid ) {
                libiodef_string_destroy(ptr->swid);
                ptr->swid = NULL;
        }

        if ( ptr->patch ) {
                libiodef_string_destroy(ptr->patch);
                ptr->patch = NULL;
        }

        if ( ptr->version ) {
                libiodef_string_destroy(ptr->version);
                ptr->version = NULL;
        }

        if ( ptr->configid ) {
                libiodef_string_destroy(ptr->configid);
                ptr->configid = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_application_destroy:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_application_destroy(iodef_application_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_application_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_application_get_url:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get url children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_url(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;
}

/**
 * iodef_application_set_url:
 * @ptr: pointer to a #iodef_application_t object.
 * @url: pointer to a #libiodef_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodef_application_set_url(iodef_application_t *ptr, libiodef_string_t *url)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->url )
                libiodef_string_destroy(ptr->url);

        ptr->url = url;
}

/**
 * iodef_application_new_url:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new url object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_url(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodef_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->url;
        return 0;
}

/**
 * iodef_application_get_vendor:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get vendor children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_vendor(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vendor;
}

/**
 * iodef_application_set_vendor:
 * @ptr: pointer to a #iodef_application_t object.
 * @vendor: pointer to a #libiodef_string_t object.
 *
 * Set @vendor object as a children of @ptr.
 * if @ptr already contain an @vendor object, then it is destroyed,
 * and updated to point to the provided @vendor object.
 */

void iodef_application_set_vendor(iodef_application_t *ptr, libiodef_string_t *vendor)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->vendor )
                libiodef_string_destroy(ptr->vendor);

        ptr->vendor = vendor;
}

/**
 * iodef_application_new_vendor:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new vendor object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_vendor(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->vendor ) {
                retval = libiodef_string_new(&ptr->vendor);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->vendor;
        return 0;
}

/**
 * iodef_application_get_name:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get name children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_name(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;
}

/**
 * iodef_application_set_name:
 * @ptr: pointer to a #iodef_application_t object.
 * @name: pointer to a #libiodef_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodef_application_set_name(iodef_application_t *ptr, libiodef_string_t *name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->name )
                libiodef_string_destroy(ptr->name);

        ptr->name = name;
}

/**
 * iodef_application_new_name:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new name object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_name(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodef_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->name;
        return 0;
}

/**
 * iodef_application_get_family:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get family children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_family(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->family;
}

/**
 * iodef_application_set_family:
 * @ptr: pointer to a #iodef_application_t object.
 * @family: pointer to a #libiodef_string_t object.
 *
 * Set @family object as a children of @ptr.
 * if @ptr already contain an @family object, then it is destroyed,
 * and updated to point to the provided @family object.
 */

void iodef_application_set_family(iodef_application_t *ptr, libiodef_string_t *family)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->family )
                libiodef_string_destroy(ptr->family);

        ptr->family = family;
}

/**
 * iodef_application_new_family:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new family object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_family(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->family ) {
                retval = libiodef_string_new(&ptr->family);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->family;
        return 0;
}

/**
 * iodef_application_get_swid:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get swid children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_swid(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->swid;
}

/**
 * iodef_application_set_swid:
 * @ptr: pointer to a #iodef_application_t object.
 * @swid: pointer to a #libiodef_string_t object.
 *
 * Set @swid object as a children of @ptr.
 * if @ptr already contain an @swid object, then it is destroyed,
 * and updated to point to the provided @swid object.
 */

void iodef_application_set_swid(iodef_application_t *ptr, libiodef_string_t *swid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->swid )
                libiodef_string_destroy(ptr->swid);

        ptr->swid = swid;
}

/**
 * iodef_application_new_swid:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new swid object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_swid(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->swid ) {
                retval = libiodef_string_new(&ptr->swid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->swid;
        return 0;
}

/**
 * iodef_application_get_patch:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get patch children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_patch(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->patch;
}

/**
 * iodef_application_set_patch:
 * @ptr: pointer to a #iodef_application_t object.
 * @patch: pointer to a #libiodef_string_t object.
 *
 * Set @patch object as a children of @ptr.
 * if @ptr already contain an @patch object, then it is destroyed,
 * and updated to point to the provided @patch object.
 */

void iodef_application_set_patch(iodef_application_t *ptr, libiodef_string_t *patch)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->patch )
                libiodef_string_destroy(ptr->patch);

        ptr->patch = patch;
}

/**
 * iodef_application_new_patch:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new patch object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_patch(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->patch ) {
                retval = libiodef_string_new(&ptr->patch);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->patch;
        return 0;
}

/**
 * iodef_application_get_version:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get version children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_version(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;
}

/**
 * iodef_application_set_version:
 * @ptr: pointer to a #iodef_application_t object.
 * @version: pointer to a #libiodef_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodef_application_set_version(iodef_application_t *ptr, libiodef_string_t *version)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->version )
                libiodef_string_destroy(ptr->version);

        ptr->version = version;
}

/**
 * iodef_application_new_version:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new version object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_version(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodef_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->version;
        return 0;
}

/**
 * iodef_application_get_configid:
 * @ptr: pointer to a #iodef_application_t object.
 *
 * Get configid children of the #iodef_application_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_application_get_configid(iodef_application_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->configid;
}

/**
 * iodef_application_set_configid:
 * @ptr: pointer to a #iodef_application_t object.
 * @configid: pointer to a #libiodef_string_t object.
 *
 * Set @configid object as a children of @ptr.
 * if @ptr already contain an @configid object, then it is destroyed,
 * and updated to point to the provided @configid object.
 */

void iodef_application_set_configid(iodef_application_t *ptr, libiodef_string_t *configid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->configid )
                libiodef_string_destroy(ptr->configid);

        ptr->configid = configid;
}

/**
 * iodef_application_new_configid:
 * @ptr: pointer to a #iodef_application_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new configid object, children of #iodef_application_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_application_new_configid(iodef_application_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->configid ) {
                retval = libiodef_string_new(&ptr->configid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->configid;
        return 0;
}

/**
 * iodef_application_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_application_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_application_copy(const iodef_application_t *src, iodef_application_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->url ) {
                libiodef_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodef_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->vendor ) {
                libiodef_string_destroy(dst->vendor);
                dst->vendor = NULL;
        }

        if ( src->vendor ) {
                ret = libiodef_string_clone(src->vendor, &dst->vendor);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->name ) {
                libiodef_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libiodef_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->family ) {
                libiodef_string_destroy(dst->family);
                dst->family = NULL;
        }

        if ( src->family ) {
                ret = libiodef_string_clone(src->family, &dst->family);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->swid ) {
                libiodef_string_destroy(dst->swid);
                dst->swid = NULL;
        }

        if ( src->swid ) {
                ret = libiodef_string_clone(src->swid, &dst->swid);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->patch ) {
                libiodef_string_destroy(dst->patch);
                dst->patch = NULL;
        }

        if ( src->patch ) {
                ret = libiodef_string_clone(src->patch, &dst->patch);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->version ) {
                libiodef_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libiodef_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->configid ) {
                libiodef_string_destroy(dst->configid);
                dst->configid = NULL;
        }

        if ( src->configid ) {
                ret = libiodef_string_clone(src->configid, &dst->configid);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_application_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_application_clone(iodef_application_t *src, iodef_application_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_application_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_application_copy(src, *dst);
}

/**
 * iodef_application_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_application_compare(const iodef_application_t *obj1, const iodef_application_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = libiodef_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->vendor, obj2->vendor);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->family, obj2->family);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->swid, obj2->swid);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->patch, obj2->patch);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->configid, obj2->configid);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_record_data_new:
 * @ret: Pointer where to store the created #iodef_record_data_t object.
 *
 * Create a new #iodef_record_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_data_new(iodef_record_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_RECORD_DATA;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->record_pattern_list);


        libiodef_list_init(&(*ret)->record_item_list);


        return 0;

}

/**
 * iodef_record_data_ref:
 * @record_data: pointer to a #iodef_record_data_t object.
 *
 * Increase @record_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record_data.
 */
iodef_record_data_t *iodef_record_data_ref(iodef_record_data_t *record_data)
{
        libiodef_return_val_if_fail(record_data, NULL);
        record_data->refcount++;

        return record_data;
}

int _iodef_record_data_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_record_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = ptr->additional_data;
                        return 0;

                case 1:
                        *childptr = &ptr->description_list;
                        return 0;

                case 2:
                        *childptr = &ptr->record_pattern_list;
                        return 0;

                case 3:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->date_time, TRUE);
                case 4:
                        *childptr = ptr->application;
                        return 0;

                case 5:
                        *childptr = &ptr->record_item_list;
                        return 0;

                case 6:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_DATA_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_data_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_record_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_record_data_new_additional_data(ptr, (iodef_additional_data_t **) ret);

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_record_data_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_record_data_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_record_data_new_record_pattern(ptr, (iodef_record_pattern_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_record_data_new_record_pattern(ptr, (iodef_record_pattern_t **) ret, n);
                }

                case 3:
                        return iodef_record_data_new_date_time(ptr, (iodef_time_t **) ret);

                case 4:
                        return iodef_record_data_new_application(ptr, (iodef_application_t **) ret);

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_record_data_new_record_item(ptr, (iodef_record_item_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_item_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_item_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_record_data_new_record_item(ptr, (iodef_record_item_t **) ret, n);
                }

                case 6:
                        return iodef_record_data_new_restriction(ptr, (iodef_record_data_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_data_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_record_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->additional_data ) {
                                iodef_additional_data_destroy(ptr->additional_data);
                                ptr->additional_data = NULL;
                        }

                        return 0;

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_pattern_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_pattern_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3:
                        if ( ptr->date_time ) {
                                iodef_time_destroy(ptr->date_time);
                                ptr->date_time = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->application ) {
                                iodef_application_destroy(ptr->application);
                                ptr->application = NULL;
                        }

                        return 0;

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_item_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_item_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_item_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_item_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 6:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_record_data_destroy_internal(iodef_record_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->additional_data ) {
                iodef_additional_data_destroy(ptr->additional_data);
                ptr->additional_data = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_record_pattern_t *entry;

                libiodef_list_for_each_safe(&ptr->record_pattern_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_record_pattern_destroy(entry);
                }
        }

        if ( ptr->date_time ) {
                iodef_time_destroy(ptr->date_time);
                ptr->date_time = NULL;
        }

        if ( ptr->application ) {
                iodef_application_destroy(ptr->application);
                ptr->application = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_record_item_t *entry;

                libiodef_list_for_each_safe(&ptr->record_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_record_item_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_record_data_destroy:
 * @ptr: pointer to a #iodef_record_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_record_data_destroy(iodef_record_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_record_data_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_record_data_get_additional_data:
 * @ptr: pointer to a #iodef_record_data_t object.
 *
 * Get additional_data children of the #iodef_record_data_t object.
 *
 * Returns: a pointer to a iodef_additional_data_t object, or NULL if the children object is not set.
 */
iodef_additional_data_t *iodef_record_data_get_additional_data(iodef_record_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->additional_data;
}

/**
 * iodef_record_data_set_additional_data:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @additional_data: pointer to a #iodef_additional_data_t object.
 *
 * Set @additional_data object as a children of @ptr.
 * if @ptr already contain an @additional_data object, then it is destroyed,
 * and updated to point to the provided @additional_data object.
 */

void iodef_record_data_set_additional_data(iodef_record_data_t *ptr, iodef_additional_data_t *additional_data)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->additional_data )
                iodef_additional_data_destroy(ptr->additional_data);

        ptr->additional_data = additional_data;
}

/**
 * iodef_record_data_new_additional_data:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 *
 * Create a new additional_data object, children of #iodef_record_data_t.
 * If @ptr already contain a #iodef_additional_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_additional_data(iodef_record_data_t *ptr, iodef_additional_data_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->additional_data ) {
                retval = iodef_additional_data_new(&ptr->additional_data);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->additional_data;
        return 0;
}

/**
 * iodef_record_data_get_next_description:
 * @record_data: pointer to a #iodef_record_data_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_record_data_get_next_description(iodef_record_data_t *record_data, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(record_data, NULL);

        libiodef_list_for_each_continue(&record_data->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_record_data_set_description:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_record_data_set_description(iodef_record_data_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_record_data_new_description:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_description(iodef_record_data_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_record_data_get_next_record_pattern:
 * @record_data: pointer to a #iodef_record_data_t object.
 * @record_pattern_cur: pointer to a #iodef_record_pattern_t object.
 *
 * Get the next #iodef_record_pattern_t object listed in @ptr.
 * When iterating over the iodef_record_pattern_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_record_pattern_t object.
 *
 * Returns: the next #iodef_record_pattern_t in the list.
 */
iodef_record_pattern_t *iodef_record_data_get_next_record_pattern(iodef_record_data_t *record_data, iodef_record_pattern_t *record_pattern_cur)
{
        libiodef_list_t *tmp = (record_pattern_cur) ? &((libiodef_linked_object_t *) record_pattern_cur)->_list : NULL;

        libiodef_return_val_if_fail(record_data, NULL);

        libiodef_list_for_each_continue(&record_data->record_pattern_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_record_data_set_record_pattern:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @object: pointer to a #iodef_record_pattern_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_record_pattern_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_record_data_set_record_pattern(iodef_record_data_t *ptr, iodef_record_pattern_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->record_pattern_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_record_data_new_record_pattern:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_record_pattern_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_record_pattern_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_record_pattern_t object. The created #iodef_record_pattern_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_record_pattern(iodef_record_data_t *ptr, iodef_record_pattern_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_record_pattern_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->record_pattern_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_record_data_get_date_time:
 * @ptr: pointer to a #iodef_record_data_t object.
 *
 * Get date_time children of the #iodef_record_data_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_record_data_get_date_time(iodef_record_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_time;
}

/**
 * iodef_record_data_set_date_time:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @date_time: pointer to a #iodef_time_t object.
 *
 * Set @date_time object as a children of @ptr.
 * if @ptr already contain an @date_time object, then it is destroyed,
 * and updated to point to the provided @date_time object.
 */

void iodef_record_data_set_date_time(iodef_record_data_t *ptr, iodef_time_t *date_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->date_time )
                iodef_time_destroy(ptr->date_time);

        ptr->date_time = date_time;
}

/**
 * iodef_record_data_new_date_time:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new date_time object, children of #iodef_record_data_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_date_time(iodef_record_data_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->date_time ) {
                retval = iodef_time_new(&ptr->date_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->date_time;
        return 0;
}

/**
 * iodef_record_data_get_application:
 * @ptr: pointer to a #iodef_record_data_t object.
 *
 * Get application children of the #iodef_record_data_t object.
 *
 * Returns: a pointer to a iodef_application_t object, or NULL if the children object is not set.
 */
iodef_application_t *iodef_record_data_get_application(iodef_record_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->application;
}

/**
 * iodef_record_data_set_application:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @application: pointer to a #iodef_application_t object.
 *
 * Set @application object as a children of @ptr.
 * if @ptr already contain an @application object, then it is destroyed,
 * and updated to point to the provided @application object.
 */

void iodef_record_data_set_application(iodef_record_data_t *ptr, iodef_application_t *application)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->application )
                iodef_application_destroy(ptr->application);

        ptr->application = application;
}

/**
 * iodef_record_data_new_application:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_application_t object.
 *
 * Create a new application object, children of #iodef_record_data_t.
 * If @ptr already contain a #iodef_application_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_application(iodef_record_data_t *ptr, iodef_application_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->application ) {
                retval = iodef_application_new(&ptr->application);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->application;
        return 0;
}

/**
 * iodef_record_data_get_next_record_item:
 * @record_data: pointer to a #iodef_record_data_t object.
 * @record_item_cur: pointer to a #iodef_record_item_t object.
 *
 * Get the next #iodef_record_item_t object listed in @ptr.
 * When iterating over the iodef_record_item_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_record_item_t object.
 *
 * Returns: the next #iodef_record_item_t in the list.
 */
iodef_record_item_t *iodef_record_data_get_next_record_item(iodef_record_data_t *record_data, iodef_record_item_t *record_item_cur)
{
        libiodef_list_t *tmp = (record_item_cur) ? &((libiodef_linked_object_t *) record_item_cur)->_list : NULL;

        libiodef_return_val_if_fail(record_data, NULL);

        libiodef_list_for_each_continue(&record_data->record_item_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_record_data_set_record_item:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @object: pointer to a #iodef_record_item_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_record_item_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_record_data_set_record_item(iodef_record_data_t *ptr, iodef_record_item_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->record_item_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_record_data_new_record_item:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_record_item_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_record_item_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_record_item_t object. The created #iodef_record_item_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_record_item(iodef_record_data_t *ptr, iodef_record_item_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_record_item_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->record_item_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_record_data_get_restriction:
 * @ptr: pointer to a #iodef_record_data_t object.
 *
 * Get restriction children of the #iodef_record_data_t object.
 *
 * Returns: a pointer to a iodef_record_data_restriction_t object, or NULL if the children object is not set.
 */
iodef_record_data_restriction_t iodef_record_data_get_restriction(iodef_record_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_record_data_set_restriction:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @restriction: pointer to a #iodef_record_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_record_data_set_restriction(iodef_record_data_t *ptr, iodef_record_data_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_record_data_new_restriction:
 * @ptr: pointer to a #iodef_record_data_t object.
 * @ret: pointer to an address where to store the created #iodef_record_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_record_data_t.
 * If @ptr already contain a #iodef_record_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_data_new_restriction(iodef_record_data_t *ptr, iodef_record_data_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_record_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_record_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_data_copy(const iodef_record_data_t *src, iodef_record_data_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->additional_data ) {
                iodef_additional_data_destroy(dst->additional_data);
                dst->additional_data = NULL;
        }

        if ( src->additional_data ) {
                ret = iodef_additional_data_clone(src->additional_data, &dst->additional_data);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_record_pattern_t *entry, *new;

                libiodef_list_for_each_safe(&dst->record_pattern_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_pattern_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->record_pattern_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_pattern_clone(entry, &new);
                        libiodef_list_add_tail(&dst->record_pattern_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->date_time ) {
                iodef_time_destroy(dst->date_time);
                dst->date_time = NULL;
        }

        if ( src->date_time ) {
                ret = iodef_time_clone(src->date_time, &dst->date_time);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->application ) {
                iodef_application_destroy(dst->application);
                dst->application = NULL;
        }

        if ( src->application ) {
                ret = iodef_application_clone(src->application, &dst->application);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_record_item_t *entry, *new;

                libiodef_list_for_each_safe(&dst->record_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_item_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->record_item_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_item_clone(entry, &new);
                        libiodef_list_add_tail(&dst->record_item_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_record_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_data_clone(iodef_record_data_t *src, iodef_record_data_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_record_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_record_data_copy(src, *dst);
}

/**
 * iodef_record_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_record_data_compare(const iodef_record_data_t *obj1, const iodef_record_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = iodef_additional_data_compare(obj1->additional_data, obj2->additional_data);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_record_pattern_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->record_pattern_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->record_pattern_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_record_pattern_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->date_time, obj2->date_time);
        if ( ret != 0 )
                return ret;

        ret = iodef_application_compare(obj1->application, obj2->application);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_record_item_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->record_item_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->record_item_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_record_item_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_record_new:
 * @ret: Pointer where to store the created #iodef_record_t object.
 *
 * Create a new #iodef_record_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_new(iodef_record_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_RECORD;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->record_data_list);


        return 0;

}

/**
 * iodef_record_ref:
 * @record: pointer to a #iodef_record_t object.
 *
 * Increase @record reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record.
 */
iodef_record_t *iodef_record_ref(iodef_record_t *record)
{
        libiodef_return_val_if_fail(record, NULL);
        record->refcount++;

        return record;
}

int _iodef_record_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_record_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->record_data_list;
                        return 0;

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_RECORD_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_record_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_record_new_record_data(ptr, (iodef_record_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_record_new_record_data(ptr, (iodef_record_data_t **) ret, n);
                }

                case 1:
                        return iodef_record_new_restriction(ptr, (iodef_record_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_record_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_record_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->record_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->record_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_record_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_record_destroy_internal(iodef_record_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                iodef_record_data_t *entry;

                libiodef_list_for_each_safe(&ptr->record_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_record_data_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_record_destroy:
 * @ptr: pointer to a #iodef_record_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_record_destroy(iodef_record_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_record_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_record_get_next_record_data:
 * @record: pointer to a #iodef_record_t object.
 * @record_data_cur: pointer to a #iodef_record_data_t object.
 *
 * Get the next #iodef_record_data_t object listed in @ptr.
 * When iterating over the iodef_record_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_record_data_t object.
 *
 * Returns: the next #iodef_record_data_t in the list.
 */
iodef_record_data_t *iodef_record_get_next_record_data(iodef_record_t *record, iodef_record_data_t *record_data_cur)
{
        libiodef_list_t *tmp = (record_data_cur) ? &((libiodef_linked_object_t *) record_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(record, NULL);

        libiodef_list_for_each_continue(&record->record_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_record_set_record_data:
 * @ptr: pointer to a #iodef_record_t object.
 * @object: pointer to a #iodef_record_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_record_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_record_set_record_data(iodef_record_t *ptr, iodef_record_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->record_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_record_new_record_data:
 * @ptr: pointer to a #iodef_record_t object.
 * @ret: pointer to an address where to store the created #iodef_record_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_record_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_record_data_t object. The created #iodef_record_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_new_record_data(iodef_record_t *ptr, iodef_record_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_record_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->record_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_record_get_restriction:
 * @ptr: pointer to a #iodef_record_t object.
 *
 * Get restriction children of the #iodef_record_t object.
 *
 * Returns: a pointer to a iodef_record_restriction_t object, or NULL if the children object is not set.
 */
iodef_record_restriction_t iodef_record_get_restriction(iodef_record_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_record_set_restriction:
 * @ptr: pointer to a #iodef_record_t object.
 * @restriction: pointer to a #iodef_record_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_record_set_restriction(iodef_record_t *ptr, iodef_record_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_record_new_restriction:
 * @ptr: pointer to a #iodef_record_t object.
 * @ret: pointer to an address where to store the created #iodef_record_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_record_t.
 * If @ptr already contain a #iodef_record_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_record_new_restriction(iodef_record_t *ptr, iodef_record_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_record_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_record_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_copy(const iodef_record_t *src, iodef_record_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_record_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->record_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->record_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_record_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->record_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_record_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_record_clone(iodef_record_t *src, iodef_record_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_record_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_record_copy(src, *dst);
}

/**
 * iodef_record_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_record_compare(const iodef_record_t *obj1, const iodef_record_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_record_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->record_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->record_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_record_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_reference_new:
 * @ret: Pointer where to store the created #iodef_reference_t object.
 *
 * Create a new #iodef_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_reference_new(iodef_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_REFERENCE;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->url_list);


        libiodef_list_init(&(*ret)->description_list);


        {
                int retval = libiodef_string_new(&(*ret)->reference_name);

                if ( retval < 0 ) {
                        iodef_reference_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_reference_ref:
 * @reference: pointer to a #iodef_reference_t object.
 *
 * Increase @reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @reference.
 */
iodef_reference_t *iodef_reference_ref(iodef_reference_t *reference)
{
        libiodef_return_val_if_fail(reference, NULL);
        reference->refcount++;

        return reference;
}

int _iodef_reference_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_reference_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->url_list;
                        return 0;

                case 1:
                        *childptr = &ptr->description_list;
                        return 0;

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->reference_name, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_reference_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_reference_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_reference_new_url(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->url_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->url_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_reference_new_url(ptr, (libiodef_string_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_reference_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_reference_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 2:
                        return iodef_reference_new_reference_name(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_reference_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_reference_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->url_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->url_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        if ( ptr->reference_name ) {
                                libiodef_string_destroy(ptr->reference_name);
                                ptr->reference_name = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_reference_destroy_internal(iodef_reference_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        if ( ptr->reference_name ) {
                libiodef_string_destroy(ptr->reference_name);
                ptr->reference_name = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_reference_destroy:
 * @ptr: pointer to a #iodef_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_reference_destroy(iodef_reference_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_reference_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_reference_get_next_url:
 * @reference: pointer to a #iodef_reference_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_reference_get_next_url(iodef_reference_t *reference, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(reference, NULL);

        libiodef_list_for_each_continue(&reference->url_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_reference_set_url:
 * @ptr: pointer to a #iodef_reference_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_reference_set_url(iodef_reference_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->url_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_reference_new_url:
 * @ptr: pointer to a #iodef_reference_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_reference_new_url(iodef_reference_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->url_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_reference_get_next_description:
 * @reference: pointer to a #iodef_reference_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_reference_get_next_description(iodef_reference_t *reference, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(reference, NULL);

        libiodef_list_for_each_continue(&reference->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_reference_set_description:
 * @ptr: pointer to a #iodef_reference_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_reference_set_description(iodef_reference_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_reference_new_description:
 * @ptr: pointer to a #iodef_reference_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_reference_new_description(iodef_reference_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_reference_get_reference_name:
 * @ptr: pointer to a #iodef_reference_t object.
 *
 * Get reference_name children of the #iodef_reference_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_reference_get_reference_name(iodef_reference_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->reference_name;
}

/**
 * iodef_reference_set_reference_name:
 * @ptr: pointer to a #iodef_reference_t object.
 * @reference_name: pointer to a #libiodef_string_t object.
 *
 * Set @reference_name object as a children of @ptr.
 * if @ptr already contain an @reference_name object, then it is destroyed,
 * and updated to point to the provided @reference_name object.
 */

void iodef_reference_set_reference_name(iodef_reference_t *ptr, libiodef_string_t *reference_name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->reference_name )
                libiodef_string_destroy(ptr->reference_name);

        ptr->reference_name = reference_name;
}

/**
 * iodef_reference_new_reference_name:
 * @ptr: pointer to a #iodef_reference_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new reference_name object, children of #iodef_reference_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_reference_new_reference_name(iodef_reference_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->reference_name ) {
                retval = libiodef_string_new(&ptr->reference_name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->reference_name;
        return 0;
}

/**
 * iodef_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_reference_copy(const iodef_reference_t *src, iodef_reference_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->url_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->url_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( src->reference_name ) {
                ret = libiodef_string_copy(src->reference_name, dst->reference_name);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_reference_clone(iodef_reference_t *src, iodef_reference_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_reference_copy(src, *dst);
}

/**
 * iodef_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_reference_compare(const iodef_reference_t *obj1, const iodef_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->url_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->url_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = libiodef_string_compare(obj1->reference_name, obj2->reference_name);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_method_new:
 * @ret: Pointer where to store the created #iodef_method_t object.
 *
 * Create a new #iodef_method_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_method_new(iodef_method_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_METHOD;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->reference_list);


        return 0;

}

/**
 * iodef_method_ref:
 * @method: pointer to a #iodef_method_t object.
 *
 * Increase @method reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @method.
 */
iodef_method_t *iodef_method_ref(iodef_method_t *method)
{
        libiodef_return_val_if_fail(method, NULL);
        method->refcount++;

        return method;
}

int _iodef_method_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_method_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 1:
                        *childptr = &ptr->description_list;
                        return 0;

                case 2:
                        *childptr = &ptr->reference_list;
                        return 0;

                case 3:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_METHOD_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_method_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_method_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_method_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_method_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_method_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_method_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_method_new_reference(ptr, (iodef_reference_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->reference_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_method_new_reference(ptr, (iodef_reference_t **) ret, n);
                }

                case 3:
                        return iodef_method_new_restriction(ptr, (iodef_method_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_method_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_method_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->reference_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_reference_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_reference_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_method_destroy_internal(iodef_method_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_reference_t *entry;

                libiodef_list_for_each_safe(&ptr->reference_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_reference_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_method_destroy:
 * @ptr: pointer to a #iodef_method_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_method_destroy(iodef_method_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_method_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_method_get_next_additional_data:
 * @method: pointer to a #iodef_method_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_method_get_next_additional_data(iodef_method_t *method, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(method, NULL);

        libiodef_list_for_each_continue(&method->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_method_set_additional_data:
 * @ptr: pointer to a #iodef_method_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_method_set_additional_data(iodef_method_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_method_new_additional_data:
 * @ptr: pointer to a #iodef_method_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_method_new_additional_data(iodef_method_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_method_get_next_description:
 * @method: pointer to a #iodef_method_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_method_get_next_description(iodef_method_t *method, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(method, NULL);

        libiodef_list_for_each_continue(&method->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_method_set_description:
 * @ptr: pointer to a #iodef_method_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_method_set_description(iodef_method_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_method_new_description:
 * @ptr: pointer to a #iodef_method_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_method_new_description(iodef_method_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_method_get_next_reference:
 * @method: pointer to a #iodef_method_t object.
 * @reference_cur: pointer to a #iodef_reference_t object.
 *
 * Get the next #iodef_reference_t object listed in @ptr.
 * When iterating over the iodef_reference_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_reference_t object.
 *
 * Returns: the next #iodef_reference_t in the list.
 */
iodef_reference_t *iodef_method_get_next_reference(iodef_method_t *method, iodef_reference_t *reference_cur)
{
        libiodef_list_t *tmp = (reference_cur) ? &((libiodef_linked_object_t *) reference_cur)->_list : NULL;

        libiodef_return_val_if_fail(method, NULL);

        libiodef_list_for_each_continue(&method->reference_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_method_set_reference:
 * @ptr: pointer to a #iodef_method_t object.
 * @object: pointer to a #iodef_reference_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_reference_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_method_set_reference(iodef_method_t *ptr, iodef_reference_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->reference_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_method_new_reference:
 * @ptr: pointer to a #iodef_method_t object.
 * @ret: pointer to an address where to store the created #iodef_reference_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_reference_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_reference_t object. The created #iodef_reference_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_method_new_reference(iodef_method_t *ptr, iodef_reference_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_reference_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->reference_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_method_get_restriction:
 * @ptr: pointer to a #iodef_method_t object.
 *
 * Get restriction children of the #iodef_method_t object.
 *
 * Returns: a pointer to a iodef_method_restriction_t object, or NULL if the children object is not set.
 */
iodef_method_restriction_t iodef_method_get_restriction(iodef_method_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_method_set_restriction:
 * @ptr: pointer to a #iodef_method_t object.
 * @restriction: pointer to a #iodef_method_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_method_set_restriction(iodef_method_t *ptr, iodef_method_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_method_new_restriction:
 * @ptr: pointer to a #iodef_method_t object.
 * @ret: pointer to an address where to store the created #iodef_method_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_method_t.
 * If @ptr already contain a #iodef_method_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_method_new_restriction(iodef_method_t *ptr, iodef_method_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_method_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_method_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_method_copy(const iodef_method_t *src, iodef_method_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_reference_t *entry, *new;

                libiodef_list_for_each_safe(&dst->reference_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_reference_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->reference_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_reference_clone(entry, &new);
                        libiodef_list_add_tail(&dst->reference_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_method_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_method_clone(iodef_method_t *src, iodef_method_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_method_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_method_copy(src, *dst);
}

/**
 * iodef_method_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_method_compare(const iodef_method_t *obj1, const iodef_method_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_reference_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->reference_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->reference_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_reference_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_time_impact_new:
 * @ret: Pointer where to store the created #iodef_time_impact_t object.
 *
 * Create a new #iodef_time_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_time_impact_new(iodef_time_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_TIME_IMPACT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_time_impact_ref:
 * @time_impact: pointer to a #iodef_time_impact_t object.
 *
 * Increase @time_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @time_impact.
 */
iodef_time_impact_t *iodef_time_impact_ref(iodef_time_impact_t *time_impact)
{
        libiodef_return_val_if_fail(time_impact, NULL);
        time_impact->refcount++;

        return time_impact;
}

int _iodef_time_impact_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_time_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_metric, TRUE);
                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_TIME_IMPACT_DURATION, ptr->duration);

                case 2:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_TIME_IMPACT_METRIC, ptr->metric);

                case 3:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_TIME_IMPACT_SEVERITY, ptr->severity);

                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_duration, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_time_impact_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_time_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_time_impact_new_ext_metric(ptr, (libiodef_string_t **) ret);

                case 1:
                        return iodef_time_impact_new_duration(ptr, (iodef_time_impact_duration_t **) ret);

                case 2:
                        return iodef_time_impact_new_metric(ptr, (iodef_time_impact_metric_t **) ret);

                case 3:
                        return iodef_time_impact_new_severity(ptr, (iodef_time_impact_severity_t **) ret);

                case 4:
                        return iodef_time_impact_new_ext_duration(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_time_impact_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_time_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->ext_metric ) {
                                libiodef_string_destroy(ptr->ext_metric);
                                ptr->ext_metric = NULL;
                        }

                        return 0;

                case 1:
                        ptr->duration = 0;
                        return 0;

                case 2:
                        ptr->metric = 0;
                        return 0;

                case 3:
                        ptr->severity = 0;
                        return 0;

                case 4:
                        if ( ptr->ext_duration ) {
                                libiodef_string_destroy(ptr->ext_duration);
                                ptr->ext_duration = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_time_impact_destroy_internal(iodef_time_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_metric ) {
                libiodef_string_destroy(ptr->ext_metric);
                ptr->ext_metric = NULL;
        }

        if ( ptr->ext_duration ) {
                libiodef_string_destroy(ptr->ext_duration);
                ptr->ext_duration = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_time_impact_destroy:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_time_impact_destroy(iodef_time_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_time_impact_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_time_impact_get_ext_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Get ext_metric children of the #iodef_time_impact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_time_impact_get_ext_metric(iodef_time_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_metric;
}

/**
 * iodef_time_impact_set_ext_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ext_metric: pointer to a #libiodef_string_t object.
 *
 * Set @ext_metric object as a children of @ptr.
 * if @ptr already contain an @ext_metric object, then it is destroyed,
 * and updated to point to the provided @ext_metric object.
 */

void iodef_time_impact_set_ext_metric(iodef_time_impact_t *ptr, libiodef_string_t *ext_metric)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_metric )
                libiodef_string_destroy(ptr->ext_metric);

        ptr->ext_metric = ext_metric;
}

/**
 * iodef_time_impact_new_ext_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_metric object, children of #iodef_time_impact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_time_impact_new_ext_metric(iodef_time_impact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_metric ) {
                retval = libiodef_string_new(&ptr->ext_metric);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_metric;
        return 0;
}

/**
 * iodef_time_impact_get_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Get duration children of the #iodef_time_impact_t object.
 *
 * Returns: a pointer to a iodef_time_impact_duration_t object, or NULL if the children object is not set.
 */
iodef_time_impact_duration_t iodef_time_impact_get_duration(iodef_time_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->duration;
}

/**
 * iodef_time_impact_set_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @duration: pointer to a #iodef_time_impact_duration_t object.
 *
 * Set @duration object as a children of @ptr.
 * if @ptr already contain an @duration object, then it is destroyed,
 * and updated to point to the provided @duration object.
 */

void iodef_time_impact_set_duration(iodef_time_impact_t *ptr, iodef_time_impact_duration_t duration)
{
        libiodef_return_if_fail(ptr);
        ptr->duration = duration;
}

/**
 * iodef_time_impact_new_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_time_impact_duration_t object.
 *
 * Create a new duration object, children of #iodef_time_impact_t.
 * If @ptr already contain a #iodef_time_impact_duration_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_time_impact_new_duration(iodef_time_impact_t *ptr, iodef_time_impact_duration_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->duration;
        return 0;
}

/**
 * iodef_time_impact_get_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Get metric children of the #iodef_time_impact_t object.
 *
 * Returns: a pointer to a iodef_time_impact_metric_t object, or NULL if the children object is not set.
 */
iodef_time_impact_metric_t iodef_time_impact_get_metric(iodef_time_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->metric;
}

/**
 * iodef_time_impact_set_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @metric: pointer to a #iodef_time_impact_metric_t object.
 *
 * Set @metric object as a children of @ptr.
 * if @ptr already contain an @metric object, then it is destroyed,
 * and updated to point to the provided @metric object.
 */

void iodef_time_impact_set_metric(iodef_time_impact_t *ptr, iodef_time_impact_metric_t metric)
{
        libiodef_return_if_fail(ptr);
        ptr->metric = metric;
}

/**
 * iodef_time_impact_new_metric:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_time_impact_metric_t object.
 *
 * Create a new metric object, children of #iodef_time_impact_t.
 * If @ptr already contain a #iodef_time_impact_metric_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_time_impact_new_metric(iodef_time_impact_t *ptr, iodef_time_impact_metric_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->metric;
        return 0;
}

/**
 * iodef_time_impact_get_severity:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Get severity children of the #iodef_time_impact_t object.
 *
 * Returns: a pointer to a iodef_time_impact_severity_t object, or NULL if the children object is not set.
 */
iodef_time_impact_severity_t iodef_time_impact_get_severity(iodef_time_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity;
}

/**
 * iodef_time_impact_set_severity:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @severity: pointer to a #iodef_time_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */

void iodef_time_impact_set_severity(iodef_time_impact_t *ptr, iodef_time_impact_severity_t severity)
{
        libiodef_return_if_fail(ptr);
        ptr->severity = severity;
}

/**
 * iodef_time_impact_new_severity:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_time_impact_severity_t object.
 *
 * Create a new severity object, children of #iodef_time_impact_t.
 * If @ptr already contain a #iodef_time_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_time_impact_new_severity(iodef_time_impact_t *ptr, iodef_time_impact_severity_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->severity;
        return 0;
}

/**
 * iodef_time_impact_get_ext_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 *
 * Get ext_duration children of the #iodef_time_impact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_time_impact_get_ext_duration(iodef_time_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_duration;
}

/**
 * iodef_time_impact_set_ext_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ext_duration: pointer to a #libiodef_string_t object.
 *
 * Set @ext_duration object as a children of @ptr.
 * if @ptr already contain an @ext_duration object, then it is destroyed,
 * and updated to point to the provided @ext_duration object.
 */

void iodef_time_impact_set_ext_duration(iodef_time_impact_t *ptr, libiodef_string_t *ext_duration)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_duration )
                libiodef_string_destroy(ptr->ext_duration);

        ptr->ext_duration = ext_duration;
}

/**
 * iodef_time_impact_new_ext_duration:
 * @ptr: pointer to a #iodef_time_impact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_duration object, children of #iodef_time_impact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_time_impact_new_ext_duration(iodef_time_impact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_duration ) {
                retval = libiodef_string_new(&ptr->ext_duration);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_duration;
        return 0;
}

/**
 * iodef_time_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_time_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_time_impact_copy(const iodef_time_impact_t *src, iodef_time_impact_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->ext_metric ) {
                libiodef_string_destroy(dst->ext_metric);
                dst->ext_metric = NULL;
        }

        if ( src->ext_metric ) {
                ret = libiodef_string_clone(src->ext_metric, &dst->ext_metric);
                if ( ret < 0 )
                        return ret;
        }

        dst->duration = src->duration;

        dst->metric = src->metric;

        dst->severity = src->severity;

        if ( dst->ext_duration ) {
                libiodef_string_destroy(dst->ext_duration);
                dst->ext_duration = NULL;
        }

        if ( src->ext_duration ) {
                ret = libiodef_string_clone(src->ext_duration, &dst->ext_duration);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_time_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_time_impact_clone(iodef_time_impact_t *src, iodef_time_impact_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_time_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_time_impact_copy(src, *dst);
}

/**
 * iodef_time_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_time_impact_compare(const iodef_time_impact_t *obj1, const iodef_time_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = libiodef_string_compare(obj1->ext_metric, obj2->ext_metric);
        if ( ret != 0 )
                return ret;

        if ( obj1->duration != obj2->duration )
                return -1;

        if ( obj1->metric != obj2->metric )
                return -1;

        if ( obj1->severity != obj2->severity )
                return -1;

        ret = libiodef_string_compare(obj1->ext_duration, obj2->ext_duration);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_impact_new:
 * @ret: Pointer where to store the created #iodef_impact_t object.
 *
 * Create a new #iodef_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_impact_new(iodef_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_IMPACT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_impact_ref:
 * @impact: pointer to a #iodef_impact_t object.
 *
 * Increase @impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @impact.
 */
iodef_impact_t *iodef_impact_ref(iodef_impact_t *impact)
{
        libiodef_return_val_if_fail(impact, NULL);
        impact->refcount++;

        return impact;
}

int _iodef_impact_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_IMPACT_LANG, ptr->lang);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_IMPACT_COMPLETION, ptr->completion);

                case 2:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_IMPACT_TYPE, ptr->type);

                case 3:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_IMPACT_SEVERITY, ptr->severity);

                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_type, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_impact_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_impact_new_lang(ptr, (iodef_impact_lang_t **) ret);

                case 1:
                        return iodef_impact_new_completion(ptr, (iodef_impact_completion_t **) ret);

                case 2:
                        return iodef_impact_new_type(ptr, (iodef_impact_type_t **) ret);

                case 3:
                        return iodef_impact_new_severity(ptr, (iodef_impact_severity_t **) ret);

                case 4:
                        return iodef_impact_new_ext_type(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_impact_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->lang = 0;
                        return 0;

                case 1:
                        ptr->completion = 0;
                        return 0;

                case 2:
                        ptr->type = 0;
                        return 0;

                case 3:
                        ptr->severity = 0;
                        return 0;

                case 4:
                        if ( ptr->ext_type ) {
                                libiodef_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_impact_destroy_internal(iodef_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_type ) {
                libiodef_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_impact_destroy:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_impact_destroy(iodef_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_impact_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_impact_get_lang:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Get lang children of the #iodef_impact_t object.
 *
 * Returns: a pointer to a iodef_impact_lang_t object, or NULL if the children object is not set.
 */
iodef_impact_lang_t iodef_impact_get_lang(iodef_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;
}

/**
 * iodef_impact_set_lang:
 * @ptr: pointer to a #iodef_impact_t object.
 * @lang: pointer to a #iodef_impact_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */

void iodef_impact_set_lang(iodef_impact_t *ptr, iodef_impact_lang_t lang)
{
        libiodef_return_if_fail(ptr);
        ptr->lang = lang;
}

/**
 * iodef_impact_new_lang:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_impact_lang_t object.
 *
 * Create a new lang object, children of #iodef_impact_t.
 * If @ptr already contain a #iodef_impact_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_impact_new_lang(iodef_impact_t *ptr, iodef_impact_lang_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->lang;
        return 0;
}

/**
 * iodef_impact_get_completion:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Get completion children of the #iodef_impact_t object.
 *
 * Returns: a pointer to a iodef_impact_completion_t object, or NULL if the children object is not set.
 */
iodef_impact_completion_t iodef_impact_get_completion(iodef_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->completion;
}

/**
 * iodef_impact_set_completion:
 * @ptr: pointer to a #iodef_impact_t object.
 * @completion: pointer to a #iodef_impact_completion_t object.
 *
 * Set @completion object as a children of @ptr.
 * if @ptr already contain an @completion object, then it is destroyed,
 * and updated to point to the provided @completion object.
 */

void iodef_impact_set_completion(iodef_impact_t *ptr, iodef_impact_completion_t completion)
{
        libiodef_return_if_fail(ptr);
        ptr->completion = completion;
}

/**
 * iodef_impact_new_completion:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_impact_completion_t object.
 *
 * Create a new completion object, children of #iodef_impact_t.
 * If @ptr already contain a #iodef_impact_completion_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_impact_new_completion(iodef_impact_t *ptr, iodef_impact_completion_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->completion;
        return 0;
}

/**
 * iodef_impact_get_type:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Get type children of the #iodef_impact_t object.
 *
 * Returns: a pointer to a iodef_impact_type_t object, or NULL if the children object is not set.
 */
iodef_impact_type_t iodef_impact_get_type(iodef_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;
}

/**
 * iodef_impact_set_type:
 * @ptr: pointer to a #iodef_impact_t object.
 * @type: pointer to a #iodef_impact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void iodef_impact_set_type(iodef_impact_t *ptr, iodef_impact_type_t type)
{
        libiodef_return_if_fail(ptr);
        ptr->type = type;
}

/**
 * iodef_impact_new_type:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_impact_type_t object.
 *
 * Create a new type object, children of #iodef_impact_t.
 * If @ptr already contain a #iodef_impact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_impact_new_type(iodef_impact_t *ptr, iodef_impact_type_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->type;
        return 0;
}

/**
 * iodef_impact_get_severity:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Get severity children of the #iodef_impact_t object.
 *
 * Returns: a pointer to a iodef_impact_severity_t object, or NULL if the children object is not set.
 */
iodef_impact_severity_t iodef_impact_get_severity(iodef_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity;
}

/**
 * iodef_impact_set_severity:
 * @ptr: pointer to a #iodef_impact_t object.
 * @severity: pointer to a #iodef_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */

void iodef_impact_set_severity(iodef_impact_t *ptr, iodef_impact_severity_t severity)
{
        libiodef_return_if_fail(ptr);
        ptr->severity = severity;
}

/**
 * iodef_impact_new_severity:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_impact_severity_t object.
 *
 * Create a new severity object, children of #iodef_impact_t.
 * If @ptr already contain a #iodef_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_impact_new_severity(iodef_impact_t *ptr, iodef_impact_severity_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->severity;
        return 0;
}

/**
 * iodef_impact_get_ext_type:
 * @ptr: pointer to a #iodef_impact_t object.
 *
 * Get ext_type children of the #iodef_impact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_impact_get_ext_type(iodef_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;
}

/**
 * iodef_impact_set_ext_type:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ext_type: pointer to a #libiodef_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodef_impact_set_ext_type(iodef_impact_t *ptr, libiodef_string_t *ext_type)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_type )
                libiodef_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}

/**
 * iodef_impact_new_ext_type:
 * @ptr: pointer to a #iodef_impact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_type object, children of #iodef_impact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_impact_new_ext_type(iodef_impact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodef_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_type;
        return 0;
}

/**
 * iodef_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_impact_copy(const iodef_impact_t *src, iodef_impact_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->lang = src->lang;

        dst->completion = src->completion;

        dst->type = src->type;

        dst->severity = src->severity;

        if ( dst->ext_type ) {
                libiodef_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodef_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_impact_clone(iodef_impact_t *src, iodef_impact_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_impact_copy(src, *dst);
}

/**
 * iodef_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_impact_compare(const iodef_impact_t *obj1, const iodef_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->lang != obj2->lang )
                return -1;

        if ( obj1->completion != obj2->completion )
                return -1;

        if ( obj1->type != obj2->type )
                return -1;

        if ( obj1->severity != obj2->severity )
                return -1;

        ret = libiodef_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_confidence_new:
 * @ret: Pointer where to store the created #iodef_confidence_t object.
 *
 * Create a new #iodef_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_confidence_new(iodef_confidence_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_CONFIDENCE;

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_confidence_ref:
 * @confidence: pointer to a #iodef_confidence_t object.
 *
 * Increase @confidence reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @confidence.
 */
iodef_confidence_t *iodef_confidence_ref(iodef_confidence_t *confidence)
{
        libiodef_return_val_if_fail(confidence, NULL);
        confidence->refcount++;

        return confidence;
}

int _iodef_confidence_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_confidence_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_CONFIDENCE_RATING, ptr->rating);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_confidence_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_confidence_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_confidence_new_rating(ptr, (iodef_confidence_rating_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_confidence_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_confidence_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->rating = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_confidence_destroy_internal(iodef_confidence_t *ptr)
{
        libiodef_return_if_fail(ptr);


        /* free() should be done by the caller */
}

/**
 * iodef_confidence_destroy:
 * @ptr: pointer to a #iodef_confidence_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_confidence_destroy(iodef_confidence_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_confidence_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_confidence_get_rating:
 * @ptr: pointer to a #iodef_confidence_t object.
 *
 * Get rating children of the #iodef_confidence_t object.
 *
 * Returns: a pointer to a iodef_confidence_rating_t object, or NULL if the children object is not set.
 */
iodef_confidence_rating_t iodef_confidence_get_rating(iodef_confidence_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->rating;
}

/**
 * iodef_confidence_set_rating:
 * @ptr: pointer to a #iodef_confidence_t object.
 * @rating: pointer to a #iodef_confidence_rating_t object.
 *
 * Set @rating object as a children of @ptr.
 * if @ptr already contain an @rating object, then it is destroyed,
 * and updated to point to the provided @rating object.
 */

void iodef_confidence_set_rating(iodef_confidence_t *ptr, iodef_confidence_rating_t rating)
{
        libiodef_return_if_fail(ptr);
        ptr->rating = rating;
}

/**
 * iodef_confidence_new_rating:
 * @ptr: pointer to a #iodef_confidence_t object.
 * @ret: pointer to an address where to store the created #iodef_confidence_rating_t object.
 *
 * Create a new rating object, children of #iodef_confidence_t.
 * If @ptr already contain a #iodef_confidence_rating_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_confidence_new_rating(iodef_confidence_t *ptr, iodef_confidence_rating_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->rating;
        return 0;
}

/**
 * iodef_confidence_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_confidence_copy(const iodef_confidence_t *src, iodef_confidence_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->rating = src->rating;

        return 0;
}

/**
 * iodef_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_confidence_clone(iodef_confidence_t *src, iodef_confidence_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_confidence_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_confidence_copy(src, *dst);
}

/**
 * iodef_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_confidence_compare(const iodef_confidence_t *obj1, const iodef_confidence_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->rating != obj2->rating )
                return -1;

        return ret;
}

/**
 * iodef_monetary_impact_new:
 * @ret: Pointer where to store the created #iodef_monetary_impact_t object.
 *
 * Create a new #iodef_monetary_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_monetary_impact_new(iodef_monetary_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_MONETARY_IMPACT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
                int retval = libiodef_string_new(&(*ret)->currency);

                if ( retval < 0 ) {
                        iodef_monetary_impact_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_monetary_impact_ref:
 * @monetary_impact: pointer to a #iodef_monetary_impact_t object.
 *
 * Increase @monetary_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @monetary_impact.
 */
iodef_monetary_impact_t *iodef_monetary_impact_ref(iodef_monetary_impact_t *monetary_impact)
{
        libiodef_return_val_if_fail(monetary_impact, NULL);
        monetary_impact->refcount++;

        return monetary_impact;
}

int _iodef_monetary_impact_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_monetary_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->currency, TRUE);
                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_MONETARY_IMPACT_SEVERITY, ptr->severity);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_monetary_impact_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_monetary_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_monetary_impact_new_currency(ptr, (libiodef_string_t **) ret);

                case 1:
                        return iodef_monetary_impact_new_severity(ptr, (iodef_monetary_impact_severity_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_monetary_impact_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_monetary_impact_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->currency ) {
                                libiodef_string_destroy(ptr->currency);
                                ptr->currency = NULL;
                        }

                        return 0;

                case 1:
                        ptr->severity = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_monetary_impact_destroy_internal(iodef_monetary_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->currency ) {
                libiodef_string_destroy(ptr->currency);
                ptr->currency = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_monetary_impact_destroy:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_monetary_impact_destroy(iodef_monetary_impact_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_monetary_impact_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_monetary_impact_get_currency:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 *
 * Get currency children of the #iodef_monetary_impact_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_monetary_impact_get_currency(iodef_monetary_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->currency;
}

/**
 * iodef_monetary_impact_set_currency:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 * @currency: pointer to a #libiodef_string_t object.
 *
 * Set @currency object as a children of @ptr.
 * if @ptr already contain an @currency object, then it is destroyed,
 * and updated to point to the provided @currency object.
 */

void iodef_monetary_impact_set_currency(iodef_monetary_impact_t *ptr, libiodef_string_t *currency)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->currency )
                libiodef_string_destroy(ptr->currency);

        ptr->currency = currency;
}

/**
 * iodef_monetary_impact_new_currency:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new currency object, children of #iodef_monetary_impact_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_monetary_impact_new_currency(iodef_monetary_impact_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->currency ) {
                retval = libiodef_string_new(&ptr->currency);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->currency;
        return 0;
}

/**
 * iodef_monetary_impact_get_severity:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 *
 * Get severity children of the #iodef_monetary_impact_t object.
 *
 * Returns: a pointer to a iodef_monetary_impact_severity_t object, or NULL if the children object is not set.
 */
iodef_monetary_impact_severity_t iodef_monetary_impact_get_severity(iodef_monetary_impact_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity;
}

/**
 * iodef_monetary_impact_set_severity:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 * @severity: pointer to a #iodef_monetary_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */

void iodef_monetary_impact_set_severity(iodef_monetary_impact_t *ptr, iodef_monetary_impact_severity_t severity)
{
        libiodef_return_if_fail(ptr);
        ptr->severity = severity;
}

/**
 * iodef_monetary_impact_new_severity:
 * @ptr: pointer to a #iodef_monetary_impact_t object.
 * @ret: pointer to an address where to store the created #iodef_monetary_impact_severity_t object.
 *
 * Create a new severity object, children of #iodef_monetary_impact_t.
 * If @ptr already contain a #iodef_monetary_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_monetary_impact_new_severity(iodef_monetary_impact_t *ptr, iodef_monetary_impact_severity_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->severity;
        return 0;
}

/**
 * iodef_monetary_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_monetary_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_monetary_impact_copy(const iodef_monetary_impact_t *src, iodef_monetary_impact_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( src->currency ) {
                ret = libiodef_string_copy(src->currency, dst->currency);
                if ( ret < 0 )
                        return ret;
        }

        dst->severity = src->severity;

        return 0;
}

/**
 * iodef_monetary_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_monetary_impact_clone(iodef_monetary_impact_t *src, iodef_monetary_impact_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_monetary_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_monetary_impact_copy(src, *dst);
}

/**
 * iodef_monetary_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_monetary_impact_compare(const iodef_monetary_impact_t *obj1, const iodef_monetary_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = libiodef_string_compare(obj1->currency, obj2->currency);
        if ( ret != 0 )
                return ret;

        if ( obj1->severity != obj2->severity )
                return -1;

        return ret;
}

/**
 * iodef_counter_new:
 * @ret: Pointer where to store the created #iodef_counter_t object.
 *
 * Create a new #iodef_counter_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_counter_new(iodef_counter_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_COUNTER;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_counter_ref:
 * @counter: pointer to a #iodef_counter_t object.
 *
 * Increase @counter reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @counter.
 */
iodef_counter_t *iodef_counter_ref(iodef_counter_t *counter)
{
        libiodef_return_val_if_fail(counter, NULL);
        counter->refcount++;

        return counter;
}

int _iodef_counter_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_counter_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_COUNTER_DURATION, ptr->duration);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_COUNTER_TYPE, ptr->type);

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_duration, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_type, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_counter_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_counter_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_counter_new_duration(ptr, (iodef_counter_duration_t **) ret);

                case 1:
                        return iodef_counter_new_type(ptr, (iodef_counter_type_t **) ret);

                case 2:
                        return iodef_counter_new_ext_duration(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_counter_new_ext_type(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_counter_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_counter_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->duration = 0;
                        return 0;

                case 1:
                        ptr->type = 0;
                        return 0;

                case 2:
                        if ( ptr->ext_duration ) {
                                libiodef_string_destroy(ptr->ext_duration);
                                ptr->ext_duration = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->ext_type ) {
                                libiodef_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_counter_destroy_internal(iodef_counter_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_duration ) {
                libiodef_string_destroy(ptr->ext_duration);
                ptr->ext_duration = NULL;
        }

        if ( ptr->ext_type ) {
                libiodef_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_counter_destroy:
 * @ptr: pointer to a #iodef_counter_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_counter_destroy(iodef_counter_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_counter_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_counter_get_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 *
 * Get duration children of the #iodef_counter_t object.
 *
 * Returns: a pointer to a iodef_counter_duration_t object, or NULL if the children object is not set.
 */
iodef_counter_duration_t iodef_counter_get_duration(iodef_counter_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->duration;
}

/**
 * iodef_counter_set_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 * @duration: pointer to a #iodef_counter_duration_t object.
 *
 * Set @duration object as a children of @ptr.
 * if @ptr already contain an @duration object, then it is destroyed,
 * and updated to point to the provided @duration object.
 */

void iodef_counter_set_duration(iodef_counter_t *ptr, iodef_counter_duration_t duration)
{
        libiodef_return_if_fail(ptr);
        ptr->duration = duration;
}

/**
 * iodef_counter_new_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ret: pointer to an address where to store the created #iodef_counter_duration_t object.
 *
 * Create a new duration object, children of #iodef_counter_t.
 * If @ptr already contain a #iodef_counter_duration_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_counter_new_duration(iodef_counter_t *ptr, iodef_counter_duration_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->duration;
        return 0;
}

/**
 * iodef_counter_get_type:
 * @ptr: pointer to a #iodef_counter_t object.
 *
 * Get type children of the #iodef_counter_t object.
 *
 * Returns: a pointer to a iodef_counter_type_t object, or NULL if the children object is not set.
 */
iodef_counter_type_t iodef_counter_get_type(iodef_counter_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;
}

/**
 * iodef_counter_set_type:
 * @ptr: pointer to a #iodef_counter_t object.
 * @type: pointer to a #iodef_counter_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */

void iodef_counter_set_type(iodef_counter_t *ptr, iodef_counter_type_t type)
{
        libiodef_return_if_fail(ptr);
        ptr->type = type;
}

/**
 * iodef_counter_new_type:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ret: pointer to an address where to store the created #iodef_counter_type_t object.
 *
 * Create a new type object, children of #iodef_counter_t.
 * If @ptr already contain a #iodef_counter_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_counter_new_type(iodef_counter_t *ptr, iodef_counter_type_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->type;
        return 0;
}

/**
 * iodef_counter_get_ext_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 *
 * Get ext_duration children of the #iodef_counter_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_counter_get_ext_duration(iodef_counter_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_duration;
}

/**
 * iodef_counter_set_ext_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ext_duration: pointer to a #libiodef_string_t object.
 *
 * Set @ext_duration object as a children of @ptr.
 * if @ptr already contain an @ext_duration object, then it is destroyed,
 * and updated to point to the provided @ext_duration object.
 */

void iodef_counter_set_ext_duration(iodef_counter_t *ptr, libiodef_string_t *ext_duration)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_duration )
                libiodef_string_destroy(ptr->ext_duration);

        ptr->ext_duration = ext_duration;
}

/**
 * iodef_counter_new_ext_duration:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_duration object, children of #iodef_counter_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_counter_new_ext_duration(iodef_counter_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_duration ) {
                retval = libiodef_string_new(&ptr->ext_duration);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_duration;
        return 0;
}

/**
 * iodef_counter_get_ext_type:
 * @ptr: pointer to a #iodef_counter_t object.
 *
 * Get ext_type children of the #iodef_counter_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_counter_get_ext_type(iodef_counter_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;
}

/**
 * iodef_counter_set_ext_type:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ext_type: pointer to a #libiodef_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodef_counter_set_ext_type(iodef_counter_t *ptr, libiodef_string_t *ext_type)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_type )
                libiodef_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}

/**
 * iodef_counter_new_ext_type:
 * @ptr: pointer to a #iodef_counter_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_type object, children of #iodef_counter_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_counter_new_ext_type(iodef_counter_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodef_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_type;
        return 0;
}

/**
 * iodef_counter_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_counter_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_counter_copy(const iodef_counter_t *src, iodef_counter_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->duration = src->duration;

        dst->type = src->type;

        if ( dst->ext_duration ) {
                libiodef_string_destroy(dst->ext_duration);
                dst->ext_duration = NULL;
        }

        if ( src->ext_duration ) {
                ret = libiodef_string_clone(src->ext_duration, &dst->ext_duration);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->ext_type ) {
                libiodef_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodef_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_counter_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_counter_clone(iodef_counter_t *src, iodef_counter_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_counter_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_counter_copy(src, *dst);
}

/**
 * iodef_counter_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_counter_compare(const iodef_counter_t *obj1, const iodef_counter_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->duration != obj2->duration )
                return -1;

        if ( obj1->type != obj2->type )
                return -1;

        ret = libiodef_string_compare(obj1->ext_duration, obj2->ext_duration);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_assessment_new:
 * @ret: Pointer where to store the created #iodef_assessment_t object.
 *
 * Create a new #iodef_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_assessment_new(iodef_assessment_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_ASSESSMENT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->impact_list);


        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->time_impact_list);


        libiodef_list_init(&(*ret)->monetary_impact_list);


        libiodef_list_init(&(*ret)->counter_list);


        return 0;

}

/**
 * iodef_assessment_ref:
 * @assessment: pointer to a #iodef_assessment_t object.
 *
 * Increase @assessment reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @assessment.
 */
iodef_assessment_t *iodef_assessment_ref(iodef_assessment_t *assessment)
{
        libiodef_return_val_if_fail(assessment, NULL);
        assessment->refcount++;

        return assessment;
}

int _iodef_assessment_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_assessment_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->impact_list;
                        return 0;

                case 1:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 2:
                        *childptr = ptr->confidence;
                        return 0;

                case 3:
                        *childptr = &ptr->time_impact_list;
                        return 0;

                case 4:
                        *childptr = &ptr->monetary_impact_list;
                        return 0;

                case 5:
                        *childptr = &ptr->counter_list;
                        return 0;

                case 6:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ASSESSMENT_RESTRICTION, ptr->restriction);

                case 7:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ASSESSMENT_OCCURRENCE, ptr->occurrence);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_assessment_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_assessment_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_assessment_new_impact(ptr, (iodef_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_assessment_new_impact(ptr, (iodef_impact_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_assessment_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_assessment_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 2:
                        return iodef_assessment_new_confidence(ptr, (iodef_confidence_t **) ret);

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_assessment_new_time_impact(ptr, (iodef_time_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->time_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->time_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_assessment_new_time_impact(ptr, (iodef_time_impact_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_assessment_new_monetary_impact(ptr, (iodef_monetary_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_assessment_new_monetary_impact(ptr, (iodef_monetary_impact_t **) ret, n);
                }

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_assessment_new_counter(ptr, (iodef_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_assessment_new_counter(ptr, (iodef_counter_t **) ret, n);
                }

                case 6:
                        return iodef_assessment_new_restriction(ptr, (iodef_assessment_restriction_t **) ret);

                case 7:
                        return iodef_assessment_new_occurrence(ptr, (iodef_assessment_occurrence_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_assessment_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_assessment_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->impact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        if ( ptr->confidence ) {
                                iodef_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->time_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_time_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->time_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_time_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_monetary_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_monetary_impact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 6:
                        ptr->restriction = 0;
                        return 0;

                case 7:
                        ptr->occurrence = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_assessment_destroy_internal(iodef_assessment_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                iodef_impact_t *entry;

                libiodef_list_for_each_safe(&ptr->impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_impact_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        if ( ptr->confidence ) {
                iodef_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_time_impact_t *entry;

                libiodef_list_for_each_safe(&ptr->time_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_time_impact_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_monetary_impact_t *entry;

                libiodef_list_for_each_safe(&ptr->monetary_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_monetary_impact_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry;

                libiodef_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_counter_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_assessment_destroy:
 * @ptr: pointer to a #iodef_assessment_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_assessment_destroy(iodef_assessment_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_assessment_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_assessment_get_next_impact:
 * @assessment: pointer to a #iodef_assessment_t object.
 * @impact_cur: pointer to a #iodef_impact_t object.
 *
 * Get the next #iodef_impact_t object listed in @ptr.
 * When iterating over the iodef_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_impact_t object.
 *
 * Returns: the next #iodef_impact_t in the list.
 */
iodef_impact_t *iodef_assessment_get_next_impact(iodef_assessment_t *assessment, iodef_impact_t *impact_cur)
{
        libiodef_list_t *tmp = (impact_cur) ? &((libiodef_linked_object_t *) impact_cur)->_list : NULL;

        libiodef_return_val_if_fail(assessment, NULL);

        libiodef_list_for_each_continue(&assessment->impact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_assessment_set_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @object: pointer to a #iodef_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_impact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_assessment_set_impact(iodef_assessment_t *ptr, iodef_impact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->impact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_assessment_new_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_impact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_impact_t object. The created #iodef_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_impact(iodef_assessment_t *ptr, iodef_impact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->impact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_assessment_get_next_additional_data:
 * @assessment: pointer to a #iodef_assessment_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_assessment_get_next_additional_data(iodef_assessment_t *assessment, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(assessment, NULL);

        libiodef_list_for_each_continue(&assessment->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_assessment_set_additional_data:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_assessment_set_additional_data(iodef_assessment_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_assessment_new_additional_data:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_additional_data(iodef_assessment_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_assessment_get_confidence:
 * @ptr: pointer to a #iodef_assessment_t object.
 *
 * Get confidence children of the #iodef_assessment_t object.
 *
 * Returns: a pointer to a iodef_confidence_t object, or NULL if the children object is not set.
 */
iodef_confidence_t *iodef_assessment_get_confidence(iodef_assessment_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;
}

/**
 * iodef_assessment_set_confidence:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @confidence: pointer to a #iodef_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void iodef_assessment_set_confidence(iodef_assessment_t *ptr, iodef_confidence_t *confidence)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->confidence )
                iodef_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}

/**
 * iodef_assessment_new_confidence:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_confidence_t object.
 *
 * Create a new confidence object, children of #iodef_assessment_t.
 * If @ptr already contain a #iodef_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_confidence(iodef_assessment_t *ptr, iodef_confidence_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = iodef_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->confidence;
        return 0;
}

/**
 * iodef_assessment_get_next_time_impact:
 * @assessment: pointer to a #iodef_assessment_t object.
 * @time_impact_cur: pointer to a #iodef_time_impact_t object.
 *
 * Get the next #iodef_time_impact_t object listed in @ptr.
 * When iterating over the iodef_time_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_time_impact_t object.
 *
 * Returns: the next #iodef_time_impact_t in the list.
 */
iodef_time_impact_t *iodef_assessment_get_next_time_impact(iodef_assessment_t *assessment, iodef_time_impact_t *time_impact_cur)
{
        libiodef_list_t *tmp = (time_impact_cur) ? &((libiodef_linked_object_t *) time_impact_cur)->_list : NULL;

        libiodef_return_val_if_fail(assessment, NULL);

        libiodef_list_for_each_continue(&assessment->time_impact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_assessment_set_time_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @object: pointer to a #iodef_time_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_time_impact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_assessment_set_time_impact(iodef_assessment_t *ptr, iodef_time_impact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->time_impact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_assessment_new_time_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_time_impact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_time_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_time_impact_t object. The created #iodef_time_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_time_impact(iodef_assessment_t *ptr, iodef_time_impact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_time_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->time_impact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_assessment_get_next_monetary_impact:
 * @assessment: pointer to a #iodef_assessment_t object.
 * @monetary_impact_cur: pointer to a #iodef_monetary_impact_t object.
 *
 * Get the next #iodef_monetary_impact_t object listed in @ptr.
 * When iterating over the iodef_monetary_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_monetary_impact_t object.
 *
 * Returns: the next #iodef_monetary_impact_t in the list.
 */
iodef_monetary_impact_t *iodef_assessment_get_next_monetary_impact(iodef_assessment_t *assessment, iodef_monetary_impact_t *monetary_impact_cur)
{
        libiodef_list_t *tmp = (monetary_impact_cur) ? &((libiodef_linked_object_t *) monetary_impact_cur)->_list : NULL;

        libiodef_return_val_if_fail(assessment, NULL);

        libiodef_list_for_each_continue(&assessment->monetary_impact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_assessment_set_monetary_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @object: pointer to a #iodef_monetary_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_monetary_impact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_assessment_set_monetary_impact(iodef_assessment_t *ptr, iodef_monetary_impact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->monetary_impact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_assessment_new_monetary_impact:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_monetary_impact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_monetary_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_monetary_impact_t object. The created #iodef_monetary_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_monetary_impact(iodef_assessment_t *ptr, iodef_monetary_impact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_monetary_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->monetary_impact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_assessment_get_next_counter:
 * @assessment: pointer to a #iodef_assessment_t object.
 * @counter_cur: pointer to a #iodef_counter_t object.
 *
 * Get the next #iodef_counter_t object listed in @ptr.
 * When iterating over the iodef_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_counter_t object.
 *
 * Returns: the next #iodef_counter_t in the list.
 */
iodef_counter_t *iodef_assessment_get_next_counter(iodef_assessment_t *assessment, iodef_counter_t *counter_cur)
{
        libiodef_list_t *tmp = (counter_cur) ? &((libiodef_linked_object_t *) counter_cur)->_list : NULL;

        libiodef_return_val_if_fail(assessment, NULL);

        libiodef_list_for_each_continue(&assessment->counter_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_assessment_set_counter:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @object: pointer to a #iodef_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_counter_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_assessment_set_counter(iodef_assessment_t *ptr, iodef_counter_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_assessment_new_counter:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_counter_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_counter_t object. The created #iodef_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_counter(iodef_assessment_t *ptr, iodef_counter_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_assessment_get_restriction:
 * @ptr: pointer to a #iodef_assessment_t object.
 *
 * Get restriction children of the #iodef_assessment_t object.
 *
 * Returns: a pointer to a iodef_assessment_restriction_t object, or NULL if the children object is not set.
 */
iodef_assessment_restriction_t iodef_assessment_get_restriction(iodef_assessment_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_assessment_set_restriction:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @restriction: pointer to a #iodef_assessment_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_assessment_set_restriction(iodef_assessment_t *ptr, iodef_assessment_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_assessment_new_restriction:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_assessment_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_assessment_t.
 * If @ptr already contain a #iodef_assessment_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_restriction(iodef_assessment_t *ptr, iodef_assessment_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_assessment_get_occurrence:
 * @ptr: pointer to a #iodef_assessment_t object.
 *
 * Get occurrence children of the #iodef_assessment_t object.
 *
 * Returns: a pointer to a iodef_assessment_occurrence_t object, or NULL if the children object is not set.
 */
iodef_assessment_occurrence_t iodef_assessment_get_occurrence(iodef_assessment_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->occurrence;
}

/**
 * iodef_assessment_set_occurrence:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @occurrence: pointer to a #iodef_assessment_occurrence_t object.
 *
 * Set @occurrence object as a children of @ptr.
 * if @ptr already contain an @occurrence object, then it is destroyed,
 * and updated to point to the provided @occurrence object.
 */

void iodef_assessment_set_occurrence(iodef_assessment_t *ptr, iodef_assessment_occurrence_t occurrence)
{
        libiodef_return_if_fail(ptr);
        ptr->occurrence = occurrence;
}

/**
 * iodef_assessment_new_occurrence:
 * @ptr: pointer to a #iodef_assessment_t object.
 * @ret: pointer to an address where to store the created #iodef_assessment_occurrence_t object.
 *
 * Create a new occurrence object, children of #iodef_assessment_t.
 * If @ptr already contain a #iodef_assessment_occurrence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_assessment_new_occurrence(iodef_assessment_t *ptr, iodef_assessment_occurrence_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->occurrence;
        return 0;
}

/**
 * iodef_assessment_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_assessment_copy(const iodef_assessment_t *src, iodef_assessment_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_impact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_impact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_impact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->impact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->confidence ) {
                iodef_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = iodef_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_time_impact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->time_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_time_impact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->time_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_time_impact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->time_impact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_monetary_impact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->monetary_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_monetary_impact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->monetary_impact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_monetary_impact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->monetary_impact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry, *new;

                libiodef_list_for_each_safe(&dst->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_clone(entry, &new);
                        libiodef_list_add_tail(&dst->counter_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        dst->occurrence = src->occurrence;

        return 0;
}

/**
 * iodef_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_assessment_clone(iodef_assessment_t *src, iodef_assessment_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_assessment_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_assessment_copy(src, *dst);
}

/**
 * iodef_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_assessment_compare(const iodef_assessment_t *obj1, const iodef_assessment_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_impact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->impact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->impact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_time_impact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->time_impact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->time_impact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_time_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_monetary_impact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->monetary_impact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->monetary_impact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_monetary_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_counter_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->counter_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        if ( obj1->occurrence != obj2->occurrence )
                return -1;

        return ret;
}

/**
 * iodef_service_new:
 * @ret: Pointer where to store the created #iodef_service_t object.
 *
 * Create a new #iodef_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_service_new(iodef_service_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_SERVICE;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->application_list);


        return 0;

}

/**
 * iodef_service_ref:
 * @service: pointer to a #iodef_service_t object.
 *
 * Increase @service reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @service.
 */
iodef_service_t *iodef_service_ref(iodef_service_t *service)
{
        libiodef_return_val_if_fail(service, NULL);
        service->refcount++;

        return service;
}

int _iodef_service_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_service_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return (ptr->proto_code_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->proto_code) : 0;

                case 1:
                       return (ptr->proto_flags_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->proto_flags) : 0;

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->portlist, TRUE);
                case 3:
                        *childptr = &ptr->application_list;
                        return 0;

                case 4:
                       return (ptr->proto_type_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->proto_type) : 0;

                case 5:
                       return (ptr->port_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->port) : 0;

                case 6:
                       return (ptr->ip_protocol_is_set) ? iodef_value_new_uint32((iodef_value_t **) childptr, ptr->ip_protocol) : 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_service_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_service_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_service_new_proto_code(ptr, (uint32_t **) ret);

                case 1:
                        return iodef_service_new_proto_flags(ptr, (uint32_t **) ret);

                case 2:
                        return iodef_service_new_portlist(ptr, (libiodef_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_service_new_application(ptr, (iodef_application_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->application_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->application_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_service_new_application(ptr, (iodef_application_t **) ret, n);
                }

                case 4:
                        return iodef_service_new_proto_type(ptr, (uint32_t **) ret);

                case 5:
                        return iodef_service_new_port(ptr, (uint32_t **) ret);

                case 6:
                        return iodef_service_new_ip_protocol(ptr, (uint32_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_service_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_service_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->proto_code_is_set = 0;
                        return 0;

                case 1:
                        ptr->proto_flags_is_set = 0;
                        return 0;

                case 2:
                        if ( ptr->portlist ) {
                                libiodef_string_destroy(ptr->portlist);
                                ptr->portlist = NULL;
                        }

                        return 0;

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->application_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_application_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->application_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_application_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4:
                        ptr->proto_type_is_set = 0;
                        return 0;

                case 5:
                        ptr->port_is_set = 0;
                        return 0;

                case 6:
                        ptr->ip_protocol_is_set = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_service_destroy_internal(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->portlist ) {
                libiodef_string_destroy(ptr->portlist);
                ptr->portlist = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_application_t *entry;

                libiodef_list_for_each_safe(&ptr->application_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_application_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_service_destroy:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_service_destroy(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_service_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_service_get_proto_code:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get proto_code children of the #iodef_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_service_get_proto_code(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_code_is_set ? &ptr->proto_code : NULL;
}

/**
 * iodef_service_set_proto_code:
 * @ptr: pointer to a #iodef_service_t object.
 * @proto_code: pointer to a #uint32_t object.
 *
 * Set @proto_code object as a children of @ptr.
 * if @ptr already contain an @proto_code object, then it is destroyed,
 * and updated to point to the provided @proto_code object.
 */

void iodef_service_set_proto_code(iodef_service_t *ptr, uint32_t proto_code)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_code = proto_code;
        ptr->proto_code_is_set = 1;
}


void iodef_service_unset_proto_code(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_code_is_set = 0;
}


/**
 * iodef_service_new_proto_code:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_code object, children of #iodef_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_proto_code(iodef_service_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->proto_code_is_set = 1;

        *ret = &ptr->proto_code;
        return 0;
}

/**
 * iodef_service_get_proto_flags:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get proto_flags children of the #iodef_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_service_get_proto_flags(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_flags_is_set ? &ptr->proto_flags : NULL;
}

/**
 * iodef_service_set_proto_flags:
 * @ptr: pointer to a #iodef_service_t object.
 * @proto_flags: pointer to a #uint32_t object.
 *
 * Set @proto_flags object as a children of @ptr.
 * if @ptr already contain an @proto_flags object, then it is destroyed,
 * and updated to point to the provided @proto_flags object.
 */

void iodef_service_set_proto_flags(iodef_service_t *ptr, uint32_t proto_flags)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_flags = proto_flags;
        ptr->proto_flags_is_set = 1;
}


void iodef_service_unset_proto_flags(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_flags_is_set = 0;
}


/**
 * iodef_service_new_proto_flags:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_flags object, children of #iodef_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_proto_flags(iodef_service_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->proto_flags_is_set = 1;

        *ret = &ptr->proto_flags;
        return 0;
}

/**
 * iodef_service_get_portlist:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get portlist children of the #iodef_service_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_service_get_portlist(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->portlist;
}

/**
 * iodef_service_set_portlist:
 * @ptr: pointer to a #iodef_service_t object.
 * @portlist: pointer to a #libiodef_string_t object.
 *
 * Set @portlist object as a children of @ptr.
 * if @ptr already contain an @portlist object, then it is destroyed,
 * and updated to point to the provided @portlist object.
 */

void iodef_service_set_portlist(iodef_service_t *ptr, libiodef_string_t *portlist)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->portlist )
                libiodef_string_destroy(ptr->portlist);

        ptr->portlist = portlist;
}

/**
 * iodef_service_new_portlist:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new portlist object, children of #iodef_service_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_portlist(iodef_service_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->portlist ) {
                retval = libiodef_string_new(&ptr->portlist);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->portlist;
        return 0;
}

/**
 * iodef_service_get_next_application:
 * @service: pointer to a #iodef_service_t object.
 * @application_cur: pointer to a #iodef_application_t object.
 *
 * Get the next #iodef_application_t object listed in @ptr.
 * When iterating over the iodef_application_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_application_t object.
 *
 * Returns: the next #iodef_application_t in the list.
 */
iodef_application_t *iodef_service_get_next_application(iodef_service_t *service, iodef_application_t *application_cur)
{
        libiodef_list_t *tmp = (application_cur) ? &((libiodef_linked_object_t *) application_cur)->_list : NULL;

        libiodef_return_val_if_fail(service, NULL);

        libiodef_list_for_each_continue(&service->application_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_service_set_application:
 * @ptr: pointer to a #iodef_service_t object.
 * @object: pointer to a #iodef_application_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_application_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_service_set_application(iodef_service_t *ptr, iodef_application_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->application_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_service_new_application:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #iodef_application_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_application_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_application_t object. The created #iodef_application_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_application(iodef_service_t *ptr, iodef_application_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_application_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->application_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_service_get_proto_type:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get proto_type children of the #iodef_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_service_get_proto_type(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_type_is_set ? &ptr->proto_type : NULL;
}

/**
 * iodef_service_set_proto_type:
 * @ptr: pointer to a #iodef_service_t object.
 * @proto_type: pointer to a #uint32_t object.
 *
 * Set @proto_type object as a children of @ptr.
 * if @ptr already contain an @proto_type object, then it is destroyed,
 * and updated to point to the provided @proto_type object.
 */

void iodef_service_set_proto_type(iodef_service_t *ptr, uint32_t proto_type)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_type = proto_type;
        ptr->proto_type_is_set = 1;
}


void iodef_service_unset_proto_type(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->proto_type_is_set = 0;
}


/**
 * iodef_service_new_proto_type:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_type object, children of #iodef_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_proto_type(iodef_service_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->proto_type_is_set = 1;

        *ret = &ptr->proto_type;
        return 0;
}

/**
 * iodef_service_get_port:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get port children of the #iodef_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_service_get_port(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->port_is_set ? &ptr->port : NULL;
}

/**
 * iodef_service_set_port:
 * @ptr: pointer to a #iodef_service_t object.
 * @port: pointer to a #uint32_t object.
 *
 * Set @port object as a children of @ptr.
 * if @ptr already contain an @port object, then it is destroyed,
 * and updated to point to the provided @port object.
 */

void iodef_service_set_port(iodef_service_t *ptr, uint32_t port)
{
        libiodef_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}


void iodef_service_unset_port(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->port_is_set = 0;
}


/**
 * iodef_service_new_port:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new port object, children of #iodef_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_port(iodef_service_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->port_is_set = 1;

        *ret = &ptr->port;
        return 0;
}

/**
 * iodef_service_get_ip_protocol:
 * @ptr: pointer to a #iodef_service_t object.
 *
 * Get ip_protocol children of the #iodef_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodef_service_get_ip_protocol(iodef_service_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ip_protocol_is_set ? &ptr->ip_protocol : NULL;
}

/**
 * iodef_service_set_ip_protocol:
 * @ptr: pointer to a #iodef_service_t object.
 * @ip_protocol: pointer to a #uint32_t object.
 *
 * Set @ip_protocol object as a children of @ptr.
 * if @ptr already contain an @ip_protocol object, then it is destroyed,
 * and updated to point to the provided @ip_protocol object.
 */

void iodef_service_set_ip_protocol(iodef_service_t *ptr, uint32_t ip_protocol)
{
        libiodef_return_if_fail(ptr);
        ptr->ip_protocol = ip_protocol;
        ptr->ip_protocol_is_set = 1;
}


void iodef_service_unset_ip_protocol(iodef_service_t *ptr)
{
        libiodef_return_if_fail(ptr);
        ptr->ip_protocol_is_set = 0;
}


/**
 * iodef_service_new_ip_protocol:
 * @ptr: pointer to a #iodef_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new ip_protocol object, children of #iodef_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_service_new_ip_protocol(iodef_service_t *ptr, uint32_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        ptr->ip_protocol_is_set = 1;

        *ret = &ptr->ip_protocol;
        return 0;
}

/**
 * iodef_service_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_service_copy(const iodef_service_t *src, iodef_service_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->proto_code_is_set = src->proto_code_is_set;

        dst->proto_code = src->proto_code;

        dst->proto_flags_is_set = src->proto_flags_is_set;

        dst->proto_flags = src->proto_flags;

        if ( dst->portlist ) {
                libiodef_string_destroy(dst->portlist);
                dst->portlist = NULL;
        }

        if ( src->portlist ) {
                ret = libiodef_string_clone(src->portlist, &dst->portlist);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_application_t *entry, *new;

                libiodef_list_for_each_safe(&dst->application_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_application_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->application_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_application_clone(entry, &new);
                        libiodef_list_add_tail(&dst->application_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->proto_type_is_set = src->proto_type_is_set;

        dst->proto_type = src->proto_type;

        dst->port_is_set = src->port_is_set;

        dst->port = src->port;

        dst->ip_protocol_is_set = src->ip_protocol_is_set;

        dst->ip_protocol = src->ip_protocol;

        return 0;
}

/**
 * iodef_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_service_clone(iodef_service_t *src, iodef_service_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_service_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_service_copy(src, *dst);
}

/**
 * iodef_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_service_compare(const iodef_service_t *obj1, const iodef_service_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->proto_code_is_set != obj2->proto_code_is_set )
                return -1;

        if ( obj1->proto_code_is_set && obj1->proto_code != obj2->proto_code )
                return -1;

        if ( obj1->proto_flags_is_set != obj2->proto_flags_is_set )
                return -1;

        if ( obj1->proto_flags_is_set && obj1->proto_flags != obj2->proto_flags )
                return -1;

        ret = libiodef_string_compare(obj1->portlist, obj2->portlist);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_application_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->application_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->application_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_application_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->proto_type_is_set != obj2->proto_type_is_set )
                return -1;

        if ( obj1->proto_type_is_set && obj1->proto_type != obj2->proto_type )
                return -1;

        if ( obj1->port_is_set != obj2->port_is_set )
                return -1;

        if ( obj1->port_is_set && obj1->port != obj2->port )
                return -1;

        if ( obj1->ip_protocol_is_set != obj2->ip_protocol_is_set )
                return -1;

        if ( obj1->ip_protocol_is_set && obj1->ip_protocol != obj2->ip_protocol )
                return -1;

        return ret;
}

/**
 * iodef_address_new:
 * @ret: Pointer where to store the created #iodef_address_t object.
 *
 * Create a new #iodef_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_address_new(iodef_address_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_ADDRESS;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_address_ref:
 * @address: pointer to a #iodef_address_t object.
 *
 * Increase @address reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @address.
 */
iodef_address_t *iodef_address_ref(iodef_address_t *address)
{
        libiodef_return_val_if_fail(address, NULL);
        address->refcount++;

        return address;
}

int _iodef_address_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_ADDRESS_CATEGORY, ptr->category);

                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->vlan_name, TRUE);
                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_category, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->vlan_num, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_address_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_address_new_category(ptr, (iodef_address_category_t **) ret);

                case 1:
                        return iodef_address_new_vlan_name(ptr, (libiodef_string_t **) ret);

                case 2:
                        return iodef_address_new_ext_category(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_address_new_vlan_num(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_address_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_address_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->category = 0;
                        return 0;

                case 1:
                        if ( ptr->vlan_name ) {
                                libiodef_string_destroy(ptr->vlan_name);
                                ptr->vlan_name = NULL;
                        }

                        return 0;

                case 2:
                        if ( ptr->ext_category ) {
                                libiodef_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->vlan_num ) {
                                libiodef_string_destroy(ptr->vlan_num);
                                ptr->vlan_num = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_address_destroy_internal(iodef_address_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->vlan_name ) {
                libiodef_string_destroy(ptr->vlan_name);
                ptr->vlan_name = NULL;
        }

        if ( ptr->ext_category ) {
                libiodef_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }

        if ( ptr->vlan_num ) {
                libiodef_string_destroy(ptr->vlan_num);
                ptr->vlan_num = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_address_destroy:
 * @ptr: pointer to a #iodef_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_address_destroy(iodef_address_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_address_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_address_get_category:
 * @ptr: pointer to a #iodef_address_t object.
 *
 * Get category children of the #iodef_address_t object.
 *
 * Returns: a pointer to a iodef_address_category_t object, or NULL if the children object is not set.
 */
iodef_address_category_t iodef_address_get_category(iodef_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;
}

/**
 * iodef_address_set_category:
 * @ptr: pointer to a #iodef_address_t object.
 * @category: pointer to a #iodef_address_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void iodef_address_set_category(iodef_address_t *ptr, iodef_address_category_t category)
{
        libiodef_return_if_fail(ptr);
        ptr->category = category;
}

/**
 * iodef_address_new_category:
 * @ptr: pointer to a #iodef_address_t object.
 * @ret: pointer to an address where to store the created #iodef_address_category_t object.
 *
 * Create a new category object, children of #iodef_address_t.
 * If @ptr already contain a #iodef_address_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_address_new_category(iodef_address_t *ptr, iodef_address_category_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->category;
        return 0;
}

/**
 * iodef_address_get_vlan_name:
 * @ptr: pointer to a #iodef_address_t object.
 *
 * Get vlan_name children of the #iodef_address_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_address_get_vlan_name(iodef_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_name;
}

/**
 * iodef_address_set_vlan_name:
 * @ptr: pointer to a #iodef_address_t object.
 * @vlan_name: pointer to a #libiodef_string_t object.
 *
 * Set @vlan_name object as a children of @ptr.
 * if @ptr already contain an @vlan_name object, then it is destroyed,
 * and updated to point to the provided @vlan_name object.
 */

void iodef_address_set_vlan_name(iodef_address_t *ptr, libiodef_string_t *vlan_name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->vlan_name )
                libiodef_string_destroy(ptr->vlan_name);

        ptr->vlan_name = vlan_name;
}

/**
 * iodef_address_new_vlan_name:
 * @ptr: pointer to a #iodef_address_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new vlan_name object, children of #iodef_address_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_address_new_vlan_name(iodef_address_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->vlan_name ) {
                retval = libiodef_string_new(&ptr->vlan_name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->vlan_name;
        return 0;
}

/**
 * iodef_address_get_ext_category:
 * @ptr: pointer to a #iodef_address_t object.
 *
 * Get ext_category children of the #iodef_address_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_address_get_ext_category(iodef_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;
}

/**
 * iodef_address_set_ext_category:
 * @ptr: pointer to a #iodef_address_t object.
 * @ext_category: pointer to a #libiodef_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodef_address_set_ext_category(iodef_address_t *ptr, libiodef_string_t *ext_category)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_category )
                libiodef_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}

/**
 * iodef_address_new_ext_category:
 * @ptr: pointer to a #iodef_address_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_category object, children of #iodef_address_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_address_new_ext_category(iodef_address_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodef_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_category;
        return 0;
}

/**
 * iodef_address_get_vlan_num:
 * @ptr: pointer to a #iodef_address_t object.
 *
 * Get vlan_num children of the #iodef_address_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_address_get_vlan_num(iodef_address_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_num;
}

/**
 * iodef_address_set_vlan_num:
 * @ptr: pointer to a #iodef_address_t object.
 * @vlan_num: pointer to a #libiodef_string_t object.
 *
 * Set @vlan_num object as a children of @ptr.
 * if @ptr already contain an @vlan_num object, then it is destroyed,
 * and updated to point to the provided @vlan_num object.
 */

void iodef_address_set_vlan_num(iodef_address_t *ptr, libiodef_string_t *vlan_num)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->vlan_num )
                libiodef_string_destroy(ptr->vlan_num);

        ptr->vlan_num = vlan_num;
}

/**
 * iodef_address_new_vlan_num:
 * @ptr: pointer to a #iodef_address_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new vlan_num object, children of #iodef_address_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_address_new_vlan_num(iodef_address_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->vlan_num ) {
                retval = libiodef_string_new(&ptr->vlan_num);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->vlan_num;
        return 0;
}

/**
 * iodef_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_address_copy(const iodef_address_t *src, iodef_address_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->category = src->category;

        if ( dst->vlan_name ) {
                libiodef_string_destroy(dst->vlan_name);
                dst->vlan_name = NULL;
        }

        if ( src->vlan_name ) {
                ret = libiodef_string_clone(src->vlan_name, &dst->vlan_name);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->ext_category ) {
                libiodef_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodef_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->vlan_num ) {
                libiodef_string_destroy(dst->vlan_num);
                dst->vlan_num = NULL;
        }

        if ( src->vlan_num ) {
                ret = libiodef_string_clone(src->vlan_num, &dst->vlan_num);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_address_clone(iodef_address_t *src, iodef_address_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_address_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_address_copy(src, *dst);
}

/**
 * iodef_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_address_compare(const iodef_address_t *obj1, const iodef_address_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->category != obj2->category )
                return -1;

        ret = libiodef_string_compare(obj1->vlan_name, obj2->vlan_name);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->vlan_num, obj2->vlan_num);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_node_role_new:
 * @ret: Pointer where to store the created #iodef_node_role_t object.
 *
 * Create a new #iodef_node_role_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_role_new(iodef_node_role_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_NODE_ROLE;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_node_role_ref:
 * @node_role: pointer to a #iodef_node_role_t object.
 *
 * Increase @node_role reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node_role.
 */
iodef_node_role_t *iodef_node_role_ref(iodef_node_role_t *node_role)
{
        libiodef_return_val_if_fail(node_role, NULL);
        node_role->refcount++;

        return node_role;
}

int _iodef_node_role_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_node_role_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_NODE_ROLE_CATEGORY, ptr->category);

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_NODE_ROLE_LANG, ptr->lang);

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_category, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_node_role_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_node_role_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_node_role_new_category(ptr, (iodef_node_role_category_t **) ret);

                case 1:
                        return iodef_node_role_new_lang(ptr, (iodef_node_role_lang_t **) ret);

                case 2:
                        return iodef_node_role_new_ext_category(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_node_role_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_node_role_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        ptr->category = 0;
                        return 0;

                case 1:
                        ptr->lang = 0;
                        return 0;

                case 2:
                        if ( ptr->ext_category ) {
                                libiodef_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_node_role_destroy_internal(iodef_node_role_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->ext_category ) {
                libiodef_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_node_role_destroy:
 * @ptr: pointer to a #iodef_node_role_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_node_role_destroy(iodef_node_role_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_node_role_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_node_role_get_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 *
 * Get category children of the #iodef_node_role_t object.
 *
 * Returns: a pointer to a iodef_node_role_category_t object, or NULL if the children object is not set.
 */
iodef_node_role_category_t iodef_node_role_get_category(iodef_node_role_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;
}

/**
 * iodef_node_role_set_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @category: pointer to a #iodef_node_role_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void iodef_node_role_set_category(iodef_node_role_t *ptr, iodef_node_role_category_t category)
{
        libiodef_return_if_fail(ptr);
        ptr->category = category;
}

/**
 * iodef_node_role_new_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @ret: pointer to an address where to store the created #iodef_node_role_category_t object.
 *
 * Create a new category object, children of #iodef_node_role_t.
 * If @ptr already contain a #iodef_node_role_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_role_new_category(iodef_node_role_t *ptr, iodef_node_role_category_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->category;
        return 0;
}

/**
 * iodef_node_role_get_lang:
 * @ptr: pointer to a #iodef_node_role_t object.
 *
 * Get lang children of the #iodef_node_role_t object.
 *
 * Returns: a pointer to a iodef_node_role_lang_t object, or NULL if the children object is not set.
 */
iodef_node_role_lang_t iodef_node_role_get_lang(iodef_node_role_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;
}

/**
 * iodef_node_role_set_lang:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @lang: pointer to a #iodef_node_role_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */

void iodef_node_role_set_lang(iodef_node_role_t *ptr, iodef_node_role_lang_t lang)
{
        libiodef_return_if_fail(ptr);
        ptr->lang = lang;
}

/**
 * iodef_node_role_new_lang:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @ret: pointer to an address where to store the created #iodef_node_role_lang_t object.
 *
 * Create a new lang object, children of #iodef_node_role_t.
 * If @ptr already contain a #iodef_node_role_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_role_new_lang(iodef_node_role_t *ptr, iodef_node_role_lang_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->lang;
        return 0;
}

/**
 * iodef_node_role_get_ext_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 *
 * Get ext_category children of the #iodef_node_role_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_node_role_get_ext_category(iodef_node_role_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;
}

/**
 * iodef_node_role_set_ext_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @ext_category: pointer to a #libiodef_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodef_node_role_set_ext_category(iodef_node_role_t *ptr, libiodef_string_t *ext_category)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_category )
                libiodef_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}

/**
 * iodef_node_role_new_ext_category:
 * @ptr: pointer to a #iodef_node_role_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_category object, children of #iodef_node_role_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_role_new_ext_category(iodef_node_role_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodef_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_category;
        return 0;
}

/**
 * iodef_node_role_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_node_role_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_role_copy(const iodef_node_role_t *src, iodef_node_role_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        dst->category = src->category;

        dst->lang = src->lang;

        if ( dst->ext_category ) {
                libiodef_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodef_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_node_role_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_role_clone(iodef_node_role_t *src, iodef_node_role_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_node_role_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_node_role_copy(src, *dst);
}

/**
 * iodef_node_role_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_node_role_compare(const iodef_node_role_t *obj1, const iodef_node_role_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        if ( obj1->category != obj2->category )
                return -1;

        if ( obj1->lang != obj2->lang )
                return -1;

        ret = libiodef_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_node_new:
 * @ret: Pointer where to store the created #iodef_node_t object.
 *
 * Create a new #iodef_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_new(iodef_node_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_NODE;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->node_name_list);


        libiodef_list_init(&(*ret)->counter_list);


        libiodef_list_init(&(*ret)->node_role_list);


        libiodef_list_init(&(*ret)->address_list);


        return 0;

}

/**
 * iodef_node_ref:
 * @node: pointer to a #iodef_node_t object.
 *
 * Increase @node reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node.
 */
iodef_node_t *iodef_node_ref(iodef_node_t *node)
{
        libiodef_return_val_if_fail(node, NULL);
        node->refcount++;

        return node;
}

int _iodef_node_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_node_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->node_name_list;
                        return 0;

                case 1:
                        *childptr = &ptr->counter_list;
                        return 0;

                case 2:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->date_time, TRUE);
                case 3:
                        *childptr = &ptr->node_role_list;
                        return 0;

                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->location, TRUE);
                case 5:
                        *childptr = &ptr->address_list;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_node_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_node_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_node_new_node_name(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->node_name_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->node_name_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_node_new_node_name(ptr, (libiodef_string_t **) ret, n);
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_node_new_counter(ptr, (iodef_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_node_new_counter(ptr, (iodef_counter_t **) ret, n);
                }

                case 2:
                        return iodef_node_new_date_time(ptr, (iodef_time_t **) ret);

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_node_new_node_role(ptr, (iodef_node_role_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->node_role_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_node_new_node_role(ptr, (iodef_node_role_t **) ret, n);
                }

                case 4:
                        return iodef_node_new_location(ptr, (libiodef_string_t **) ret);

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_node_new_address(ptr, (iodef_address_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->address_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->address_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_node_new_address(ptr, (iodef_address_t **) ret, n);
                }

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_node_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_node_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->node_name_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->node_name_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        if ( ptr->date_time ) {
                                iodef_time_destroy(ptr->date_time);
                                ptr->date_time = NULL;
                        }

                        return 0;

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->node_role_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_node_role_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_node_role_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4:
                        if ( ptr->location ) {
                                libiodef_string_destroy(ptr->location);
                                ptr->location = NULL;
                        }

                        return 0;

                case 5: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->address_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_address_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->address_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_address_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_node_destroy_internal(iodef_node_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->node_name_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry;

                libiodef_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_counter_destroy(entry);
                }
        }

        if ( ptr->date_time ) {
                iodef_time_destroy(ptr->date_time);
                ptr->date_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_node_role_t *entry;

                libiodef_list_for_each_safe(&ptr->node_role_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_node_role_destroy(entry);
                }
        }

        if ( ptr->location ) {
                libiodef_string_destroy(ptr->location);
                ptr->location = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_address_t *entry;

                libiodef_list_for_each_safe(&ptr->address_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_address_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_node_destroy:
 * @ptr: pointer to a #iodef_node_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_node_destroy(iodef_node_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_node_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_node_get_next_node_name:
 * @node: pointer to a #iodef_node_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_node_get_next_node_name(iodef_node_t *node, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(node, NULL);

        libiodef_list_for_each_continue(&node->node_name_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_node_set_node_name:
 * @ptr: pointer to a #iodef_node_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_node_set_node_name(iodef_node_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->node_name_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_node_new_node_name:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_node_name(iodef_node_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->node_name_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_node_get_next_counter:
 * @node: pointer to a #iodef_node_t object.
 * @counter_cur: pointer to a #iodef_counter_t object.
 *
 * Get the next #iodef_counter_t object listed in @ptr.
 * When iterating over the iodef_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_counter_t object.
 *
 * Returns: the next #iodef_counter_t in the list.
 */
iodef_counter_t *iodef_node_get_next_counter(iodef_node_t *node, iodef_counter_t *counter_cur)
{
        libiodef_list_t *tmp = (counter_cur) ? &((libiodef_linked_object_t *) counter_cur)->_list : NULL;

        libiodef_return_val_if_fail(node, NULL);

        libiodef_list_for_each_continue(&node->counter_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_node_set_counter:
 * @ptr: pointer to a #iodef_node_t object.
 * @object: pointer to a #iodef_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_counter_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_node_set_counter(iodef_node_t *ptr, iodef_counter_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_node_new_counter:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #iodef_counter_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_counter_t object. The created #iodef_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_counter(iodef_node_t *ptr, iodef_counter_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_node_get_date_time:
 * @ptr: pointer to a #iodef_node_t object.
 *
 * Get date_time children of the #iodef_node_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_node_get_date_time(iodef_node_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_time;
}

/**
 * iodef_node_set_date_time:
 * @ptr: pointer to a #iodef_node_t object.
 * @date_time: pointer to a #iodef_time_t object.
 *
 * Set @date_time object as a children of @ptr.
 * if @ptr already contain an @date_time object, then it is destroyed,
 * and updated to point to the provided @date_time object.
 */

void iodef_node_set_date_time(iodef_node_t *ptr, iodef_time_t *date_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->date_time )
                iodef_time_destroy(ptr->date_time);

        ptr->date_time = date_time;
}

/**
 * iodef_node_new_date_time:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new date_time object, children of #iodef_node_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_date_time(iodef_node_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->date_time ) {
                retval = iodef_time_new(&ptr->date_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->date_time;
        return 0;
}

/**
 * iodef_node_get_next_node_role:
 * @node: pointer to a #iodef_node_t object.
 * @node_role_cur: pointer to a #iodef_node_role_t object.
 *
 * Get the next #iodef_node_role_t object listed in @ptr.
 * When iterating over the iodef_node_role_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_node_role_t object.
 *
 * Returns: the next #iodef_node_role_t in the list.
 */
iodef_node_role_t *iodef_node_get_next_node_role(iodef_node_t *node, iodef_node_role_t *node_role_cur)
{
        libiodef_list_t *tmp = (node_role_cur) ? &((libiodef_linked_object_t *) node_role_cur)->_list : NULL;

        libiodef_return_val_if_fail(node, NULL);

        libiodef_list_for_each_continue(&node->node_role_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_node_set_node_role:
 * @ptr: pointer to a #iodef_node_t object.
 * @object: pointer to a #iodef_node_role_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_node_role_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_node_set_node_role(iodef_node_t *ptr, iodef_node_role_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->node_role_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_node_new_node_role:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #iodef_node_role_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_node_role_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_node_role_t object. The created #iodef_node_role_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_node_role(iodef_node_t *ptr, iodef_node_role_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_node_role_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->node_role_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_node_get_location:
 * @ptr: pointer to a #iodef_node_t object.
 *
 * Get location children of the #iodef_node_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_node_get_location(iodef_node_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->location;
}

/**
 * iodef_node_set_location:
 * @ptr: pointer to a #iodef_node_t object.
 * @location: pointer to a #libiodef_string_t object.
 *
 * Set @location object as a children of @ptr.
 * if @ptr already contain an @location object, then it is destroyed,
 * and updated to point to the provided @location object.
 */

void iodef_node_set_location(iodef_node_t *ptr, libiodef_string_t *location)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->location )
                libiodef_string_destroy(ptr->location);

        ptr->location = location;
}

/**
 * iodef_node_new_location:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new location object, children of #iodef_node_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_location(iodef_node_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->location ) {
                retval = libiodef_string_new(&ptr->location);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->location;
        return 0;
}

/**
 * iodef_node_get_next_address:
 * @node: pointer to a #iodef_node_t object.
 * @address_cur: pointer to a #iodef_address_t object.
 *
 * Get the next #iodef_address_t object listed in @ptr.
 * When iterating over the iodef_address_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_address_t object.
 *
 * Returns: the next #iodef_address_t in the list.
 */
iodef_address_t *iodef_node_get_next_address(iodef_node_t *node, iodef_address_t *address_cur)
{
        libiodef_list_t *tmp = (address_cur) ? &((libiodef_linked_object_t *) address_cur)->_list : NULL;

        libiodef_return_val_if_fail(node, NULL);

        libiodef_list_for_each_continue(&node->address_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_node_set_address:
 * @ptr: pointer to a #iodef_node_t object.
 * @object: pointer to a #iodef_address_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_address_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_node_set_address(iodef_node_t *ptr, iodef_address_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->address_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_node_new_address:
 * @ptr: pointer to a #iodef_node_t object.
 * @ret: pointer to an address where to store the created #iodef_address_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_address_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_address_t object. The created #iodef_address_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_node_new_address(iodef_node_t *ptr, iodef_address_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_address_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->address_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_node_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_copy(const iodef_node_t *src, iodef_node_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->node_name_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->node_name_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->node_name_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry, *new;

                libiodef_list_for_each_safe(&dst->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_clone(entry, &new);
                        libiodef_list_add_tail(&dst->counter_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->date_time ) {
                iodef_time_destroy(dst->date_time);
                dst->date_time = NULL;
        }

        if ( src->date_time ) {
                ret = iodef_time_clone(src->date_time, &dst->date_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_node_role_t *entry, *new;

                libiodef_list_for_each_safe(&dst->node_role_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_node_role_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->node_role_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_node_role_clone(entry, &new);
                        libiodef_list_add_tail(&dst->node_role_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->location ) {
                libiodef_string_destroy(dst->location);
                dst->location = NULL;
        }

        if ( src->location ) {
                ret = libiodef_string_clone(src->location, &dst->location);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_address_t *entry, *new;

                libiodef_list_for_each_safe(&dst->address_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_address_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->address_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_address_clone(entry, &new);
                        libiodef_list_add_tail(&dst->address_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        return 0;
}

/**
 * iodef_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_node_clone(iodef_node_t *src, iodef_node_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_node_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_node_copy(src, *dst);
}

/**
 * iodef_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_node_compare(const iodef_node_t *obj1, const iodef_node_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->node_name_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->node_name_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_counter_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->counter_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->date_time, obj2->date_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_node_role_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->node_role_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->node_role_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_node_role_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = libiodef_string_compare(obj1->location, obj2->location);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_address_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->address_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->address_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_address_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        return ret;
}

/**
 * iodef_operating_system_new:
 * @ret: Pointer where to store the created #iodef_operating_system_t object.
 *
 * Create a new #iodef_operating_system_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_operating_system_new(iodef_operating_system_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_OPERATING_SYSTEM;

        (*ret)->refcount = 1;

        return 0;

}

/**
 * iodef_operating_system_ref:
 * @operating_system: pointer to a #iodef_operating_system_t object.
 *
 * Increase @operating_system reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @operating_system.
 */
iodef_operating_system_t *iodef_operating_system_ref(iodef_operating_system_t *operating_system)
{
        libiodef_return_val_if_fail(operating_system, NULL);
        operating_system->refcount++;

        return operating_system;
}

int _iodef_operating_system_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_operating_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->url, TRUE);
                case 1:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->vendor, TRUE);
                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->name, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->family, TRUE);
                case 4:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->swid, TRUE);
                case 5:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->patch, TRUE);
                case 6:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->version, TRUE);
                case 7:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->configid, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_operating_system_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_operating_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_operating_system_new_url(ptr, (libiodef_string_t **) ret);

                case 1:
                        return iodef_operating_system_new_vendor(ptr, (libiodef_string_t **) ret);

                case 2:
                        return iodef_operating_system_new_name(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_operating_system_new_family(ptr, (libiodef_string_t **) ret);

                case 4:
                        return iodef_operating_system_new_swid(ptr, (libiodef_string_t **) ret);

                case 5:
                        return iodef_operating_system_new_patch(ptr, (libiodef_string_t **) ret);

                case 6:
                        return iodef_operating_system_new_version(ptr, (libiodef_string_t **) ret);

                case 7:
                        return iodef_operating_system_new_configid(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_operating_system_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_operating_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->url ) {
                                libiodef_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

                case 1:
                        if ( ptr->vendor ) {
                                libiodef_string_destroy(ptr->vendor);
                                ptr->vendor = NULL;
                        }

                        return 0;

                case 2:
                        if ( ptr->name ) {
                                libiodef_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->family ) {
                                libiodef_string_destroy(ptr->family);
                                ptr->family = NULL;
                        }

                        return 0;

                case 4:
                        if ( ptr->swid ) {
                                libiodef_string_destroy(ptr->swid);
                                ptr->swid = NULL;
                        }

                        return 0;

                case 5:
                        if ( ptr->patch ) {
                                libiodef_string_destroy(ptr->patch);
                                ptr->patch = NULL;
                        }

                        return 0;

                case 6:
                        if ( ptr->version ) {
                                libiodef_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;

                case 7:
                        if ( ptr->configid ) {
                                libiodef_string_destroy(ptr->configid);
                                ptr->configid = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_operating_system_destroy_internal(iodef_operating_system_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->url ) {
                libiodef_string_destroy(ptr->url);
                ptr->url = NULL;
        }

        if ( ptr->vendor ) {
                libiodef_string_destroy(ptr->vendor);
                ptr->vendor = NULL;
        }

        if ( ptr->name ) {
                libiodef_string_destroy(ptr->name);
                ptr->name = NULL;
        }

        if ( ptr->family ) {
                libiodef_string_destroy(ptr->family);
                ptr->family = NULL;
        }

        if ( ptr->swid ) {
                libiodef_string_destroy(ptr->swid);
                ptr->swid = NULL;
        }

        if ( ptr->patch ) {
                libiodef_string_destroy(ptr->patch);
                ptr->patch = NULL;
        }

        if ( ptr->version ) {
                libiodef_string_destroy(ptr->version);
                ptr->version = NULL;
        }

        if ( ptr->configid ) {
                libiodef_string_destroy(ptr->configid);
                ptr->configid = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_operating_system_destroy:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_operating_system_destroy(iodef_operating_system_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_operating_system_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_operating_system_get_url:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get url children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_url(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;
}

/**
 * iodef_operating_system_set_url:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @url: pointer to a #libiodef_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodef_operating_system_set_url(iodef_operating_system_t *ptr, libiodef_string_t *url)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->url )
                libiodef_string_destroy(ptr->url);

        ptr->url = url;
}

/**
 * iodef_operating_system_new_url:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new url object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_url(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodef_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->url;
        return 0;
}

/**
 * iodef_operating_system_get_vendor:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get vendor children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_vendor(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vendor;
}

/**
 * iodef_operating_system_set_vendor:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @vendor: pointer to a #libiodef_string_t object.
 *
 * Set @vendor object as a children of @ptr.
 * if @ptr already contain an @vendor object, then it is destroyed,
 * and updated to point to the provided @vendor object.
 */

void iodef_operating_system_set_vendor(iodef_operating_system_t *ptr, libiodef_string_t *vendor)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->vendor )
                libiodef_string_destroy(ptr->vendor);

        ptr->vendor = vendor;
}

/**
 * iodef_operating_system_new_vendor:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new vendor object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_vendor(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->vendor ) {
                retval = libiodef_string_new(&ptr->vendor);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->vendor;
        return 0;
}

/**
 * iodef_operating_system_get_name:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get name children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_name(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;
}

/**
 * iodef_operating_system_set_name:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @name: pointer to a #libiodef_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodef_operating_system_set_name(iodef_operating_system_t *ptr, libiodef_string_t *name)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->name )
                libiodef_string_destroy(ptr->name);

        ptr->name = name;
}

/**
 * iodef_operating_system_new_name:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new name object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_name(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodef_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->name;
        return 0;
}

/**
 * iodef_operating_system_get_family:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get family children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_family(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->family;
}

/**
 * iodef_operating_system_set_family:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @family: pointer to a #libiodef_string_t object.
 *
 * Set @family object as a children of @ptr.
 * if @ptr already contain an @family object, then it is destroyed,
 * and updated to point to the provided @family object.
 */

void iodef_operating_system_set_family(iodef_operating_system_t *ptr, libiodef_string_t *family)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->family )
                libiodef_string_destroy(ptr->family);

        ptr->family = family;
}

/**
 * iodef_operating_system_new_family:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new family object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_family(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->family ) {
                retval = libiodef_string_new(&ptr->family);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->family;
        return 0;
}

/**
 * iodef_operating_system_get_swid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get swid children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_swid(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->swid;
}

/**
 * iodef_operating_system_set_swid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @swid: pointer to a #libiodef_string_t object.
 *
 * Set @swid object as a children of @ptr.
 * if @ptr already contain an @swid object, then it is destroyed,
 * and updated to point to the provided @swid object.
 */

void iodef_operating_system_set_swid(iodef_operating_system_t *ptr, libiodef_string_t *swid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->swid )
                libiodef_string_destroy(ptr->swid);

        ptr->swid = swid;
}

/**
 * iodef_operating_system_new_swid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new swid object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_swid(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->swid ) {
                retval = libiodef_string_new(&ptr->swid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->swid;
        return 0;
}

/**
 * iodef_operating_system_get_patch:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get patch children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_patch(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->patch;
}

/**
 * iodef_operating_system_set_patch:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @patch: pointer to a #libiodef_string_t object.
 *
 * Set @patch object as a children of @ptr.
 * if @ptr already contain an @patch object, then it is destroyed,
 * and updated to point to the provided @patch object.
 */

void iodef_operating_system_set_patch(iodef_operating_system_t *ptr, libiodef_string_t *patch)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->patch )
                libiodef_string_destroy(ptr->patch);

        ptr->patch = patch;
}

/**
 * iodef_operating_system_new_patch:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new patch object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_patch(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->patch ) {
                retval = libiodef_string_new(&ptr->patch);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->patch;
        return 0;
}

/**
 * iodef_operating_system_get_version:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get version children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_version(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;
}

/**
 * iodef_operating_system_set_version:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @version: pointer to a #libiodef_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodef_operating_system_set_version(iodef_operating_system_t *ptr, libiodef_string_t *version)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->version )
                libiodef_string_destroy(ptr->version);

        ptr->version = version;
}

/**
 * iodef_operating_system_new_version:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new version object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_version(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodef_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->version;
        return 0;
}

/**
 * iodef_operating_system_get_configid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 *
 * Get configid children of the #iodef_operating_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_operating_system_get_configid(iodef_operating_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->configid;
}

/**
 * iodef_operating_system_set_configid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @configid: pointer to a #libiodef_string_t object.
 *
 * Set @configid object as a children of @ptr.
 * if @ptr already contain an @configid object, then it is destroyed,
 * and updated to point to the provided @configid object.
 */

void iodef_operating_system_set_configid(iodef_operating_system_t *ptr, libiodef_string_t *configid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->configid )
                libiodef_string_destroy(ptr->configid);

        ptr->configid = configid;
}

/**
 * iodef_operating_system_new_configid:
 * @ptr: pointer to a #iodef_operating_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new configid object, children of #iodef_operating_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_operating_system_new_configid(iodef_operating_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->configid ) {
                retval = libiodef_string_new(&ptr->configid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->configid;
        return 0;
}

/**
 * iodef_operating_system_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_operating_system_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_operating_system_copy(const iodef_operating_system_t *src, iodef_operating_system_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->url ) {
                libiodef_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodef_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->vendor ) {
                libiodef_string_destroy(dst->vendor);
                dst->vendor = NULL;
        }

        if ( src->vendor ) {
                ret = libiodef_string_clone(src->vendor, &dst->vendor);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->name ) {
                libiodef_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libiodef_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->family ) {
                libiodef_string_destroy(dst->family);
                dst->family = NULL;
        }

        if ( src->family ) {
                ret = libiodef_string_clone(src->family, &dst->family);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->swid ) {
                libiodef_string_destroy(dst->swid);
                dst->swid = NULL;
        }

        if ( src->swid ) {
                ret = libiodef_string_clone(src->swid, &dst->swid);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->patch ) {
                libiodef_string_destroy(dst->patch);
                dst->patch = NULL;
        }

        if ( src->patch ) {
                ret = libiodef_string_clone(src->patch, &dst->patch);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->version ) {
                libiodef_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libiodef_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->configid ) {
                libiodef_string_destroy(dst->configid);
                dst->configid = NULL;
        }

        if ( src->configid ) {
                ret = libiodef_string_clone(src->configid, &dst->configid);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_operating_system_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_operating_system_clone(iodef_operating_system_t *src, iodef_operating_system_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_operating_system_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_operating_system_copy(src, *dst);
}

/**
 * iodef_operating_system_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_operating_system_compare(const iodef_operating_system_t *obj1, const iodef_operating_system_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = libiodef_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->vendor, obj2->vendor);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->family, obj2->family);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->swid, obj2->swid);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->patch, obj2->patch);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->configid, obj2->configid);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_system_new:
 * @ret: Pointer where to store the created #iodef_system_t object.
 *
 * Create a new #iodef_system_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_system_new(iodef_system_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_SYSTEM;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->service_list);


        libiodef_list_init(&(*ret)->counter_list);


        {
                int retval = iodef_node_new(&(*ret)->node);

                if ( retval < 0 ) {
                        iodef_system_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_system_ref:
 * @system: pointer to a #iodef_system_t object.
 *
 * Increase @system reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @system.
 */
iodef_system_t *iodef_system_ref(iodef_system_t *system)
{
        libiodef_return_val_if_fail(system, NULL);
        system->refcount++;

        return system;
}

int _iodef_system_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = ptr->node;
                        return 0;

                case 1:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 2:
                        *childptr = &ptr->description_list;
                        return 0;

                case 3:
                        *childptr = &ptr->service_list;
                        return 0;

                case 4:
                        *childptr = &ptr->counter_list;
                        return 0;

                case 5:
                        *childptr = ptr->operating_system;
                        return 0;

                case 6:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_SYSTEM_CATEGORY, ptr->category);

                case 7:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_SYSTEM_RESTRICTION, ptr->restriction);

                case 8:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_category, TRUE);
                case 9:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_SYSTEM_SPOOFED, ptr->spoofed);

                case 10:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->interface, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_system_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_system_new_node(ptr, (iodef_node_t **) ret);

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_system_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_system_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_system_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_system_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_system_new_service(ptr, (iodef_service_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->service_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->service_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_system_new_service(ptr, (iodef_service_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_system_new_counter(ptr, (iodef_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_system_new_counter(ptr, (iodef_counter_t **) ret, n);
                }

                case 5:
                        return iodef_system_new_operating_system(ptr, (iodef_operating_system_t **) ret);

                case 6:
                        return iodef_system_new_category(ptr, (iodef_system_category_t **) ret);

                case 7:
                        return iodef_system_new_restriction(ptr, (iodef_system_restriction_t **) ret);

                case 8:
                        return iodef_system_new_ext_category(ptr, (libiodef_string_t **) ret);

                case 9:
                        return iodef_system_new_spoofed(ptr, (iodef_system_spoofed_t **) ret);

                case 10:
                        return iodef_system_new_interface(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_system_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_system_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->node ) {
                                iodef_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->service_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_service_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->service_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_service_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_counter_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 5:
                        if ( ptr->operating_system ) {
                                iodef_operating_system_destroy(ptr->operating_system);
                                ptr->operating_system = NULL;
                        }

                        return 0;

                case 6:
                        ptr->category = 0;
                        return 0;

                case 7:
                        ptr->restriction = 0;
                        return 0;

                case 8:
                        if ( ptr->ext_category ) {
                                libiodef_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;

                case 9:
                        ptr->spoofed = 0;
                        return 0;

                case 10:
                        if ( ptr->interface ) {
                                libiodef_string_destroy(ptr->interface);
                                ptr->interface = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_system_destroy_internal(iodef_system_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->node ) {
                iodef_node_destroy(ptr->node);
                ptr->node = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_service_t *entry;

                libiodef_list_for_each_safe(&ptr->service_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_service_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry;

                libiodef_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_counter_destroy(entry);
                }
        }

        if ( ptr->operating_system ) {
                iodef_operating_system_destroy(ptr->operating_system);
                ptr->operating_system = NULL;
        }

        if ( ptr->ext_category ) {
                libiodef_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }

        if ( ptr->interface ) {
                libiodef_string_destroy(ptr->interface);
                ptr->interface = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_system_destroy:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_system_destroy(iodef_system_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_system_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_system_get_node:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get node children of the #iodef_system_t object.
 *
 * Returns: a pointer to a iodef_node_t object, or NULL if the children object is not set.
 */
iodef_node_t *iodef_system_get_node(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;
}

/**
 * iodef_system_set_node:
 * @ptr: pointer to a #iodef_system_t object.
 * @node: pointer to a #iodef_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void iodef_system_set_node(iodef_system_t *ptr, iodef_node_t *node)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->node )
                iodef_node_destroy(ptr->node);

        ptr->node = node;
}

/**
 * iodef_system_new_node:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_node_t object.
 *
 * Create a new node object, children of #iodef_system_t.
 * If @ptr already contain a #iodef_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_node(iodef_system_t *ptr, iodef_node_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = iodef_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->node;
        return 0;
}

/**
 * iodef_system_get_next_additional_data:
 * @system: pointer to a #iodef_system_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_system_get_next_additional_data(iodef_system_t *system, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(system, NULL);

        libiodef_list_for_each_continue(&system->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_system_set_additional_data:
 * @ptr: pointer to a #iodef_system_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_system_set_additional_data(iodef_system_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_system_new_additional_data:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_additional_data(iodef_system_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_system_get_next_description:
 * @system: pointer to a #iodef_system_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_system_get_next_description(iodef_system_t *system, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(system, NULL);

        libiodef_list_for_each_continue(&system->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_system_set_description:
 * @ptr: pointer to a #iodef_system_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_system_set_description(iodef_system_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_system_new_description:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_description(iodef_system_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_system_get_next_service:
 * @system: pointer to a #iodef_system_t object.
 * @service_cur: pointer to a #iodef_service_t object.
 *
 * Get the next #iodef_service_t object listed in @ptr.
 * When iterating over the iodef_service_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_service_t object.
 *
 * Returns: the next #iodef_service_t in the list.
 */
iodef_service_t *iodef_system_get_next_service(iodef_system_t *system, iodef_service_t *service_cur)
{
        libiodef_list_t *tmp = (service_cur) ? &((libiodef_linked_object_t *) service_cur)->_list : NULL;

        libiodef_return_val_if_fail(system, NULL);

        libiodef_list_for_each_continue(&system->service_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_system_set_service:
 * @ptr: pointer to a #iodef_system_t object.
 * @object: pointer to a #iodef_service_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_service_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_system_set_service(iodef_system_t *ptr, iodef_service_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->service_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_system_new_service:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_service_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_service_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_service_t object. The created #iodef_service_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_service(iodef_system_t *ptr, iodef_service_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_service_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->service_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_system_get_next_counter:
 * @system: pointer to a #iodef_system_t object.
 * @counter_cur: pointer to a #iodef_counter_t object.
 *
 * Get the next #iodef_counter_t object listed in @ptr.
 * When iterating over the iodef_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_counter_t object.
 *
 * Returns: the next #iodef_counter_t in the list.
 */
iodef_counter_t *iodef_system_get_next_counter(iodef_system_t *system, iodef_counter_t *counter_cur)
{
        libiodef_list_t *tmp = (counter_cur) ? &((libiodef_linked_object_t *) counter_cur)->_list : NULL;

        libiodef_return_val_if_fail(system, NULL);

        libiodef_list_for_each_continue(&system->counter_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_system_set_counter:
 * @ptr: pointer to a #iodef_system_t object.
 * @object: pointer to a #iodef_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_counter_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_system_set_counter(iodef_system_t *ptr, iodef_counter_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_system_new_counter:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_counter_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_counter_t object. The created #iodef_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_counter(iodef_system_t *ptr, iodef_counter_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_system_get_operating_system:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get operating_system children of the #iodef_system_t object.
 *
 * Returns: a pointer to a iodef_operating_system_t object, or NULL if the children object is not set.
 */
iodef_operating_system_t *iodef_system_get_operating_system(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->operating_system;
}

/**
 * iodef_system_set_operating_system:
 * @ptr: pointer to a #iodef_system_t object.
 * @operating_system: pointer to a #iodef_operating_system_t object.
 *
 * Set @operating_system object as a children of @ptr.
 * if @ptr already contain an @operating_system object, then it is destroyed,
 * and updated to point to the provided @operating_system object.
 */

void iodef_system_set_operating_system(iodef_system_t *ptr, iodef_operating_system_t *operating_system)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->operating_system )
                iodef_operating_system_destroy(ptr->operating_system);

        ptr->operating_system = operating_system;
}

/**
 * iodef_system_new_operating_system:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_operating_system_t object.
 *
 * Create a new operating_system object, children of #iodef_system_t.
 * If @ptr already contain a #iodef_operating_system_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_operating_system(iodef_system_t *ptr, iodef_operating_system_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->operating_system ) {
                retval = iodef_operating_system_new(&ptr->operating_system);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->operating_system;
        return 0;
}

/**
 * iodef_system_get_category:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get category children of the #iodef_system_t object.
 *
 * Returns: a pointer to a iodef_system_category_t object, or NULL if the children object is not set.
 */
iodef_system_category_t iodef_system_get_category(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;
}

/**
 * iodef_system_set_category:
 * @ptr: pointer to a #iodef_system_t object.
 * @category: pointer to a #iodef_system_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */

void iodef_system_set_category(iodef_system_t *ptr, iodef_system_category_t category)
{
        libiodef_return_if_fail(ptr);
        ptr->category = category;
}

/**
 * iodef_system_new_category:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_system_category_t object.
 *
 * Create a new category object, children of #iodef_system_t.
 * If @ptr already contain a #iodef_system_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_category(iodef_system_t *ptr, iodef_system_category_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->category;
        return 0;
}

/**
 * iodef_system_get_restriction:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get restriction children of the #iodef_system_t object.
 *
 * Returns: a pointer to a iodef_system_restriction_t object, or NULL if the children object is not set.
 */
iodef_system_restriction_t iodef_system_get_restriction(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_system_set_restriction:
 * @ptr: pointer to a #iodef_system_t object.
 * @restriction: pointer to a #iodef_system_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_system_set_restriction(iodef_system_t *ptr, iodef_system_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_system_new_restriction:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_system_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_system_t.
 * If @ptr already contain a #iodef_system_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_restriction(iodef_system_t *ptr, iodef_system_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_system_get_ext_category:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get ext_category children of the #iodef_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_system_get_ext_category(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;
}

/**
 * iodef_system_set_ext_category:
 * @ptr: pointer to a #iodef_system_t object.
 * @ext_category: pointer to a #libiodef_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodef_system_set_ext_category(iodef_system_t *ptr, libiodef_string_t *ext_category)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_category )
                libiodef_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}

/**
 * iodef_system_new_ext_category:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_category object, children of #iodef_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_ext_category(iodef_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodef_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_category;
        return 0;
}

/**
 * iodef_system_get_spoofed:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get spoofed children of the #iodef_system_t object.
 *
 * Returns: a pointer to a iodef_system_spoofed_t object, or NULL if the children object is not set.
 */
iodef_system_spoofed_t iodef_system_get_spoofed(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->spoofed;
}

/**
 * iodef_system_set_spoofed:
 * @ptr: pointer to a #iodef_system_t object.
 * @spoofed: pointer to a #iodef_system_spoofed_t object.
 *
 * Set @spoofed object as a children of @ptr.
 * if @ptr already contain an @spoofed object, then it is destroyed,
 * and updated to point to the provided @spoofed object.
 */

void iodef_system_set_spoofed(iodef_system_t *ptr, iodef_system_spoofed_t spoofed)
{
        libiodef_return_if_fail(ptr);
        ptr->spoofed = spoofed;
}

/**
 * iodef_system_new_spoofed:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #iodef_system_spoofed_t object.
 *
 * Create a new spoofed object, children of #iodef_system_t.
 * If @ptr already contain a #iodef_system_spoofed_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_spoofed(iodef_system_t *ptr, iodef_system_spoofed_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->spoofed;
        return 0;
}

/**
 * iodef_system_get_interface:
 * @ptr: pointer to a #iodef_system_t object.
 *
 * Get interface children of the #iodef_system_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_system_get_interface(iodef_system_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->interface;
}

/**
 * iodef_system_set_interface:
 * @ptr: pointer to a #iodef_system_t object.
 * @interface: pointer to a #libiodef_string_t object.
 *
 * Set @interface object as a children of @ptr.
 * if @ptr already contain an @interface object, then it is destroyed,
 * and updated to point to the provided @interface object.
 */

void iodef_system_set_interface(iodef_system_t *ptr, libiodef_string_t *interface)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->interface )
                libiodef_string_destroy(ptr->interface);

        ptr->interface = interface;
}

/**
 * iodef_system_new_interface:
 * @ptr: pointer to a #iodef_system_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new interface object, children of #iodef_system_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_system_new_interface(iodef_system_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->interface ) {
                retval = libiodef_string_new(&ptr->interface);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->interface;
        return 0;
}

/**
 * iodef_system_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_system_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_system_copy(const iodef_system_t *src, iodef_system_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( src->node ) {
                ret = iodef_node_copy(src->node, dst->node);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_service_t *entry, *new;

                libiodef_list_for_each_safe(&dst->service_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_service_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->service_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_service_clone(entry, &new);
                        libiodef_list_add_tail(&dst->service_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_counter_t *entry, *new;

                libiodef_list_for_each_safe(&dst->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->counter_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_counter_clone(entry, &new);
                        libiodef_list_add_tail(&dst->counter_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->operating_system ) {
                iodef_operating_system_destroy(dst->operating_system);
                dst->operating_system = NULL;
        }

        if ( src->operating_system ) {
                ret = iodef_operating_system_clone(src->operating_system, &dst->operating_system);
                if ( ret < 0 )
                        return ret;
        }

        dst->category = src->category;

        dst->restriction = src->restriction;

        if ( dst->ext_category ) {
                libiodef_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodef_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }

        dst->spoofed = src->spoofed;

        if ( dst->interface ) {
                libiodef_string_destroy(dst->interface);
                dst->interface = NULL;
        }

        if ( src->interface ) {
                ret = libiodef_string_clone(src->interface, &dst->interface);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_system_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_system_clone(iodef_system_t *src, iodef_system_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_system_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_system_copy(src, *dst);
}

/**
 * iodef_system_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_system_compare(const iodef_system_t *obj1, const iodef_system_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = iodef_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_service_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->service_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->service_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_service_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_counter_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->counter_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_operating_system_compare(obj1->operating_system, obj2->operating_system);
        if ( ret != 0 )
                return ret;

        if ( obj1->category != obj2->category )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        ret = libiodef_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;

        if ( obj1->spoofed != obj2->spoofed )
                return -1;

        ret = libiodef_string_compare(obj1->interface, obj2->interface);
        if ( ret != 0 )
                return ret;

        return ret;
}

/**
 * iodef_flow_new:
 * @ret: Pointer where to store the created #iodef_flow_t object.
 *
 * Create a new #iodef_flow_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_flow_new(iodef_flow_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_FLOW;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->system_list);


        return 0;

}

/**
 * iodef_flow_ref:
 * @flow: pointer to a #iodef_flow_t object.
 *
 * Increase @flow reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @flow.
 */
iodef_flow_t *iodef_flow_ref(iodef_flow_t *flow)
{
        libiodef_return_val_if_fail(flow, NULL);
        flow->refcount++;

        return flow;
}

int _iodef_flow_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_flow_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->system_list;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_flow_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_flow_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_flow_new_system(ptr, (iodef_system_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->system_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->system_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_flow_new_system(ptr, (iodef_system_t **) ret, n);
                }

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_flow_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_flow_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->system_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_system_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->system_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_system_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_flow_destroy_internal(iodef_flow_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        {
                libiodef_list_t *n, *tmp;
                iodef_system_t *entry;

                libiodef_list_for_each_safe(&ptr->system_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_system_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_flow_destroy:
 * @ptr: pointer to a #iodef_flow_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_flow_destroy(iodef_flow_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_flow_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_flow_get_next_system:
 * @flow: pointer to a #iodef_flow_t object.
 * @system_cur: pointer to a #iodef_system_t object.
 *
 * Get the next #iodef_system_t object listed in @ptr.
 * When iterating over the iodef_system_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_system_t object.
 *
 * Returns: the next #iodef_system_t in the list.
 */
iodef_system_t *iodef_flow_get_next_system(iodef_flow_t *flow, iodef_system_t *system_cur)
{
        libiodef_list_t *tmp = (system_cur) ? &((libiodef_linked_object_t *) system_cur)->_list : NULL;

        libiodef_return_val_if_fail(flow, NULL);

        libiodef_list_for_each_continue(&flow->system_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_flow_set_system:
 * @ptr: pointer to a #iodef_flow_t object.
 * @object: pointer to a #iodef_system_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_system_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_flow_set_system(iodef_flow_t *ptr, iodef_system_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->system_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_flow_new_system:
 * @ptr: pointer to a #iodef_flow_t object.
 * @ret: pointer to an address where to store the created #iodef_system_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_system_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_system_t object. The created #iodef_system_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_flow_new_system(iodef_flow_t *ptr, iodef_system_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_system_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->system_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_flow_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_flow_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_flow_copy(const iodef_flow_t *src, iodef_flow_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_system_t *entry, *new;

                libiodef_list_for_each_safe(&dst->system_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_system_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->system_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_system_clone(entry, &new);
                        libiodef_list_add_tail(&dst->system_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        return 0;
}

/**
 * iodef_flow_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_flow_clone(iodef_flow_t *src, iodef_flow_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_flow_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_flow_copy(src, *dst);
}

/**
 * iodef_flow_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_flow_compare(const iodef_flow_t *obj1, const iodef_flow_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_system_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->system_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->system_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_system_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        return ret;
}

/**
 * iodef_event_data_new:
 * @ret: Pointer where to store the created #iodef_event_data_t object.
 *
 * Create a new #iodef_event_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_event_data_new(iodef_event_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_EVENT_DATA;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->flow_list);


        libiodef_list_init(&(*ret)->expectation_list);


        libiodef_list_init(&(*ret)->contact_list);


        libiodef_list_init(&(*ret)->event_data_list);


        libiodef_list_init(&(*ret)->method_list);


        return 0;

}

/**
 * iodef_event_data_ref:
 * @event_data: pointer to a #iodef_event_data_t object.
 *
 * Increase @event_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @event_data.
 */
iodef_event_data_t *iodef_event_data_ref(iodef_event_data_t *event_data)
{
        libiodef_return_val_if_fail(event_data, NULL);
        event_data->refcount++;

        return event_data;
}

int _iodef_event_data_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_event_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->detect_time, TRUE);
                case 1:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 2:
                        *childptr = &ptr->description_list;
                        return 0;

                case 3:
                        *childptr = &ptr->flow_list;
                        return 0;

                case 4:
                        *childptr = &ptr->expectation_list;
                        return 0;

                case 5:
                        *childptr = ptr->record;
                        return 0;

                case 6:
                        *childptr = &ptr->contact_list;
                        return 0;

                case 7:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->start_time, TRUE);
                case 8:
                        *childptr = &ptr->event_data_list;
                        return 0;

                case 9:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->end_time, TRUE);
                case 10:
                        *childptr = ptr->assessment;
                        return 0;

                case 11:
                        *childptr = &ptr->method_list;
                        return 0;

                case 12:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_EVENT_DATA_RESTRICTION, ptr->restriction);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_event_data_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_event_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_event_data_new_detect_time(ptr, (iodef_time_t **) ret);

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_flow(ptr, (iodef_flow_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->flow_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->flow_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_flow(ptr, (iodef_flow_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_expectation(ptr, (iodef_expectation_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->expectation_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->expectation_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_expectation(ptr, (iodef_expectation_t **) ret, n);
                }

                case 5:
                        return iodef_event_data_new_record(ptr, (iodef_record_t **) ret);

                case 6: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_contact(ptr, (iodef_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_contact(ptr, (iodef_contact_t **) ret, n);
                }

                case 7:
                        return iodef_event_data_new_start_time(ptr, (iodef_time_t **) ret);

                case 8: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_event_data(ptr, (iodef_event_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->event_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_event_data(ptr, (iodef_event_data_t **) ret, n);
                }

                case 9:
                        return iodef_event_data_new_end_time(ptr, (iodef_time_t **) ret);

                case 10:
                        return iodef_event_data_new_assessment(ptr, (iodef_assessment_t **) ret);

                case 11: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_event_data_new_method(ptr, (iodef_method_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_event_data_new_method(ptr, (iodef_method_t **) ret, n);
                }

                case 12:
                        return iodef_event_data_new_restriction(ptr, (iodef_event_data_restriction_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_event_data_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_event_data_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->detect_time ) {
                                iodef_time_destroy(ptr->detect_time);
                                ptr->detect_time = NULL;
                        }

                        return 0;

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->flow_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_flow_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->flow_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_flow_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->expectation_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_expectation_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->expectation_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_expectation_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 5:
                        if ( ptr->record ) {
                                iodef_record_destroy(ptr->record);
                                ptr->record = NULL;
                        }

                        return 0;

                case 6: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 7:
                        if ( ptr->start_time ) {
                                iodef_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;

                case 8: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->event_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_event_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_event_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 9:
                        if ( ptr->end_time ) {
                                iodef_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;

                case 10:
                        if ( ptr->assessment ) {
                                iodef_assessment_destroy(ptr->assessment);
                                ptr->assessment = NULL;
                        }

                        return 0;

                case 11: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_method_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_method_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 12:
                        ptr->restriction = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_event_data_destroy_internal(iodef_event_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->detect_time ) {
                iodef_time_destroy(ptr->detect_time);
                ptr->detect_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_flow_t *entry;

                libiodef_list_for_each_safe(&ptr->flow_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_flow_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_expectation_t *entry;

                libiodef_list_for_each_safe(&ptr->expectation_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_expectation_destroy(entry);
                }
        }

        if ( ptr->record ) {
                iodef_record_destroy(ptr->record);
                ptr->record = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry;

                libiodef_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_contact_destroy(entry);
                }
        }

        if ( ptr->start_time ) {
                iodef_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_event_data_t *entry;

                libiodef_list_for_each_safe(&ptr->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_event_data_destroy(entry);
                }
        }

        if ( ptr->end_time ) {
                iodef_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }

        if ( ptr->assessment ) {
                iodef_assessment_destroy(ptr->assessment);
                ptr->assessment = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_method_t *entry;

                libiodef_list_for_each_safe(&ptr->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_method_destroy(entry);
                }
        }


        /* free() should be done by the caller */
}

/**
 * iodef_event_data_destroy:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_event_data_destroy(iodef_event_data_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_event_data_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_event_data_get_detect_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get detect_time children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_event_data_get_detect_time(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detect_time;
}

/**
 * iodef_event_data_set_detect_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @detect_time: pointer to a #iodef_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void iodef_event_data_set_detect_time(iodef_event_data_t *ptr, iodef_time_t *detect_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->detect_time )
                iodef_time_destroy(ptr->detect_time);

        ptr->detect_time = detect_time;
}

/**
 * iodef_event_data_new_detect_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new detect_time object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_detect_time(iodef_event_data_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->detect_time ) {
                retval = iodef_time_new(&ptr->detect_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->detect_time;
        return 0;
}

/**
 * iodef_event_data_get_next_additional_data:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_event_data_get_next_additional_data(iodef_event_data_t *event_data, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_additional_data:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_additional_data(iodef_event_data_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_additional_data:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_additional_data(iodef_event_data_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_next_description:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_event_data_get_next_description(iodef_event_data_t *event_data, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_description:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_description(iodef_event_data_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_description:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_description(iodef_event_data_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_next_flow:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @flow_cur: pointer to a #iodef_flow_t object.
 *
 * Get the next #iodef_flow_t object listed in @ptr.
 * When iterating over the iodef_flow_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_flow_t object.
 *
 * Returns: the next #iodef_flow_t in the list.
 */
iodef_flow_t *iodef_event_data_get_next_flow(iodef_event_data_t *event_data, iodef_flow_t *flow_cur)
{
        libiodef_list_t *tmp = (flow_cur) ? &((libiodef_linked_object_t *) flow_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->flow_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_flow:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_flow_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_flow_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_flow(iodef_event_data_t *ptr, iodef_flow_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->flow_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_flow:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_flow_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_flow_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_flow_t object. The created #iodef_flow_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_flow(iodef_event_data_t *ptr, iodef_flow_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_flow_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->flow_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_next_expectation:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @expectation_cur: pointer to a #iodef_expectation_t object.
 *
 * Get the next #iodef_expectation_t object listed in @ptr.
 * When iterating over the iodef_expectation_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_expectation_t object.
 *
 * Returns: the next #iodef_expectation_t in the list.
 */
iodef_expectation_t *iodef_event_data_get_next_expectation(iodef_event_data_t *event_data, iodef_expectation_t *expectation_cur)
{
        libiodef_list_t *tmp = (expectation_cur) ? &((libiodef_linked_object_t *) expectation_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->expectation_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_expectation:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_expectation_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_expectation_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_expectation(iodef_event_data_t *ptr, iodef_expectation_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->expectation_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_expectation:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_expectation_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_expectation_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_expectation_t object. The created #iodef_expectation_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_expectation(iodef_event_data_t *ptr, iodef_expectation_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_expectation_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->expectation_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_record:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get record children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_record_t object, or NULL if the children object is not set.
 */
iodef_record_t *iodef_event_data_get_record(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->record;
}

/**
 * iodef_event_data_set_record:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @record: pointer to a #iodef_record_t object.
 *
 * Set @record object as a children of @ptr.
 * if @ptr already contain an @record object, then it is destroyed,
 * and updated to point to the provided @record object.
 */

void iodef_event_data_set_record(iodef_event_data_t *ptr, iodef_record_t *record)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->record )
                iodef_record_destroy(ptr->record);

        ptr->record = record;
}

/**
 * iodef_event_data_new_record:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_record_t object.
 *
 * Create a new record object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_record_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_record(iodef_event_data_t *ptr, iodef_record_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->record ) {
                retval = iodef_record_new(&ptr->record);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->record;
        return 0;
}

/**
 * iodef_event_data_get_next_contact:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @contact_cur: pointer to a #iodef_contact_t object.
 *
 * Get the next #iodef_contact_t object listed in @ptr.
 * When iterating over the iodef_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_contact_t object.
 *
 * Returns: the next #iodef_contact_t in the list.
 */
iodef_contact_t *iodef_event_data_get_next_contact(iodef_event_data_t *event_data, iodef_contact_t *contact_cur)
{
        libiodef_list_t *tmp = (contact_cur) ? &((libiodef_linked_object_t *) contact_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->contact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_contact:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_contact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_contact(iodef_event_data_t *ptr, iodef_contact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_contact:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_contact_t object. The created #iodef_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_contact(iodef_event_data_t *ptr, iodef_contact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_start_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get start_time children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_event_data_get_start_time(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;
}

/**
 * iodef_event_data_set_start_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @start_time: pointer to a #iodef_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodef_event_data_set_start_time(iodef_event_data_t *ptr, iodef_time_t *start_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->start_time )
                iodef_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}

/**
 * iodef_event_data_new_start_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new start_time object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_start_time(iodef_event_data_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodef_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->start_time;
        return 0;
}

/**
 * iodef_event_data_get_next_event_data:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @event_data_cur: pointer to a #iodef_event_data_t object.
 *
 * Get the next #iodef_event_data_t object listed in @ptr.
 * When iterating over the iodef_event_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_event_data_t object.
 *
 * Returns: the next #iodef_event_data_t in the list.
 */
iodef_event_data_t *iodef_event_data_get_next_event_data(iodef_event_data_t *event_data, iodef_event_data_t *event_data_cur)
{
        libiodef_list_t *tmp = (event_data_cur) ? &((libiodef_linked_object_t *) event_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->event_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_event_data:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_event_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_event_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_event_data(iodef_event_data_t *ptr, iodef_event_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->event_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_event_data:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_event_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_event_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_event_data_t object. The created #iodef_event_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_event_data(iodef_event_data_t *ptr, iodef_event_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_event_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->event_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_end_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get end_time children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_event_data_get_end_time(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;
}

/**
 * iodef_event_data_set_end_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @end_time: pointer to a #iodef_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodef_event_data_set_end_time(iodef_event_data_t *ptr, iodef_time_t *end_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->end_time )
                iodef_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}

/**
 * iodef_event_data_new_end_time:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new end_time object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_end_time(iodef_event_data_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodef_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->end_time;
        return 0;
}

/**
 * iodef_event_data_get_assessment:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get assessment children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_assessment_t object, or NULL if the children object is not set.
 */
iodef_assessment_t *iodef_event_data_get_assessment(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->assessment;
}

/**
 * iodef_event_data_set_assessment:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @assessment: pointer to a #iodef_assessment_t object.
 *
 * Set @assessment object as a children of @ptr.
 * if @ptr already contain an @assessment object, then it is destroyed,
 * and updated to point to the provided @assessment object.
 */

void iodef_event_data_set_assessment(iodef_event_data_t *ptr, iodef_assessment_t *assessment)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->assessment )
                iodef_assessment_destroy(ptr->assessment);

        ptr->assessment = assessment;
}

/**
 * iodef_event_data_new_assessment:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_assessment_t object.
 *
 * Create a new assessment object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_assessment_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_assessment(iodef_event_data_t *ptr, iodef_assessment_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->assessment ) {
                retval = iodef_assessment_new(&ptr->assessment);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->assessment;
        return 0;
}

/**
 * iodef_event_data_get_next_method:
 * @event_data: pointer to a #iodef_event_data_t object.
 * @method_cur: pointer to a #iodef_method_t object.
 *
 * Get the next #iodef_method_t object listed in @ptr.
 * When iterating over the iodef_method_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_method_t object.
 *
 * Returns: the next #iodef_method_t in the list.
 */
iodef_method_t *iodef_event_data_get_next_method(iodef_event_data_t *event_data, iodef_method_t *method_cur)
{
        libiodef_list_t *tmp = (method_cur) ? &((libiodef_linked_object_t *) method_cur)->_list : NULL;

        libiodef_return_val_if_fail(event_data, NULL);

        libiodef_list_for_each_continue(&event_data->method_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_event_data_set_method:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @object: pointer to a #iodef_method_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_method_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_event_data_set_method(iodef_event_data_t *ptr, iodef_method_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->method_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_event_data_new_method:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_method_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_method_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_method_t object. The created #iodef_method_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_method(iodef_event_data_t *ptr, iodef_method_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_method_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->method_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_event_data_get_restriction:
 * @ptr: pointer to a #iodef_event_data_t object.
 *
 * Get restriction children of the #iodef_event_data_t object.
 *
 * Returns: a pointer to a iodef_event_data_restriction_t object, or NULL if the children object is not set.
 */
iodef_event_data_restriction_t iodef_event_data_get_restriction(iodef_event_data_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_event_data_set_restriction:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @restriction: pointer to a #iodef_event_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_event_data_set_restriction(iodef_event_data_t *ptr, iodef_event_data_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_event_data_new_restriction:
 * @ptr: pointer to a #iodef_event_data_t object.
 * @ret: pointer to an address where to store the created #iodef_event_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_event_data_t.
 * If @ptr already contain a #iodef_event_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_event_data_new_restriction(iodef_event_data_t *ptr, iodef_event_data_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_event_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_event_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_event_data_copy(const iodef_event_data_t *src, iodef_event_data_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->detect_time ) {
                iodef_time_destroy(dst->detect_time);
                dst->detect_time = NULL;
        }

        if ( src->detect_time ) {
                ret = iodef_time_clone(src->detect_time, &dst->detect_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_flow_t *entry, *new;

                libiodef_list_for_each_safe(&dst->flow_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_flow_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->flow_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_flow_clone(entry, &new);
                        libiodef_list_add_tail(&dst->flow_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_expectation_t *entry, *new;

                libiodef_list_for_each_safe(&dst->expectation_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_expectation_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->expectation_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_expectation_clone(entry, &new);
                        libiodef_list_add_tail(&dst->expectation_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->record ) {
                iodef_record_destroy(dst->record);
                dst->record = NULL;
        }

        if ( src->record ) {
                ret = iodef_record_clone(src->record, &dst->record);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->contact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->start_time ) {
                iodef_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodef_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_event_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_event_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_event_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->event_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->end_time ) {
                iodef_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodef_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->assessment ) {
                iodef_assessment_destroy(dst->assessment);
                dst->assessment = NULL;
        }

        if ( src->assessment ) {
                ret = iodef_assessment_clone(src->assessment, &dst->assessment);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_method_t *entry, *new;

                libiodef_list_for_each_safe(&dst->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_method_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_method_clone(entry, &new);
                        libiodef_list_add_tail(&dst->method_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->restriction = src->restriction;

        return 0;
}

/**
 * iodef_event_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_event_data_clone(iodef_event_data_t *src, iodef_event_data_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_event_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_event_data_copy(src, *dst);
}

/**
 * iodef_event_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_event_data_compare(const iodef_event_data_t *obj1, const iodef_event_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = iodef_time_compare(obj1->detect_time, obj2->detect_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_flow_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->flow_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->flow_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_flow_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_expectation_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->expectation_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->expectation_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_expectation_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_record_compare(obj1->record, obj2->record);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_contact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->contact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_event_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->event_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->event_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_event_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;

        ret = iodef_assessment_compare(obj1->assessment, obj2->assessment);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_method_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->method_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->method_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_method_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}

/**
 * iodef_incident_new:
 * @ret: Pointer where to store the created #iodef_incident_t object.
 *
 * Create a new #iodef_incident_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_new(iodef_incident_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_INCIDENT;

        libiodef_list_init(&((libiodef_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->additional_data_list);


        libiodef_list_init(&(*ret)->description_list);


        libiodef_list_init(&(*ret)->contact_list);


        libiodef_list_init(&(*ret)->event_data_list);


        libiodef_list_init(&(*ret)->assessment_list);


        libiodef_list_init(&(*ret)->method_list);


        {
                int retval = iodef_time_new(&(*ret)->report_time);

                if ( retval < 0 ) {
                        iodef_incident_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        iodef_time_set_from_gettimeofday((*ret)->report_time);

        {
                int retval = iodef_incident_id_new(&(*ret)->incident_id);

                if ( retval < 0 ) {
                        iodef_incident_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_incident_ref:
 * @incident: pointer to a #iodef_incident_t object.
 *
 * Increase @incident reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @incident.
 */
iodef_incident_t *iodef_incident_ref(iodef_incident_t *incident)
{
        libiodef_return_val_if_fail(incident, NULL);
        incident->refcount++;

        return incident;
}

int _iodef_incident_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_incident_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->detect_time, TRUE);
                case 1:
                        *childptr = &ptr->additional_data_list;
                        return 0;

                case 2:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->end_time, TRUE);
                case 3:
                        *childptr = &ptr->description_list;
                        return 0;

                case 4:
                        *childptr = &ptr->contact_list;
                        return 0;

                case 5:
                        *childptr = ptr->alternative_id;
                        return 0;

                case 6:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->report_time, TRUE);
                case 7:
                       return get_value_from_time((iodef_value_t **) childptr,  ptr->start_time, TRUE);
                case 8:
                        *childptr = &ptr->event_data_list;
                        return 0;

                case 9:
                        *childptr = ptr->related_activity;
                        return 0;

                case 10:
                        *childptr = ptr->incident_id;
                        return 0;

                case 11:
                        *childptr = &ptr->assessment_list;
                        return 0;

                case 12:
                        *childptr = &ptr->method_list;
                        return 0;

                case 13:
                        *childptr = ptr->history;
                        return 0;

                case 14:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_INCIDENT_LANG, ptr->lang);

                case 15:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_INCIDENT_RESTRICTION, ptr->restriction);

                case 16:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->ext_purpose, TRUE);
                case 17:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_INCIDENT_PURPOSE, ptr->purpose);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_incident_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_incident_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        return iodef_incident_new_detect_time(ptr, (iodef_time_t **) ret);

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_additional_data(ptr, (iodef_additional_data_t **) ret, n);
                }

                case 2:
                        return iodef_incident_new_end_time(ptr, (iodef_time_t **) ret);

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_description(ptr, (libiodef_string_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_description(ptr, (libiodef_string_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_contact(ptr, (iodef_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_contact(ptr, (iodef_contact_t **) ret, n);
                }

                case 5:
                        return iodef_incident_new_alternative_id(ptr, (iodef_alternative_id_t **) ret);

                case 6:
                        return iodef_incident_new_report_time(ptr, (iodef_time_t **) ret);

                case 7:
                        return iodef_incident_new_start_time(ptr, (iodef_time_t **) ret);

                case 8: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_event_data(ptr, (iodef_event_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->event_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_event_data(ptr, (iodef_event_data_t **) ret, n);
                }

                case 9:
                        return iodef_incident_new_related_activity(ptr, (iodef_related_activity_t **) ret);

                case 10:
                        return iodef_incident_new_incident_id(ptr, (iodef_incident_id_t **) ret);

                case 11: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_assessment(ptr, (iodef_assessment_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->assessment_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->assessment_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_assessment(ptr, (iodef_assessment_t **) ret, n);
                }

                case 12: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_incident_new_method(ptr, (iodef_method_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_incident_new_method(ptr, (iodef_method_t **) ret, n);
                }

                case 13:
                        return iodef_incident_new_history(ptr, (iodef_history_t **) ret);

                case 14:
                        return iodef_incident_new_lang(ptr, (iodef_incident_lang_t **) ret);

                case 15:
                        return iodef_incident_new_restriction(ptr, (iodef_incident_restriction_t **) ret);

                case 16:
                        return iodef_incident_new_ext_purpose(ptr, (libiodef_string_t **) ret);

                case 17:
                        return iodef_incident_new_purpose(ptr, (iodef_incident_purpose_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_incident_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_incident_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0:
                        if ( ptr->detect_time ) {
                                iodef_time_destroy(ptr->detect_time);
                                ptr->detect_time = NULL;
                        }

                        return 0;

                case 1: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_additional_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 2:
                        if ( ptr->end_time ) {
                                iodef_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;

                case 3: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->description_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->description_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               libiodef_string_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 4: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_contact_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 5:
                        if ( ptr->alternative_id ) {
                                iodef_alternative_id_destroy(ptr->alternative_id);
                                ptr->alternative_id = NULL;
                        }

                        return 0;

                case 6:
                        if ( ptr->report_time ) {
                                iodef_time_destroy(ptr->report_time);
                                ptr->report_time = NULL;
                        }

                        return 0;

                case 7:
                        if ( ptr->start_time ) {
                                iodef_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;

                case 8: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->event_data_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_event_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_event_data_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 9:
                        if ( ptr->related_activity ) {
                                iodef_related_activity_destroy(ptr->related_activity);
                                ptr->related_activity = NULL;
                        }

                        return 0;

                case 10:
                        if ( ptr->incident_id ) {
                                iodef_incident_id_destroy(ptr->incident_id);
                                ptr->incident_id = NULL;
                        }

                        return 0;

                case 11: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->assessment_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_assessment_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->assessment_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_assessment_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 12: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_method_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_method_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 13:
                        if ( ptr->history ) {
                                iodef_history_destroy(ptr->history);
                                ptr->history = NULL;
                        }

                        return 0;

                case 14:
                        ptr->lang = 0;
                        return 0;

                case 15:
                        ptr->restriction = 0;
                        return 0;

                case 16:
                        if ( ptr->ext_purpose ) {
                                libiodef_string_destroy(ptr->ext_purpose);
                                ptr->ext_purpose = NULL;
                        }

                        return 0;

                case 17:
                        ptr->purpose = 0;
                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_incident_destroy_internal(iodef_incident_t *ptr)
{
        libiodef_return_if_fail(ptr);

       if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *)ptr)->_list) )
               libiodef_list_del_init(&((libiodef_linked_object_t *)ptr)->_list);
    
        if ( ptr->detect_time ) {
                iodef_time_destroy(ptr->detect_time);
                ptr->detect_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry;

                libiodef_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_additional_data_destroy(entry);
                }
        }

        if ( ptr->end_time ) {
                iodef_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry;

                libiodef_list_for_each_safe(&ptr->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        libiodef_string_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry;

                libiodef_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_contact_destroy(entry);
                }
        }

        if ( ptr->alternative_id ) {
                iodef_alternative_id_destroy(ptr->alternative_id);
                ptr->alternative_id = NULL;
        }

        if ( ptr->report_time ) {
                iodef_time_destroy(ptr->report_time);
                ptr->report_time = NULL;
        }

        if ( ptr->start_time ) {
                iodef_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_event_data_t *entry;

                libiodef_list_for_each_safe(&ptr->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_event_data_destroy(entry);
                }
        }

        if ( ptr->related_activity ) {
                iodef_related_activity_destroy(ptr->related_activity);
                ptr->related_activity = NULL;
        }

        if ( ptr->incident_id ) {
                iodef_incident_id_destroy(ptr->incident_id);
                ptr->incident_id = NULL;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_assessment_t *entry;

                libiodef_list_for_each_safe(&ptr->assessment_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_assessment_destroy(entry);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_method_t *entry;

                libiodef_list_for_each_safe(&ptr->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_method_destroy(entry);
                }
        }

        if ( ptr->history ) {
                iodef_history_destroy(ptr->history);
                ptr->history = NULL;
        }

        if ( ptr->ext_purpose ) {
                libiodef_string_destroy(ptr->ext_purpose);
                ptr->ext_purpose = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_incident_destroy:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */

void iodef_incident_destroy(iodef_incident_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_incident_destroy_internal(ptr);
        free(ptr);
}

/**
 * iodef_incident_get_detect_time:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get detect_time children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_incident_get_detect_time(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detect_time;
}

/**
 * iodef_incident_set_detect_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @detect_time: pointer to a #iodef_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void iodef_incident_set_detect_time(iodef_incident_t *ptr, iodef_time_t *detect_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->detect_time )
                iodef_time_destroy(ptr->detect_time);

        ptr->detect_time = detect_time;
}

/**
 * iodef_incident_new_detect_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new detect_time object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_detect_time(iodef_incident_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->detect_time ) {
                retval = iodef_time_new(&ptr->detect_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->detect_time;
        return 0;
}

/**
 * iodef_incident_get_next_additional_data:
 * @incident: pointer to a #iodef_incident_t object.
 * @additional_data_cur: pointer to a #iodef_additional_data_t object.
 *
 * Get the next #iodef_additional_data_t object listed in @ptr.
 * When iterating over the iodef_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_additional_data_t object.
 *
 * Returns: the next #iodef_additional_data_t in the list.
 */
iodef_additional_data_t *iodef_incident_get_next_additional_data(iodef_incident_t *incident, iodef_additional_data_t *additional_data_cur)
{
        libiodef_list_t *tmp = (additional_data_cur) ? &((libiodef_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->additional_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_additional_data:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #iodef_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_additional_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_additional_data(iodef_incident_t *ptr, iodef_additional_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_additional_data:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_additional_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_additional_data_t object. The created #iodef_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_additional_data(iodef_incident_t *ptr, iodef_additional_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_end_time:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get end_time children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_incident_get_end_time(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;
}

/**
 * iodef_incident_set_end_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @end_time: pointer to a #iodef_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodef_incident_set_end_time(iodef_incident_t *ptr, iodef_time_t *end_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->end_time )
                iodef_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}

/**
 * iodef_incident_new_end_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new end_time object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_end_time(iodef_incident_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodef_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->end_time;
        return 0;
}

/**
 * iodef_incident_get_next_description:
 * @incident: pointer to a #iodef_incident_t object.
 * @libiodef_string_cur: pointer to a #libiodef_string_t object.
 *
 * Get the next #libiodef_string_t object listed in @ptr.
 * When iterating over the libiodef_string_t object listed in @ptr,
 * @object should be set to the latest returned #libiodef_string_t object.
 *
 * Returns: the next #libiodef_string_t in the list.
 */
libiodef_string_t *iodef_incident_get_next_description(iodef_incident_t *incident, libiodef_string_t *libiodef_string_cur)
{
        libiodef_list_t *tmp = (libiodef_string_cur) ? &((libiodef_linked_object_t *) libiodef_string_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->description_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_description:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #libiodef_string_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #libiodef_string_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_description(iodef_incident_t *ptr, libiodef_string_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_description:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 * @pos: position in the list.
 *
 * Create a new #libiodef_string_t children of @ptr, and add it to position @pos of
 * @ptr list of #libiodef_string_t object. The created #libiodef_string_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_description(iodef_incident_t *ptr, libiodef_string_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = libiodef_string_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->description_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_next_contact:
 * @incident: pointer to a #iodef_incident_t object.
 * @contact_cur: pointer to a #iodef_contact_t object.
 *
 * Get the next #iodef_contact_t object listed in @ptr.
 * When iterating over the iodef_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_contact_t object.
 *
 * Returns: the next #iodef_contact_t in the list.
 */
iodef_contact_t *iodef_incident_get_next_contact(iodef_incident_t *incident, iodef_contact_t *contact_cur)
{
        libiodef_list_t *tmp = (contact_cur) ? &((libiodef_linked_object_t *) contact_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->contact_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_contact:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #iodef_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_contact_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_contact(iodef_incident_t *ptr, iodef_contact_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_contact:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_contact_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_contact_t object. The created #iodef_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_contact(iodef_incident_t *ptr, iodef_contact_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_alternative_id:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get alternative_id children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_alternative_id_t object, or NULL if the children object is not set.
 */
iodef_alternative_id_t *iodef_incident_get_alternative_id(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->alternative_id;
}

/**
 * iodef_incident_set_alternative_id:
 * @ptr: pointer to a #iodef_incident_t object.
 * @alternative_id: pointer to a #iodef_alternative_id_t object.
 *
 * Set @alternative_id object as a children of @ptr.
 * if @ptr already contain an @alternative_id object, then it is destroyed,
 * and updated to point to the provided @alternative_id object.
 */

void iodef_incident_set_alternative_id(iodef_incident_t *ptr, iodef_alternative_id_t *alternative_id)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->alternative_id )
                iodef_alternative_id_destroy(ptr->alternative_id);

        ptr->alternative_id = alternative_id;
}

/**
 * iodef_incident_new_alternative_id:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_alternative_id_t object.
 *
 * Create a new alternative_id object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_alternative_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_alternative_id(iodef_incident_t *ptr, iodef_alternative_id_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->alternative_id ) {
                retval = iodef_alternative_id_new(&ptr->alternative_id);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->alternative_id;
        return 0;
}

/**
 * iodef_incident_get_report_time:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get report_time children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_incident_get_report_time(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->report_time;
}

/**
 * iodef_incident_set_report_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @report_time: pointer to a #iodef_time_t object.
 *
 * Set @report_time object as a children of @ptr.
 * if @ptr already contain an @report_time object, then it is destroyed,
 * and updated to point to the provided @report_time object.
 */

void iodef_incident_set_report_time(iodef_incident_t *ptr, iodef_time_t *report_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->report_time )
                iodef_time_destroy(ptr->report_time);

        ptr->report_time = report_time;
}

/**
 * iodef_incident_new_report_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new report_time object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_report_time(iodef_incident_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->report_time ) {
                retval = iodef_time_new(&ptr->report_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->report_time;
        return 0;
}

/**
 * iodef_incident_get_start_time:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get start_time children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_time_t object, or NULL if the children object is not set.
 */
iodef_time_t *iodef_incident_get_start_time(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;
}

/**
 * iodef_incident_set_start_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @start_time: pointer to a #iodef_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodef_incident_set_start_time(iodef_incident_t *ptr, iodef_time_t *start_time)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->start_time )
                iodef_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}

/**
 * iodef_incident_new_start_time:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_time_t object.
 *
 * Create a new start_time object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_start_time(iodef_incident_t *ptr, iodef_time_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodef_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->start_time;
        return 0;
}

/**
 * iodef_incident_get_next_event_data:
 * @incident: pointer to a #iodef_incident_t object.
 * @event_data_cur: pointer to a #iodef_event_data_t object.
 *
 * Get the next #iodef_event_data_t object listed in @ptr.
 * When iterating over the iodef_event_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_event_data_t object.
 *
 * Returns: the next #iodef_event_data_t in the list.
 */
iodef_event_data_t *iodef_incident_get_next_event_data(iodef_incident_t *incident, iodef_event_data_t *event_data_cur)
{
        libiodef_list_t *tmp = (event_data_cur) ? &((libiodef_linked_object_t *) event_data_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->event_data_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_event_data:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #iodef_event_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_event_data_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_event_data(iodef_incident_t *ptr, iodef_event_data_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->event_data_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_event_data:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_event_data_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_event_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_event_data_t object. The created #iodef_event_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_event_data(iodef_incident_t *ptr, iodef_event_data_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_event_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->event_data_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_related_activity:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get related_activity children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_related_activity_t object, or NULL if the children object is not set.
 */
iodef_related_activity_t *iodef_incident_get_related_activity(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->related_activity;
}

/**
 * iodef_incident_set_related_activity:
 * @ptr: pointer to a #iodef_incident_t object.
 * @related_activity: pointer to a #iodef_related_activity_t object.
 *
 * Set @related_activity object as a children of @ptr.
 * if @ptr already contain an @related_activity object, then it is destroyed,
 * and updated to point to the provided @related_activity object.
 */

void iodef_incident_set_related_activity(iodef_incident_t *ptr, iodef_related_activity_t *related_activity)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->related_activity )
                iodef_related_activity_destroy(ptr->related_activity);

        ptr->related_activity = related_activity;
}

/**
 * iodef_incident_new_related_activity:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_related_activity_t object.
 *
 * Create a new related_activity object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_related_activity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_related_activity(iodef_incident_t *ptr, iodef_related_activity_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->related_activity ) {
                retval = iodef_related_activity_new(&ptr->related_activity);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->related_activity;
        return 0;
}

/**
 * iodef_incident_get_incident_id:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get incident_id children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_incident_id_t object, or NULL if the children object is not set.
 */
iodef_incident_id_t *iodef_incident_get_incident_id(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->incident_id;
}

/**
 * iodef_incident_set_incident_id:
 * @ptr: pointer to a #iodef_incident_t object.
 * @incident_id: pointer to a #iodef_incident_id_t object.
 *
 * Set @incident_id object as a children of @ptr.
 * if @ptr already contain an @incident_id object, then it is destroyed,
 * and updated to point to the provided @incident_id object.
 */

void iodef_incident_set_incident_id(iodef_incident_t *ptr, iodef_incident_id_t *incident_id)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->incident_id )
                iodef_incident_id_destroy(ptr->incident_id);

        ptr->incident_id = incident_id;
}

/**
 * iodef_incident_new_incident_id:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_id_t object.
 *
 * Create a new incident_id object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_incident_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_incident_id(iodef_incident_t *ptr, iodef_incident_id_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->incident_id ) {
                retval = iodef_incident_id_new(&ptr->incident_id);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->incident_id;
        return 0;
}

/**
 * iodef_incident_get_next_assessment:
 * @incident: pointer to a #iodef_incident_t object.
 * @assessment_cur: pointer to a #iodef_assessment_t object.
 *
 * Get the next #iodef_assessment_t object listed in @ptr.
 * When iterating over the iodef_assessment_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_assessment_t object.
 *
 * Returns: the next #iodef_assessment_t in the list.
 */
iodef_assessment_t *iodef_incident_get_next_assessment(iodef_incident_t *incident, iodef_assessment_t *assessment_cur)
{
        libiodef_list_t *tmp = (assessment_cur) ? &((libiodef_linked_object_t *) assessment_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->assessment_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_assessment:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #iodef_assessment_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_assessment_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_assessment(iodef_incident_t *ptr, iodef_assessment_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->assessment_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_assessment:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_assessment_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_assessment_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_assessment_t object. The created #iodef_assessment_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_assessment(iodef_incident_t *ptr, iodef_assessment_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_assessment_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->assessment_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_next_method:
 * @incident: pointer to a #iodef_incident_t object.
 * @method_cur: pointer to a #iodef_method_t object.
 *
 * Get the next #iodef_method_t object listed in @ptr.
 * When iterating over the iodef_method_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_method_t object.
 *
 * Returns: the next #iodef_method_t in the list.
 */
iodef_method_t *iodef_incident_get_next_method(iodef_incident_t *incident, iodef_method_t *method_cur)
{
        libiodef_list_t *tmp = (method_cur) ? &((libiodef_linked_object_t *) method_cur)->_list : NULL;

        libiodef_return_val_if_fail(incident, NULL);

        libiodef_list_for_each_continue(&incident->method_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_incident_set_method:
 * @ptr: pointer to a #iodef_incident_t object.
 * @object: pointer to a #iodef_method_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_method_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_incident_set_method(iodef_incident_t *ptr, iodef_method_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->method_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_incident_new_method:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_method_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_method_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_method_t object. The created #iodef_method_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_method(iodef_incident_t *ptr, iodef_method_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_method_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->method_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_incident_get_history:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get history children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_history_t object, or NULL if the children object is not set.
 */
iodef_history_t *iodef_incident_get_history(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->history;
}

/**
 * iodef_incident_set_history:
 * @ptr: pointer to a #iodef_incident_t object.
 * @history: pointer to a #iodef_history_t object.
 *
 * Set @history object as a children of @ptr.
 * if @ptr already contain an @history object, then it is destroyed,
 * and updated to point to the provided @history object.
 */

void iodef_incident_set_history(iodef_incident_t *ptr, iodef_history_t *history)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->history )
                iodef_history_destroy(ptr->history);

        ptr->history = history;
}

/**
 * iodef_incident_new_history:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_history_t object.
 *
 * Create a new history object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_history_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_history(iodef_incident_t *ptr, iodef_history_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->history ) {
                retval = iodef_history_new(&ptr->history);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->history;
        return 0;
}

/**
 * iodef_incident_get_lang:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get lang children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_incident_lang_t object, or NULL if the children object is not set.
 */
iodef_incident_lang_t iodef_incident_get_lang(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;
}

/**
 * iodef_incident_set_lang:
 * @ptr: pointer to a #iodef_incident_t object.
 * @lang: pointer to a #iodef_incident_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */

void iodef_incident_set_lang(iodef_incident_t *ptr, iodef_incident_lang_t lang)
{
        libiodef_return_if_fail(ptr);
        ptr->lang = lang;
}

/**
 * iodef_incident_new_lang:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_lang_t object.
 *
 * Create a new lang object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_incident_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_lang(iodef_incident_t *ptr, iodef_incident_lang_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->lang;
        return 0;
}

/**
 * iodef_incident_get_restriction:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get restriction children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_incident_restriction_t object, or NULL if the children object is not set.
 */
iodef_incident_restriction_t iodef_incident_get_restriction(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction;
}

/**
 * iodef_incident_set_restriction:
 * @ptr: pointer to a #iodef_incident_t object.
 * @restriction: pointer to a #iodef_incident_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */

void iodef_incident_set_restriction(iodef_incident_t *ptr, iodef_incident_restriction_t restriction)
{
        libiodef_return_if_fail(ptr);
        ptr->restriction = restriction;
}

/**
 * iodef_incident_new_restriction:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_restriction_t object.
 *
 * Create a new restriction object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_incident_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_restriction(iodef_incident_t *ptr, iodef_incident_restriction_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->restriction;
        return 0;
}

/**
 * iodef_incident_get_ext_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get ext_purpose children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_incident_get_ext_purpose(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_purpose;
}

/**
 * iodef_incident_set_ext_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ext_purpose: pointer to a #libiodef_string_t object.
 *
 * Set @ext_purpose object as a children of @ptr.
 * if @ptr already contain an @ext_purpose object, then it is destroyed,
 * and updated to point to the provided @ext_purpose object.
 */

void iodef_incident_set_ext_purpose(iodef_incident_t *ptr, libiodef_string_t *ext_purpose)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->ext_purpose )
                libiodef_string_destroy(ptr->ext_purpose);

        ptr->ext_purpose = ext_purpose;
}

/**
 * iodef_incident_new_ext_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new ext_purpose object, children of #iodef_incident_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_ext_purpose(iodef_incident_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->ext_purpose ) {
                retval = libiodef_string_new(&ptr->ext_purpose);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->ext_purpose;
        return 0;
}

/**
 * iodef_incident_get_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 *
 * Get purpose children of the #iodef_incident_t object.
 *
 * Returns: a pointer to a iodef_incident_purpose_t object, or NULL if the children object is not set.
 */
iodef_incident_purpose_t iodef_incident_get_purpose(iodef_incident_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->purpose;
}

/**
 * iodef_incident_set_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 * @purpose: pointer to a #iodef_incident_purpose_t object.
 *
 * Set @purpose object as a children of @ptr.
 * if @ptr already contain an @purpose object, then it is destroyed,
 * and updated to point to the provided @purpose object.
 */

void iodef_incident_set_purpose(iodef_incident_t *ptr, iodef_incident_purpose_t purpose)
{
        libiodef_return_if_fail(ptr);
        ptr->purpose = purpose;
}

/**
 * iodef_incident_new_purpose:
 * @ptr: pointer to a #iodef_incident_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_purpose_t object.
 *
 * Create a new purpose object, children of #iodef_incident_t.
 * If @ptr already contain a #iodef_incident_purpose_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_incident_new_purpose(iodef_incident_t *ptr, iodef_incident_purpose_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->purpose;
        return 0;
}

/**
 * iodef_incident_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_incident_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_copy(const iodef_incident_t *src, iodef_incident_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        if ( dst->detect_time ) {
                iodef_time_destroy(dst->detect_time);
                dst->detect_time = NULL;
        }

        if ( src->detect_time ) {
                ret = iodef_time_clone(src->detect_time, &dst->detect_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_additional_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->additional_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_additional_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->additional_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->end_time ) {
                iodef_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodef_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                libiodef_string_t *entry, *new;

                libiodef_list_for_each_safe(&dst->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->description_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_string_clone(entry, &new);
                        libiodef_list_add_tail(&dst->description_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_contact_t *entry, *new;

                libiodef_list_for_each_safe(&dst->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->contact_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_contact_clone(entry, &new);
                        libiodef_list_add_tail(&dst->contact_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->alternative_id ) {
                iodef_alternative_id_destroy(dst->alternative_id);
                dst->alternative_id = NULL;
        }

        if ( src->alternative_id ) {
                ret = iodef_alternative_id_clone(src->alternative_id, &dst->alternative_id);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->report_time ) {
                ret = iodef_time_copy(src->report_time, dst->report_time);
                if ( ret < 0 )
                        return ret;
        }

        if ( dst->start_time ) {
                iodef_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodef_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_event_data_t *entry, *new;

                libiodef_list_for_each_safe(&dst->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_event_data_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->event_data_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_event_data_clone(entry, &new);
                        libiodef_list_add_tail(&dst->event_data_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->related_activity ) {
                iodef_related_activity_destroy(dst->related_activity);
                dst->related_activity = NULL;
        }

        if ( src->related_activity ) {
                ret = iodef_related_activity_clone(src->related_activity, &dst->related_activity);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->incident_id ) {
                ret = iodef_incident_id_copy(src->incident_id, dst->incident_id);
                if ( ret < 0 )
                        return ret;
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_assessment_t *entry, *new;

                libiodef_list_for_each_safe(&dst->assessment_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_assessment_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->assessment_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_assessment_clone(entry, &new);
                        libiodef_list_add_tail(&dst->assessment_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        {
                libiodef_list_t *n, *tmp;
                iodef_method_t *entry, *new;

                libiodef_list_for_each_safe(&dst->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_method_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->method_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_method_clone(entry, &new);
                        libiodef_list_add_tail(&dst->method_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        if ( dst->history ) {
                iodef_history_destroy(dst->history);
                dst->history = NULL;
        }

        if ( src->history ) {
                ret = iodef_history_clone(src->history, &dst->history);
                if ( ret < 0 )
                        return ret;
        }

        dst->lang = src->lang;

        dst->restriction = src->restriction;

        if ( dst->ext_purpose ) {
                libiodef_string_destroy(dst->ext_purpose);
                dst->ext_purpose = NULL;
        }

        if ( src->ext_purpose ) {
                ret = libiodef_string_clone(src->ext_purpose, &dst->ext_purpose);
                if ( ret < 0 )
                        return ret;
        }

        dst->purpose = src->purpose;

        return 0;
}

/**
 * iodef_incident_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_incident_clone(iodef_incident_t *src, iodef_incident_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_incident_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_incident_copy(src, *dst);
}

/**
 * iodef_incident_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_incident_compare(const iodef_incident_t *obj1, const iodef_incident_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        ret = iodef_time_compare(obj1->detect_time, obj2->detect_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_additional_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->additional_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                libiodef_string_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->description_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->description_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = libiodef_string_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_contact_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->contact_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_alternative_id_compare(obj1->alternative_id, obj2->alternative_id);
        if ( ret != 0 )
                return ret;

        ret = iodef_time_compare(obj1->report_time, obj2->report_time);
        if ( ret != 0 )
                return ret;

        ret = iodef_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_event_data_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->event_data_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->event_data_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_event_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_related_activity_compare(obj1->related_activity, obj2->related_activity);
        if ( ret != 0 )
                return ret;

        ret = iodef_incident_id_compare(obj1->incident_id, obj2->incident_id);
        if ( ret != 0 )
                return ret;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_assessment_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->assessment_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->assessment_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_assessment_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_method_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->method_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->method_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_method_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        ret = iodef_history_compare(obj1->history, obj2->history);
        if ( ret != 0 )
                return ret;

        if ( obj1->lang != obj2->lang )
                return -1;

        if ( obj1->restriction != obj2->restriction )
                return -1;

        ret = libiodef_string_compare(obj1->ext_purpose, obj2->ext_purpose);
        if ( ret != 0 )
                return ret;

        if ( obj1->purpose != obj2->purpose )
                return -1;

        return ret;
}

/**
 * iodef_document_new:
 * @ret: Pointer where to store the created #iodef_document_t object.
 *
 * Create a new #iodef_document_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_document_new(iodef_document_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodef_error_from_errno(errno);

        (*ret)->_iodef_object_id = IODEF_CLASS_ID_DOCUMENT;

        (*ret)->refcount = 1;

        libiodef_list_init(&(*ret)->incident_list);


        {
                int retval = libiodef_string_new(&(*ret)->version);

                if ( retval < 0 ) {
                        iodef_document_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }

        return 0;

}

/**
 * iodef_document_ref:
 * @document: pointer to a #iodef_document_t object.
 *
 * Increase @document reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @document.
 */
iodef_document_t *iodef_document_ref(iodef_document_t *document)
{
        libiodef_return_val_if_fail(document, NULL);
        document->refcount++;

        return document;
}

int _iodef_document_get_child(void *p, iodef_class_child_id_t child, void **childptr)
{
        iodef_document_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) {

                case 0:
                        *childptr = &ptr->incident_list;
                        return 0;

                case 1:
                       return iodef_value_new_enum_from_numeric((iodef_value_t **) childptr,
                                                                IODEF_CLASS_ID_DOCUMENT_LANG, ptr->lang);

                case 2:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->formatid, TRUE);
                case 3:
                       return get_value_from_string((iodef_value_t **) childptr,  ptr->version, TRUE);
                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_document_new_child(void *p, iodef_class_child_id_t child, int n, void **ret)
{
        iodef_document_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n == IODEF_LIST_APPEND || n == IODEF_LIST_PREPEND )
                               return iodef_document_new_incident(ptr, (iodef_incident_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodef_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }

                        return iodef_document_new_incident(ptr, (iodef_incident_t **) ret, n);
                }

                case 1:
                        return iodef_document_new_lang(ptr, (iodef_document_lang_t **) ret);

                case 2:
                        return iodef_document_new_formatid(ptr, (libiodef_string_t **) ret);

                case 3:
                        return iodef_document_new_version(ptr, (libiodef_string_t **) ret);

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

int _iodef_document_destroy_child(void *p, iodef_class_child_id_t child, int n)
{
        iodef_document_t *ptr = p;

        libiodef_return_val_if_fail(p, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        switch ( child ) {

                case 0: {
                        int i = 0;
                        libiodef_list_t *tmp;

                        if ( n >= 0 ) {
                               libiodef_list_for_each(&ptr->incident_list, tmp) {
                                       if ( i++ == n ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodef_list_for_each_reversed(&ptr->incident_list, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = libiodef_linked_object_get_object(tmp);
                                               iodef_incident_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodef_error(LIBIODEF_ERROR_IODEF_TREE_INDEX_UNDEFINED);
                        }
                }

                case 1:
                        ptr->lang = 0;
                        return 0;

                case 2:
                        if ( ptr->formatid ) {
                                libiodef_string_destroy(ptr->formatid);
                                ptr->formatid = NULL;
                        }

                        return 0;

                case 3:
                        if ( ptr->version ) {
                                libiodef_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;

                default:
                        return libiodef_error(LIBIODEF_ERROR_IODEF_CLASS_UNKNOWN_CHILD);
        }
}

static void iodef_document_destroy_internal(iodef_document_t *ptr)
{
        libiodef_return_if_fail(ptr);

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_t *entry;

                libiodef_list_for_each_safe(&ptr->incident_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        libiodef_list_del_init(tmp);
                        iodef_incident_destroy(entry);
                }
        }

        if ( ptr->formatid ) {
                libiodef_string_destroy(ptr->formatid);
                ptr->formatid = NULL;
        }

        if ( ptr->version ) {
                libiodef_string_destroy(ptr->version);
                ptr->version = NULL;
        }


        /* free() should be done by the caller */
}

/**
 * iodef_document_get_next_incident:
 * @document: pointer to a #iodef_document_t object.
 * @incident_cur: pointer to a #iodef_incident_t object.
 *
 * Get the next #iodef_incident_t object listed in @ptr.
 * When iterating over the iodef_incident_t object listed in @ptr,
 * @object should be set to the latest returned #iodef_incident_t object.
 *
 * Returns: the next #iodef_incident_t in the list.
 */
iodef_incident_t *iodef_document_get_next_incident(iodef_document_t *document, iodef_incident_t *incident_cur)
{
        libiodef_list_t *tmp = (incident_cur) ? &((libiodef_linked_object_t *) incident_cur)->_list : NULL;

        libiodef_return_val_if_fail(document, NULL);

        libiodef_list_for_each_continue(&document->incident_list, tmp)
                return libiodef_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodef_document_set_incident:
 * @ptr: pointer to a #iodef_document_t object.
 * @object: pointer to a #iodef_incident_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodef_incident_t object.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodef_document_set_incident(iodef_document_t *ptr, iodef_incident_t *object, int pos)
{
        libiodef_return_if_fail(ptr);
        libiodef_return_if_fail(object);

        if ( ! libiodef_list_is_empty(&((libiodef_linked_object_t *) object)->_list) )
                libiodef_list_del_init(&((libiodef_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_list, &((libiodef_linked_object_t *) object)->_list, pos);
}


/**
 * iodef_document_new_incident:
 * @ptr: pointer to a #iodef_document_t object.
 * @ret: pointer to an address where to store the created #iodef_incident_t object.
 * @pos: position in the list.
 *
 * Create a new #iodef_incident_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodef_incident_t object. The created #iodef_incident_t object is
 * stored in @ret.
 *
 * If @pos is #IODEF_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEF_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_document_new_incident(iodef_document_t *ptr, iodef_incident_t **ret, int pos)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        retval = iodef_incident_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_list, &((libiodef_linked_object_t *)(*ret))->_list, pos);

        return 0;
}


/**
 * iodef_document_get_lang:
 * @ptr: pointer to a #iodef_document_t object.
 *
 * Get lang children of the #iodef_document_t object.
 *
 * Returns: a pointer to a iodef_document_lang_t object, or NULL if the children object is not set.
 */
iodef_document_lang_t iodef_document_get_lang(iodef_document_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;
}

/**
 * iodef_document_set_lang:
 * @ptr: pointer to a #iodef_document_t object.
 * @lang: pointer to a #iodef_document_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */

void iodef_document_set_lang(iodef_document_t *ptr, iodef_document_lang_t lang)
{
        libiodef_return_if_fail(ptr);
        ptr->lang = lang;
}

/**
 * iodef_document_new_lang:
 * @ptr: pointer to a #iodef_document_t object.
 * @ret: pointer to an address where to store the created #iodef_document_lang_t object.
 *
 * Create a new lang object, children of #iodef_document_t.
 * If @ptr already contain a #iodef_document_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_document_new_lang(iodef_document_t *ptr, iodef_document_lang_t **ret)
{
        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        *ret = &ptr->lang;
        return 0;
}

/**
 * iodef_document_get_formatid:
 * @ptr: pointer to a #iodef_document_t object.
 *
 * Get formatid children of the #iodef_document_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_document_get_formatid(iodef_document_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->formatid;
}

/**
 * iodef_document_set_formatid:
 * @ptr: pointer to a #iodef_document_t object.
 * @formatid: pointer to a #libiodef_string_t object.
 *
 * Set @formatid object as a children of @ptr.
 * if @ptr already contain an @formatid object, then it is destroyed,
 * and updated to point to the provided @formatid object.
 */

void iodef_document_set_formatid(iodef_document_t *ptr, libiodef_string_t *formatid)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->formatid )
                libiodef_string_destroy(ptr->formatid);

        ptr->formatid = formatid;
}

/**
 * iodef_document_new_formatid:
 * @ptr: pointer to a #iodef_document_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new formatid object, children of #iodef_document_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_document_new_formatid(iodef_document_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->formatid ) {
                retval = libiodef_string_new(&ptr->formatid);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->formatid;
        return 0;
}

/**
 * iodef_document_get_version:
 * @ptr: pointer to a #iodef_document_t object.
 *
 * Get version children of the #iodef_document_t object.
 *
 * Returns: a pointer to a libiodef_string_t object, or NULL if the children object is not set.
 */
libiodef_string_t *iodef_document_get_version(iodef_document_t *ptr)
{
        libiodef_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;
}

/**
 * iodef_document_set_version:
 * @ptr: pointer to a #iodef_document_t object.
 * @version: pointer to a #libiodef_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodef_document_set_version(iodef_document_t *ptr, libiodef_string_t *version)
{
        libiodef_return_if_fail(ptr);

        if ( ptr->version )
                libiodef_string_destroy(ptr->version);

        ptr->version = version;
}

/**
 * iodef_document_new_version:
 * @ptr: pointer to a #iodef_document_t object.
 * @ret: pointer to an address where to store the created #libiodef_string_t object.
 *
 * Create a new version object, children of #iodef_document_t.
 * If @ptr already contain a #libiodef_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodef_document_new_version(iodef_document_t *ptr, libiodef_string_t **ret)
{
        int retval;

        libiodef_return_val_if_fail(ptr, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodef_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }

        *ret = ptr->version;
        return 0;
}

/**
 * iodef_document_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodef_document_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_document_copy(const iodef_document_t *src, iodef_document_t *dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));
        libiodef_return_val_if_fail(dst, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = 0;

        {
                libiodef_list_t *n, *tmp;
                iodef_incident_t *entry, *new;

                libiodef_list_for_each_safe(&dst->incident_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_destroy(entry);
                }

                libiodef_list_for_each_safe(&src->incident_list, tmp, n) {
                        entry = libiodef_linked_object_get_object(tmp);
                        iodef_incident_clone(entry, &new);
                        libiodef_list_add_tail(&dst->incident_list, &((libiodef_linked_object_t *) new)->_list);
                }
        }

        dst->lang = src->lang;

        if ( dst->formatid ) {
                libiodef_string_destroy(dst->formatid);
                dst->formatid = NULL;
        }

        if ( src->formatid ) {
                ret = libiodef_string_clone(src->formatid, &dst->formatid);
                if ( ret < 0 )
                        return ret;
        }

        if ( src->version ) {
                ret = libiodef_string_copy(src->version, dst->version);
                if ( ret < 0 )
                        return ret;
        }

        return 0;
}

/**
 * iodef_document_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodef_document_clone(iodef_document_t *src, iodef_document_t **dst)
{
        int ret;

        libiodef_return_val_if_fail(src, libiodef_error(LIBIODEF_ERROR_ASSERTION));

        ret = iodef_document_new(dst);
        if ( ret < 0 )
                return ret;

        return iodef_document_copy(src, *dst);
}

/**
 * iodef_document_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodef_document_compare(const iodef_document_t *obj1, const iodef_document_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;

        {
                libiodef_list_t *tmp1, *tmp2;
                iodef_incident_t *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do {
                        entry1 = entry2 = NULL;

                        libiodef_list_for_each_continue(&obj1->incident_list, tmp1) {
                                entry1 = libiodef_linked_object_get_object(tmp1);
                                break;
                        }

                        libiodef_list_for_each_continue(&obj2->incident_list, tmp2) {
                                entry2 = libiodef_linked_object_get_object(tmp2);
                                break;
                        }

                        ret = iodef_incident_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                } while ( entry1 && entry2 );
        }

        if ( obj1->lang != obj2->lang )
                return -1;

        ret = libiodef_string_compare(obj1->formatid, obj2->formatid);
        if ( ret != 0 )
                return ret;

        ret = libiodef_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        return ret;
}


int _iodef_additional_data_type_is_set(iodef_additional_data_t *ad)
{
        return ad->_type_is_set;
}


/**
 * iodef_document_destroy:
 * @ptr: pointer to a #iodef_document_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodef_document_destroy(iodef_document_t *ptr)
{
        libiodef_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodef_document_destroy_internal(ptr);

        free(ptr);
}
